<!DOCTYPE html><html><head><meta charset="utf-8"><title>php中的autoload | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="PHP,"><meta name="description" content="php中的autoloadPHP中当一个类依赖于另一个类时，原始的方法是require该文件，当项目or框架中存在大量的类文件时，需要require每个需要的PHP文件，而autoload可以让PHP在执行时引入需要的类文件。__autoloadphp5提供了__autoload方法来实现类的自动加载,当遇到未加载的类时，会调用__autoload方法进行require。使用__autoload的"><meta name="keywords" content="PHP"><meta property="og:type" content="article"><meta property="og:title" content="php中的autoload"><meta property="og:url" content="http://longlog.me/2016/04/07/php-autoload/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="php中的autoloadPHP中当一个类依赖于另一个类时，原始的方法是require该文件，当项目or框架中存在大量的类文件时，需要require每个需要的PHP文件，而autoload可以让PHP在执行时引入需要的类文件。__autoloadphp5提供了__autoload方法来实现类的自动加载,当遇到未加载的类时，会调用__autoload方法进行require。使用__autoload的"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2018-08-06T12:12:41.825Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="php中的autoload"><meta name="twitter:description" content="php中的autoloadPHP中当一个类依赖于另一个类时，原始的方法是require该文件，当项目or框架中存在大量的类文件时，需要require每个需要的PHP文件，而autoload可以让PHP在执行时引入需要的类文件。__autoloadphp5提供了__autoload方法来实现类的自动加载,当遇到未加载的类时，会调用__autoload方法进行require。使用__autoload的"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#php中的autoload"><span class="toc-text">php中的autoload</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#autoload"><span class="toc-text">__autoload</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spl-autoload-register"><span class="toc-text">spl_autoload_register</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区别"><span class="toc-text">区别</span></a></li></ol></li></ol></div><div class="content-post LEFT"><article id="post-php-autoload" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">php中的autoload</h1><div class="article-meta"><span>2016-04-07</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/PHP/">PHP</a></span></div></header><div class="article-content"><h1 id="php中的autoload"><a href="#php中的autoload" class="headerlink" title="php中的autoload"></a>php中的autoload</h1><p>PHP中当一个类依赖于另一个类时，原始的方法是require该文件，当项目or框架中存在大量的类文件时，需要require每个需要的PHP文件，而autoload可以让PHP在执行时引入需要的类文件。</p><h2 id="autoload"><a href="#autoload" class="headerlink" title="__autoload"></a>__autoload</h2><p>php5提供了<code>__autoload</code>方法来实现类的自动加载,当遇到未加载的类时，会调用<code>__autoload</code>方法进行require。<br>使用<code>__autoload</code>的一个例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法必须在全局(global)内能进行访问</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($class)</span> </span>&#123;</span><br><span class="line">    $file = dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">"/$class.class.php"</span>;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($file)) &#123;</span><br><span class="line">        <span class="keyword">require_once</span>($file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$hehe = <span class="keyword">new</span> Heher();</span><br><span class="line">$hehe-&gt;sendHehe();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Heher.class.php</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sendHehe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"I'm from auto load , Hehe!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spl-autoload-register"><a href="#spl-autoload-register" class="headerlink" title="spl_autoload_register"></a>spl_autoload_register</h2><p>PHP 在 5.1.2 以後提供了SPL，SPL 全名為 Standard PHP Library，为一系列基础的工具类以及方法，<code>spl_autoload_register</code>提供了比<code>__autoload</code>更为强大的功能。<br><code>spl_autoload_register</code>的使用：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_hehe_autoload</span><span class="params">($class)</span> </span>&#123;</span><br><span class="line">    $file = dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">"/$class.class.php"</span>;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($file)) &#123;</span><br><span class="line">        <span class="keyword">require_once</span>($file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(<span class="string">'_hehe_autoload'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.3之后可以使用匿名函数</span></span><br><span class="line">spl_autoload_register(<span class="function"><span class="keyword">function</span> <span class="params">($class)</span> </span>&#123;</span><br><span class="line">    $file = dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">"/$class.class.php"</span>;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($file)) &#123;</span><br><span class="line">        <span class="keyword">require_once</span>($file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$hehe = <span class="keyword">new</span> Heher();</span><br><span class="line">$hehe-&gt;sendHehe();</span><br></pre></td></tr></table></figure><p>可以注册类的静态方法进行load：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoadClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">_hehe_autoload</span><span class="params">($class)</span> </span>&#123;</span><br><span class="line">        $file = dirname(<span class="keyword">__FILE__</span>) . DIRECTORY_SEPARATOR . <span class="string">"/$class.class.php"</span>;</span><br><span class="line">        <span class="keyword">if</span> (file_exists($file)) &#123;</span><br><span class="line">            <span class="keyword">require_once</span>($file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(<span class="keyword">array</span>(<span class="string">'LoadClass'</span>, <span class="string">'_hehe_autoload'</span>));</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>1.<code>spl_autoload_register</code>能注册多个自动加载函数，按注册的顺序依次执行，而<code>__autoload</code>方法只允许定义一次。</p><blockquote><p>If there must be multiple autoload functions, spl_autoload_register() allows for this. It effectively creates a queue of autoload functions, and runs through each of them in the order they are defined. By contrast, __autoload() may only be defined once.</p></blockquote><p>2.spl注册的函数能进行其他操作，用<code>spl_autoload_unregister</code>可以注销函数，用<code>spl_autoload_functions</code>可以查看已经注册的函数，在这些机器上可以对自动加载做更灵活的操作。</p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2016/04/07/php-autoload/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>