<!DOCTYPE html><html><head><meta charset="utf-8"><title>Golang模拟一致性哈希 | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Golang,分布式,"><meta name="description" content="参考链接- 一致性哈希原理与实践关于一致性哈希算法的原理网上很多讲解和实践，这里不再赘述。本文主要是通过代码验证一致性哈希带来的变化以及问题。普通哈希直接对数据进行哈希计算后取模确定数据存入的节点，如果集群的节点数量发生变更时，几乎需要对所有数据进行重新映射。 普通哈希的优势在于数据的分布比较均匀。程序测试结果如下，增加一个节点的情况下，需要转移的数据比例达到99%，几乎所有数据都需要进行节点迁移"><meta name="keywords" content="Golang,分布式"><meta property="og:type" content="article"><meta property="og:title" content="Golang模拟一致性哈希"><meta property="og:url" content="http://longlog.me/2018/08/06/2018-08-06-dist-hash/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="参考链接- 一致性哈希原理与实践关于一致性哈希算法的原理网上很多讲解和实践，这里不再赘述。本文主要是通过代码验证一致性哈希带来的变化以及问题。普通哈希直接对数据进行哈希计算后取模确定数据存入的节点，如果集群的节点数量发生变更时，几乎需要对所有数据进行重新映射。 普通哈希的优势在于数据的分布比较均匀。程序测试结果如下，增加一个节点的情况下，需要转移的数据比例达到99%，几乎所有数据都需要进行节点迁移"><meta property="og:locale" content="default"><meta property="og:image" content="http://7xrhmq.com1.z0.glb.clouddn.com/2018-08-06-15335478450167.png"><meta property="og:image" content="http://7xrhmq.com1.z0.glb.clouddn.com/2018-08-06-15335480401709.png"><meta property="og:updated_time" content="2018-08-07T03:43:39.129Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Golang模拟一致性哈希"><meta name="twitter:description" content="参考链接- 一致性哈希原理与实践关于一致性哈希算法的原理网上很多讲解和实践，这里不再赘述。本文主要是通过代码验证一致性哈希带来的变化以及问题。普通哈希直接对数据进行哈希计算后取模确定数据存入的节点，如果集群的节点数量发生变更时，几乎需要对所有数据进行重新映射。 普通哈希的优势在于数据的分布比较均匀。程序测试结果如下，增加一个节点的情况下，需要转移的数据比例达到99%，几乎所有数据都需要进行节点迁移"><meta name="twitter:image" content="http://7xrhmq.com1.z0.glb.clouddn.com/2018-08-06-15335478450167.png"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2018/08/06/2018-Target/">2018</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2018/08/06/2018-Target/">2018</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#普通哈希"><span class="toc-text">普通哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试代码"><span class="toc-text">测试代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一致性哈希"><span class="toc-text">一致性哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试代码-1"><span class="toc-text">测试代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟节点"><span class="toc-text">虚拟节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试代码-2"><span class="toc-text">测试代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附-测试主程序"><span class="toc-text">附-测试主程序</span></a></li></ol></div><div class="content-post LEFT"><article id="post-2018-08-06-dist-hash" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">Golang模拟一致性哈希</h1><div class="article-meta"><span>2018-08-06</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/架构/">架构</a></span></div></header><div class="article-content"><p><a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">参考链接- 一致性哈希原理与实践</a><br>关于一致性哈希算法的原理网上很多讲解和实践，这里不再赘述。本文主要是通过代码验证一致性哈希带来的变化以及问题。</p><h2 id="普通哈希"><a href="#普通哈希" class="headerlink" title="普通哈希"></a>普通哈希</h2><p>直接对数据进行哈希计算后取模确定数据存入的节点，如果集群的节点数量发生变更时，几乎需要对所有数据进行重新映射。 普通哈希的优势在于数据的分布比较均匀。<br>程序测试结果如下，增加一个节点的情况下，<strong>需要转移的数据比例达到99%</strong>，几乎所有数据都需要进行节点迁移。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CaculateChange needTransNum:990173  Percentage:0.990173 </span><br><span class="line">CaculateDist Avg:10000.00  Max:10254(102.54) Min:9791(97.91)</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NodesNum = <span class="number">100</span>      <span class="comment">//原始节点数量</span></span><br><span class="line"><span class="keyword">const</span> NewNodesNum = <span class="number">101</span>   <span class="comment">//扩充后的节点数量</span></span><br><span class="line"><span class="keyword">const</span> ItemsNum = <span class="number">1000000</span>  <span class="comment">//数据数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HashTest <span class="keyword">interface</span> &#123;</span><br><span class="line">	CaculateDist()    <span class="comment">//计算各个节点的数据数量，可以反馈出数据的均匀成都</span></span><br><span class="line">	CaculateChange()  <span class="comment">//计算在增加一个节点的情况下，数据迁移量及占比</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NormalHash <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NormalHash)</span> <span class="title">CaculateDist</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nodeStat := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ItemsNum; i++ &#123;</span><br><span class="line">		hashi := GetHash(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line"></span><br><span class="line">		saveNode := GetByteMode(hashi, NodesNum)  <span class="comment">//普通哈希算法，直接取模得到节点数</span></span><br><span class="line">		nodeStat[saveNode] += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	avg := ItemsNum * <span class="number">1.0</span> / NodesNum</span><br><span class="line">	<span class="keyword">var</span> max <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> min <span class="keyword">int64</span> = math.MaxInt64</span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> nodeStat &#123;</span><br><span class="line">		<span class="keyword">if</span> n &gt; max &#123;</span><br><span class="line">			max = n</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> n &lt; min &#123;</span><br><span class="line">			min = n</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"CaculateDist Avg:%.2f  Max:%d(%.2f) Min:%d(%.2f)"</span>, avg, max, <span class="keyword">float64</span>(max) / avg * <span class="number">100</span>, min, <span class="keyword">float64</span>(min) / avg * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当增加一个节点时，需要进行迁移的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NormalHash)</span> <span class="title">CaculateChange</span><span class="params">()</span></span> &#123;</span><br><span class="line">	needTrans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ItemsNum; i++ &#123;</span><br><span class="line">		hashi := GetHash(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line"></span><br><span class="line">		saveNode := GetByteMode(hashi, NodesNum)</span><br><span class="line">		saveNodeNew := GetByteMode(hashi, NewNodesNum)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (saveNode != saveNodeNew) &#123;</span><br><span class="line">			needTrans += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"CaculateChange needTransNum:%d  Percentage:%f \n"</span>, needTrans, <span class="keyword">float64</span>(needTrans) / ItemsNum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>一致性哈希如图，通过将节点进行哈希后映射到环上，数据计算哈希后存储到最近的节点中。优势是节点数量变更时，迁移的数据量大大减少，问题是会带来数据分布不均。<br><img src="http://7xrhmq.com1.z0.glb.clouddn.com/2018-08-06-15335478450167.png" alt=""></p><p>测试结果，<strong>在增加一个节点场景下，数据转移比例只有0.4%</strong>。但是也可以看出来，数据的分布极其不均匀</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ConsistHash:</span><br><span class="line">CaculateChange needTransNum:4057  Percentage:0.004057 </span><br><span class="line">CaculateDist Avg:10000.00  Max:39257(392.57) Min:32(0.32)</span><br></pre></td></tr></table></figure><h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConsistHash <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ConsistHash)</span> <span class="title">CaculateDist</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nodeStat := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>)</span><br><span class="line">	chInstance := ConsistHashInstance&#123;&#125;</span><br><span class="line">	chInstance.Init(NodesNum)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ItemsNum; i++ &#123;</span><br><span class="line">		node := chInstance.GetItemNode(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line">		nodeStat[node]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	avg := ItemsNum * <span class="number">1.0</span> / NodesNum</span><br><span class="line">	<span class="keyword">var</span> max <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> min <span class="keyword">int64</span> = math.MaxInt64</span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> nodeStat &#123;</span><br><span class="line">		<span class="keyword">if</span> n &gt; max &#123;</span><br><span class="line">			max = n</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> n &lt; min &#123;</span><br><span class="line">			min = n</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"CaculateDist Avg:%.2f  Max:%d(%.2f) Min:%d(%.2f)"</span>, avg, max, <span class="keyword">float64</span>(max) / avg * <span class="number">100</span>, min, <span class="keyword">float64</span>(min) / avg * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当增加一个节点时，需要进行迁移的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ConsistHash)</span> <span class="title">CaculateChange</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	chInstance := ConsistHashInstance&#123;&#125;</span><br><span class="line">	chInstance.Init(NodesNum)</span><br><span class="line"></span><br><span class="line">	chInstance2 := ConsistHashInstance&#123;&#125;</span><br><span class="line">	chInstance2.Init(NodesNum + <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">	needTrans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ItemsNum; i++ &#123;</span><br><span class="line">		node := chInstance.GetItemNode(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line">		nodeNew := chInstance2.GetItemNode(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line">		<span class="keyword">if</span>(node != nodeNew) &#123;</span><br><span class="line">			needTrans++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"CaculateChange needTransNum:%d  Percentage:%f \n"</span>, needTrans, <span class="keyword">float64</span>(needTrans) / ItemsNum)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConsistHashInstance <span class="keyword">struct</span> &#123;</span><br><span class="line">	hashToNode <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span></span><br><span class="line">	nodeHashs NodeHashArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeHashArray []<span class="keyword">string</span></span><br><span class="line"><span class="comment">//实现排序接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p NodeHashArray)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p NodeHashArray)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p NodeHashArray)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p NodeHashArray)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123;sort.Sort(p)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据分配的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ConsistHashInstance)</span> <span class="title">GetItemNode</span><span class="params">(item <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	<span class="comment">//计算item-hash</span></span><br><span class="line">	hashi := GetHash(item)</span><br><span class="line">	hashiStr := hex.EncodeToString(hashi)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取距离hash最近的node, sort.Search返回第一个f(i) == true 的index</span></span><br><span class="line">	<span class="comment">//注意此处的i并非实际的节点索引，而是环上的slot索引</span></span><br><span class="line">	i := sort.Search(<span class="built_in">len</span>(ci.nodeHashs), <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ci.nodeHashs[idx] &gt;= hashiStr</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &gt;= <span class="built_in">len</span>(ci.nodeHashs)) &#123;</span><br><span class="line">		i = <span class="built_in">len</span>(ci.nodeHashs) - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	nodeI := ci.hashToNode[ci.nodeHashs[i]]  <span class="comment">//根据slot中的哈希值找到实际的节点索引</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int64</span>(nodeI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ConsistHashInstance)</span> <span class="title">Init</span><span class="params">(nodeN <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	ci.hashToNode = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>)</span><br><span class="line">	ci.nodeHashs = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, nodeN)</span><br><span class="line"></span><br><span class="line">	i := nodeN</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; nodeN; i++ &#123;</span><br><span class="line">		hashi := GetHash(<span class="string">"node:"</span> + strconv.FormatInt(i, <span class="number">10</span>))</span><br><span class="line">		hashiStr := hex.EncodeToString(hashi)</span><br><span class="line"></span><br><span class="line">		ci.hashToNode[hashiStr] = <span class="keyword">int64</span>(i)</span><br><span class="line">		ci.nodeHashs = <span class="built_in">append</span>(ci.nodeHashs, hashiStr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序（将节点映射到环中）</span></span><br><span class="line">	ci.nodeHashs.Sort()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>一致性哈希的分布不均本质上是由于节点在环上的分布不均造成的，一种解决办法是增加节点数量，即可以把一个节点映射为多个虚拟节点。<br><img src="http://7xrhmq.com1.z0.glb.clouddn.com/2018-08-06-15335480401709.png" alt=""></p><p>测试结果，同样的节点数量，每个节点建立10个虚拟节点，测试结果如下，可以看出数据比普通的一致性哈希更均匀</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ConsistVirtualHash:</span><br><span class="line">CaculateChange needTransNum:13334  Percentage:0.013334 </span><br><span class="line">CaculateDist Avg:10000.00  Max:19887(198.87) Min:3344(33.44)</span><br></pre></td></tr></table></figure><h3 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h3><p>在实现上，和普通的一致性算法相比，区别只在于节点数量增加</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ConsistVirtualHashInstance)</span> <span class="title">Init</span><span class="params">(nodeN <span class="keyword">int64</span>, virtualNum <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	allVirtualNum := nodeN * virtualNum</span><br><span class="line"></span><br><span class="line">	ci.hashToNode = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>)</span><br><span class="line">	ci.nodeHashs = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, allVirtualNum)</span><br><span class="line"></span><br><span class="line">	i := nodeN</span><br><span class="line">	j := virtualNum</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; nodeN; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">0</span>; j &lt; virtualNum; j++ &#123;</span><br><span class="line">			nodehash := GetHash(<span class="string">"node:"</span> + strconv.FormatInt(i, <span class="number">10</span>) + strconv.FormatInt(j, <span class="number">10</span>))</span><br><span class="line">			hashiStr := hex.EncodeToString(nodehash)</span><br><span class="line"></span><br><span class="line">			ci.hashToNode[hashiStr] = <span class="keyword">int64</span>(i) <span class="comment">//记录虚拟节点对应的实际节点</span></span><br><span class="line">			ci.nodeHashs = <span class="built_in">append</span>(ci.nodeHashs, hashiStr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序（将节点映射到环中）</span></span><br><span class="line">	ci.nodeHashs.Sort()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附-测试主程序"><a href="#附-测试主程序" class="headerlink" title="附-测试主程序"></a>附-测试主程序</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"NormalHash:"</span>)</span><br><span class="line">	normal := dist_hash.NormalHash&#123;&#125;</span><br><span class="line">	normal.CaculateChange()</span><br><span class="line">	normal.CaculateDist()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\n\nConsistHash:"</span>)</span><br><span class="line">	consist := dist_hash.ConsistHash&#123;&#125;</span><br><span class="line">	consist.CaculateChange()</span><br><span class="line">	consist.CaculateDist()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\n\nConsistVirtualHash:"</span>)</span><br><span class="line">	consistV := dist_hash.ConsistVirtualHash&#123;&#125;</span><br><span class="line">	consistV.CaculateChange()</span><br><span class="line">	consistV.CaculateDist()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2018/08/06/2018-08-06-dist-hash/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>