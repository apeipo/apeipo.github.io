<!DOCTYPE html><html><head><meta charset="utf-8"><title>Golang内存模型 | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Golang，内存,"><meta name="description" content="参考链接-Go语言内存模型本文章主要是结合个人理解对官方文章The Go Memory Model的翻译背景内存模型的定义：参考链接-内存模型和Java内存模型参考链接-CPU缓存一致性入门简单来说，内存模型定义了并发环境下操作变量的规范，以保证共享数据的可见性、原子性。不同的语言有各自的内存模型，如Java通过volite、sync等一些列关键字来保证。Golang的内存模型规定了保证变量在不同"><meta name="keywords" content="Golang，内存"><meta property="og:type" content="article"><meta property="og:title" content="Golang内存模型"><meta property="og:url" content="http://longlog.me/2018/09/12/2018-09-12-golang-mem/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="参考链接-Go语言内存模型本文章主要是结合个人理解对官方文章The Go Memory Model的翻译背景内存模型的定义：参考链接-内存模型和Java内存模型参考链接-CPU缓存一致性入门简单来说，内存模型定义了并发环境下操作变量的规范，以保证共享数据的可见性、原子性。不同的语言有各自的内存模型，如Java通过volite、sync等一些列关键字来保证。Golang的内存模型规定了保证变量在不同"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2018-09-12T05:21:45.630Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Golang内存模型"><meta name="twitter:description" content="参考链接-Go语言内存模型本文章主要是结合个人理解对官方文章The Go Memory Model的翻译背景内存模型的定义：参考链接-内存模型和Java内存模型参考链接-CPU缓存一致性入门简单来说，内存模型定义了并发环境下操作变量的规范，以保证共享数据的可见性、原子性。不同的语言有各自的内存模型，如Java通过volite、sync等一些列关键字来保证。Golang的内存模型规定了保证变量在不同"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2018/08/06/2018-Target/">2018</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2018/08/06/2018-Target/">2018</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Happens-Before"><span class="toc-text">Happens Before</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义"><span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-允许可见"><span class="toc-text">1.允许可见</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-保证可见（garuantee）"><span class="toc-text">2.保证可见（garuantee）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步规则"><span class="toc-text">同步规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#包初始化"><span class="toc-text">包初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gorotune创建"><span class="toc-text">Gorotune创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gorotune销毁"><span class="toc-text">Gorotune销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel通讯"><span class="toc-text">Channel通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Locks"><span class="toc-text">Locks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Once"><span class="toc-text">Once</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误的同步方法"><span class="toc-text">错误的同步方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#case1"><span class="toc-text">case1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case2"><span class="toc-text">case2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case3"><span class="toc-text">case3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case4"><span class="toc-text">case4</span></a></li></ol></li></ol></div><div class="content-post LEFT"><article id="post-2018-09-12-golang-mem" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">Golang内存模型</h1><div class="article-meta"><span>2018-09-12</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/后端/">后端</a></span></div></header><div class="article-content"><p><a href="http://hugozhu.myalert.info/2013/04/20/31-golang-memory-model.html" target="_blank" rel="noopener">参考链接-Go语言内存模型</a><br>本文章主要是结合个人理解对官方文章<a href="https://golang.org/ref/mem" target="_blank" rel="noopener">The Go Memory Model</a>的翻译</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>内存模型的定义：<br><a href="https://mp.weixin.qq.com/s/ME_rVwhstQ7FGLPVcfpugQ" target="_blank" rel="noopener">参考链接-内存模型和Java内存模型</a><br><a href="http://www.infoq.com/cn/articles/cache-coherency-prime" target="_blank" rel="noopener">参考链接-CPU缓存一致性入门</a><br>简单来说，内存模型定义了并发环境下操作变量的规范，以保证共享数据的可见性、原子性。<br>不同的语言有各自的内存模型，如Java通过volite、sync等一些列关键字来保证。<br>Golang的内存模型规定了保证变量在不同gorotune之间可见性（一个G中对变量地更改能被其他读取该变量的G观测到）的条件。</p><h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h2><p>在单个gorotune中，读写和代码中的顺序一致，即编译器和CPU对程序的优化必须以不改变语言规范定义的行为为前提。如下代码，在编译执行期间，编译器和CPU都可能优化指令，比如先执行<code>b=2</code>在执行<code>a=1</code>。但是<code>c=a+2</code>一定是在<code>a=1</code>之后执行的。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    c = a + <span class="number">2</span></span><br><span class="line">    log.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>由于指令重排和优化的存在，一个gorotune中对变量的操作顺序和在另一个gorotune中观测到更改的顺序可能是不一样的。如下顺序，可能输出<code>000 122 023（先观测到b的更改）</code><br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        b = <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c = a + <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line">    log.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>happens-before</code>用来描述go程序中局部的内存操作顺序。如果一个内存操作<code>e1 happens-before e2</code>，则<code>e2 happens-after e1</code>。如果<code>e1 not happens-before e2 并且e1 not happens-after e2</code>则e1和e2是并发的（顺序无法判断）。</p><ol><li>在单个gorotune内，happends-before就是程序代码的顺序。</li><li>两个事件之间存在三种关系：<code>happens-before</code> <code>concurrent</code> <code>happens-after</code>，concurrent表示两个事件的顺序是不确定的。（这儿也可以看出来，<code>not happens-before != happens-after</code>，因为还可能有<code>coucurrent</code>）</li><li>happens-before是可推导的，<code>A happens-before B happens-before C =&gt; A happens-before C</code></li></ol><h4 id="1-允许可见"><a href="#1-允许可见" class="headerlink" title="1.允许可见"></a>1.允许可见</h4><p>当满足以下两个条件时，对变量v的读操作<strong>允许</strong>观测到对变量w的写操作（有点绕口，或者说v的写操作对v的读操作是<code>允许</code>可见的）：</p><ol><li>r not happens-before w（<strong>r在w之后或者并发</strong>）</li><li>w和r之间没有其他写操作 (其他w可以和w并发)</li></ol><h4 id="2-保证可见（garuantee）"><a href="#2-保证可见（garuantee）" class="headerlink" title="2.保证可见（garuantee）"></a>2.保证可见（garuantee）</h4><p>如果要保证w对r可见，就需要确保w是r唯一允许可见的写操作。当满足以下两个条件时，对变量v地写操作对读操作是<code>保证</code>可见的：</p><ol><li>w happens-before r</li><li>所有其他队v的写操作，只happens-before w或 happens-afer r</li></ol><p><strong>2.保证可见的要求比1.允许可见严格，它要求没有其他的写和wr并发</strong>。<br>在单个gorotune中，由于没有并发，1和2是等价的：对一个变量地读能读到最近一次对变量地写。<br>在多个gororune并发时，如果想让写对某个期望的读可见（读到期望的值），则必须使用同步事件来确定读写的顺序。</p><blockquote><p>从本质上来讲，happens-before规则确定了CPU缓冲和主存的同步时间点（通过内存屏障等指令），从而使得对变量的读写顺序可被确定–也就是我们通常说的“同步”</p></blockquote><p>go中可以通过锁和channel通讯来进行同步，同时有以下一系列happens-before规则可以用来确定事件的顺序。</p><h2 id="同步规则"><a href="#同步规则" class="headerlink" title="同步规则"></a>同步规则</h2><h3 id="包初始化"><a href="#包初始化" class="headerlink" title="包初始化"></a>包初始化</h3><ol><li>如果package-p引用了package-q，则q的init方法happens-before p的任意方法执行</li><li>main.main方法开始执行 happens-after 所有init方法执行完成。</li></ol><h3 id="Gorotune创建"><a href="#Gorotune创建" class="headerlink" title="Gorotune创建"></a>Gorotune创建</h3><p>gorotune创建语句happens-before 该gorotune的执行语句开始执行<br>如下代码，可以保证能输出<code>hello</code>，因为语句<code>@1 happens-before @2</code> <code>@2 happens-before @3</code>可以推导出<code>@1 happens-before @3</code>.<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(a)           <span class="comment">//@3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello, world"</span>   <span class="comment">//@1</span></span><br><span class="line">	<span class="keyword">go</span> f()               <span class="comment">//@2</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Gorotune销毁"><a href="#Gorotune销毁" class="headerlink" title="Gorotune销毁"></a>Gorotune销毁</h3><p>gorotune的退出不保证happens-before任意事件。如下代码，@1和@2之间没有同步事件，不能保证@1 happens-before @2，因此输出是不确定的，可能是空也可能是hello。<br>在极端情况下，编译器可能优化删除整个gorotune声明。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">        a = <span class="string">"hello"</span>  <span class="comment">//@1</span></span><br><span class="line">    &#125;()  </span><br><span class="line">    <span class="built_in">print</span>(a) <span class="comment">//@2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Channel通讯"><a href="#Channel通讯" class="headerlink" title="Channel通讯"></a>Channel通讯</h3><p>channel通讯是go中的主要同步方法，每个channel的发送操作都会有一个与之匹配的receive操作，receive大多数都是在其他gorotune中，因此定义了以下规则来确定happens顺序：</p><ul><li>channel发送操作happens-before对应的receive操作完成</li></ul><p>根据该规则，如下代码能保证输出helloworld.(@2 happens-before @3 happens-before @1==@4)<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello, world"</span> <span class="comment">//@2</span></span><br><span class="line">	c &lt;- <span class="number">0</span>            <span class="comment">//@3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	&lt;-c               <span class="comment">//@1</span></span><br><span class="line">	<span class="built_in">print</span>(a)          <span class="comment">//@4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>channel的关闭操作happens-before接受操作接收到最后的0值</li></ul><p>根据该规则，同样是上面代码，将@3语句修改为<code>close(c)</code>同样能保证输出hello-world</p><ul><li>无缓冲channel的receive happens-before对应的send操作完成</li></ul><p>根据该规则，如果上面代码中将c修改为无缓冲的channel，则需要调换@3和@1语句才能保证输出hello-world<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello, world"</span> <span class="comment">//@2</span></span><br><span class="line">	&lt;-c           <span class="comment">//@3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	c&lt;<span class="number">-0</span>               <span class="comment">//@1</span></span><br><span class="line">	<span class="built_in">print</span>(a)          <span class="comment">//@4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>对于容量为C的缓冲通道，第n次receive happens-before第n+k次send.</li></ul><p>这条规则保证了任意时刻缓冲通道中的元素不会超过其容量。当C=0时，这条规则等同于无缓冲通道的happens-before规则。<br>这个特性常用于限制并发资源的数量，如下代码，限制同一时刻，最多三个gorotune在运行<code>w()</code><br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(w <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">			limit &lt;- <span class="number">1</span></span><br><span class="line">			w()</span><br><span class="line">			&lt;-limit</span><br><span class="line">		&#125;(w)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h3><p>sync包提供了两种锁的数据结构<code>sync.Mutex</code>和<code>sync.RWMutex</code>，锁的happens-before规则：</p><ul><li>对于任意锁变量l，定义<code>n&lt;m</code>，第n次l.Unlock() happens-before 第m次l.Lock()</li></ul><p>这个定义看着有点绕，简单点说就是：<code>mutex.Unlock happens-before 下一次（或者多次）Lock</code><br>如下代码，能保证输出hello-world，第一次unlock happens-before 第二次lock<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello, world"</span></span><br><span class="line">	l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>For any call to l.RLock on a sync.RWMutex variable l, there is an n such that the l.RLock happens (returns) after call n to l.Unlock and the matching l.RUnlock happens before call n+1 to l.Lock.</li></ul><p>这段描述了读写锁的happens规则，实在找不到好的翻译。读写锁有4个操作<code>Lock,UnLock,RLock,RUnlock</code>，第n次RLock happens-after 第n次UnLock，与该RLock对应的RUnlock happens-before 第n+1次Lock</p><h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>Once.Do实现了单例模式，在并发下，Do调用的函数只会被执行一次。</p><ul><li>对于<code>Once.Do(f)</code>，对于函数f的调用f() happens-before 任意Once.Do返回。</li></ul><h2 id="错误的同步方法"><a href="#错误的同步方法" class="headerlink" title="错误的同步方法"></a>错误的同步方法</h2><p>在并发环境下，如果不关注gorotune之间的同步，会引发很多可见性造成的问题（不稳定）</p><h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><p>如下代码，可能输出2和0，因为在主gorotune中观测到的变量a，b的写顺序是无法保证的。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(b)</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> f()</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><p>有时为了保证变量在多个gorotune中只被初始化一次，会用共享变量来做状态检查.<br>如下代码是一个常见的错误，由于可见性的问题，在某个gorotune中，<code>done=true</code>不能保证在<code>a=&quot;hello,world&quot;</code>被读取到，因此这个可能打印空字符串。<br>另外，这个例子中once.Do只保证setup被执行一次，但是无法保证可见性。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello, world"</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !done &#123;</span><br><span class="line">		once.Do(setup)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">	<span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h3><p>有时我们为了程序等待某个事件结束后退出，会用共享变量来同步处理状态。<br>如下代码，存在两个问题:</p><ol><li>done赋值和a变量赋值的顺序在主gorotune中不保证，因此可能输出空字符串</li><li>done的更改对主gorotune不保证可见（没有同步事件保证），因此程序可能陷入死循环</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a = <span class="string">"hello, world"</span></span><br><span class="line">	done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> !done &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h3><p>另外一个例子，问题同case3，即使主程序观测到了g==nil的变化退出循环，也无法保证读取到的msg是hello-world</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := <span class="built_in">new</span>(T)</span><br><span class="line">	t.msg = <span class="string">"hello, world"</span></span><br><span class="line">	g = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> setup()</span><br><span class="line">	<span class="keyword">for</span> g == <span class="literal">nil</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(g.msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上诉这些case，解决的办法都是一样的，在多个gorotune之间加入同步事件。</p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2018/09/12/2018-09-12-golang-mem/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>