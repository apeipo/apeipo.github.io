<!DOCTYPE html><html><head><meta charset="utf-8"><title>Go-Module实践 | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Golang,"><meta name="description" content="go1.11版本的一大变化是新增了go-module支持，简化go项目的依赖管理。目前go-module的资料较少，只能通过go help mod 和 go help modules看一些简单的介绍。本篇文章通过创建和发布一个lib并在项目中使用它来实践go-modules的版本管理有什么不同准备先简单看下要发布的lib代码，比较简单，获取任意map类型的key并以数组（用interface包装）"><meta name="keywords" content="Golang"><meta property="og:type" content="article"><meta property="og:title" content="Go-Module实践"><meta property="og:url" content="http://longlog.me/2018/10/18/2018-10-18-go-modules/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="go1.11版本的一大变化是新增了go-module支持，简化go项目的依赖管理。目前go-module的资料较少，只能通过go help mod 和 go help modules看一些简单的介绍。本篇文章通过创建和发布一个lib并在项目中使用它来实践go-modules的版本管理有什么不同准备先简单看下要发布的lib代码，比较简单，获取任意map类型的key并以数组（用interface包装）"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2019-08-29T07:09:16.078Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Go-Module实践"><meta name="twitter:description" content="go1.11版本的一大变化是新增了go-module支持，简化go项目的依赖管理。目前go-module的资料较少，只能通过go help mod 和 go help modules看一些简单的介绍。本篇文章通过创建和发布一个lib并在项目中使用它来实践go-modules的版本管理有什么不同准备先简单看下要发布的lib代码，比较简单，获取任意map类型的key并以数组（用interface包装）"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备"><span class="toc-text">准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建go-module"><span class="toc-text">创建go-module</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#版本"><span class="toc-text">版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用go-module"><span class="toc-text">使用go-module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#module更新"><span class="toc-text">module更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#小版本-Patch-Minor-更新"><span class="toc-text">小版本(Patch/Minor)更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用方更新"><span class="toc-text">使用方更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大版本-Major-更新"><span class="toc-text">大版本(Major)更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用方更新-1"><span class="toc-text">*使用方更新</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#下载路径"><span class="toc-text">下载路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vendor"><span class="toc-text">vendor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#项目迁移"><span class="toc-text">项目迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#翻墙"><span class="toc-text">翻墙</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-text">参考文章</span></a></li></ol></div><div class="content-post LEFT"><article id="post-2018-10-18-go-modules" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">Go-Module实践</h1><div class="article-meta"><span>2018-10-18</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/后端/">后端</a></span></div></header><div class="article-content"><p>go1.11版本的一大变化是新增了go-module支持，简化go项目的依赖管理。目前go-module的资料较少，只能通过<code>go help mod</code> 和 <code>go help modules</code>看一些简单的介绍。</p><p>本篇文章通过创建和发布一个lib并在项目中使用它来实践go-modules的版本管理有什么不同</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>先简单看下要发布的lib代码，比较简单，获取任意map类型的key并以数组（用interface包装）的形式返回<br>git仓库为：<code>github.com/apeipo/go-mapkeys</code><br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> maputil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// return map keys as interface</span></span><br><span class="line"><span class="comment">// panic if m is not map type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapKeys</span><span class="params">(m <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	mtyp := reflect.TypeOf(m)</span><br><span class="line">	<span class="keyword">if</span> mtyp.Kind() != reflect.Map &#123;</span><br><span class="line">	   <span class="built_in">panic</span>(<span class="string">"not a map type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	v := reflect.ValueOf(m)</span><br><span class="line">	keys := v.MapKeys() <span class="comment">// panic if not map type</span></span><br><span class="line">	rkeys := reflect.MakeSlice(reflect.SliceOf(mtyp.Key()), <span class="number">0</span>, v.Len())</span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		rkeys = reflect.Append(rkeys, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rkeys.Interface()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="创建go-module"><a href="#创建go-module" class="headerlink" title="创建go-module"></a>创建go-module</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">git clone github.com/apeipo/<span class="keyword">go</span>-mapkeys</span><br><span class="line">cd <span class="keyword">go</span>-mapkeys</span><br><span class="line"><span class="keyword">go</span> mod init github.com/apeipo/<span class="keyword">go</span>-mapkeys</span><br></pre></td></tr></table></figure><p>执行以上代码就完成了一个go-module的初始化，会在目录下创建<code>go.mod</code>文件。文件内容如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">module github.com/apeipo/go-mapkeys</span><br></pre></td></tr></table></figure><p>注意：<strong>go-mapkeys不能放在GOPATH路径下</strong>，否则会报错。这一点官方的说法是<strong>未来GOPATH可能会取消</strong>，不希望Go的开发者总是理解不了为什么模块需要放到GOPATH下。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>创建好module后，需要给module加上版本以便其他模块使用。<br>go-module的版本遵循语义化版本标准<a href="https://semver.org/" target="_blank" rel="noopener">semver</a>，并且通过github的tag对版本进行控制，给mapkeys模块创建一个版本：<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag v1.0.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p></p><p>至此，一个简单的go-module已经创建并且发布了版本<code>1.0.0</code>，接下来看看怎么在其他模块中使用</p><h2 id="使用go-module"><a href="#使用go-module" class="headerlink" title="使用go-module"></a>使用go-module</h2><p>先找个目录创建一段测试代码（同样的，<strong>该目录也不能在GOPATH路径下</strong>）<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/apeipo/go-mapkeys"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="string">"A"</span> : <span class="number">20</span>,</span><br><span class="line">		<span class="string">"B"</span> : <span class="number">30</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	keys := maputil.MapKeys(m)</span><br><span class="line">	fmt.Println(keys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>创建代码后执行：<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init testmod</span><br><span class="line"><span class="keyword">go</span> build</span><br><span class="line"><span class="comment">//find github.com/apeipo/go-mapkeysa</span></span><br><span class="line"><span class="comment">//download github.com/apeipo/go-mapkeys</span></span><br></pre></td></tr></table></figure><p></p><p>执行过程go会自动扫描代码的仓库依赖并拉取依赖的module，执行完成后go.mod文件中会更新相关的依赖及版本<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go.mod</span></span><br><span class="line">module test</span><br><span class="line">require (</span><br><span class="line">	github.com/apeipo/<span class="keyword">go</span>-mapkeys v1<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>同时，目录下回生成一个go.sum文件，文件中记录了依赖包的hash，保证所下载版本的正确性<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//go.sum</span><br><span class="line">github.com/apeipo/go-mapkeys v1.0.0 h1:bPfcNKs0sKWi/cZRkhjv6eNmIeRuymjIBM98ihvlzPc=</span><br><span class="line">github.com/apeipo/go-mapkeys v1.0.0/go.mod h1:bPDRb2IUmwPjag8rByI+zdL3d4/+RkIPggHCioYUhdA=</span><br></pre></td></tr></table></figure><p></p><h2 id="module更新"><a href="#module更新" class="headerlink" title="module更新"></a>module更新</h2><p>完成go-module的创建和使用后，接下来再来看下go-module的更新。</p><h3 id="小版本-Patch-Minor-更新"><a href="#小版本-Patch-Minor-更新" class="headerlink" title="小版本(Patch/Minor)更新"></a>小版本(Patch/Minor)更新</h3><p>第一个版本的改动很小，由于<code>reflect.MapKeys</code>调用中已经有了map类型的校验，因此<code>MapKeys</code>方法就不需要再多校验一次。我们将代码中的类型校验去掉，并发布版本1.0.1<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return map keys as interface</span></span><br><span class="line"><span class="comment">// panic if m is not map type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapKeys</span><span class="params">(m <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	mtyp := reflect.TypeOf(m)</span><br><span class="line">	v := reflect.ValueOf(m)</span><br><span class="line">	keys := v.MapKeys() <span class="comment">// panic if not map type</span></span><br><span class="line">	rkeys := reflect.MakeSlice(reflect.SliceOf(mtyp.Key()), <span class="number">0</span>, v.Len())</span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		rkeys = reflect.Append(rkeys, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rkeys.Interface()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>发布版本<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cd <span class="keyword">go</span>-mapkeys</span><br><span class="line">git commit -m <span class="string">"remove type check"</span> -a</span><br><span class="line">git tag v1<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p></p><h4 id="使用方更新"><a href="#使用方更新" class="headerlink" title="使用方更新"></a>使用方更新</h4><p>适用方可以通过以下三种方式进行依赖的小版本更新，假设初始版本位<code>1.0.0</code>，三种方式的更新策略如下：<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go get -u       //更新为最近的minor或者patch版本，如1.0.0会被更新为1.0.1或者1.1.0（存在的话）</span><br><span class="line">$ go get -u=patch //更新为最近的patch版本，1.0.0会更新为1.0.1但是不会更新为1.1.0</span><br><span class="line">$ go get github.com/apeipo/go-mapkeys@v1.0.1 //指定版本</span><br></pre></td></tr></table></figure><p></p><p>进入testmod目录执行<code>go get/build</code>，会发现go.mod文件中依赖的版本自动更新为了1.0.1</p><h3 id="大版本-Major-更新"><a href="#大版本-Major-更新" class="headerlink" title="大版本(Major)更新"></a>大版本(Major)更新</h3><p>第二个版本我们给mapkeys增加一个接口，由于MapKeys有可能产生panic，因此我们提供了一个安全版本的接口，对panic进行捕获并以错误的形式返回。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map_keys.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeMapKeys</span><span class="params">(m <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(r <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">			r = <span class="literal">nil</span></span><br><span class="line">			err = fmt.Errorf(<span class="string">"%s"</span>, p)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	mtyp := reflect.TypeOf(m)</span><br><span class="line">	v := reflect.ValueOf(m)</span><br><span class="line">	keys := v.MapKeys() <span class="comment">// panic if not map type</span></span><br><span class="line">	rkeys := reflect.MakeSlice(reflect.SliceOf(mtyp.Key()), <span class="number">0</span>, v.Len())</span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		rkeys = reflect.Append(rkeys, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rkeys.Interface(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该版本新增了功能，因此我们发布一个2.0版本。<br>先需要修改go.mod文件：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module github.com/apeipo/go-mapkeys/v2</span><br></pre></td></tr></table></figure><p></p><p>git发布2.0版本，此步骤与之前相同<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cd <span class="keyword">go</span>-mapkeys</span><br><span class="line">git commit -m <span class="string">"add safe mapkeys"</span> -a</span><br><span class="line">git tag v2<span class="number">.0</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p></p><h4 id="使用方更新-1"><a href="#使用方更新-1" class="headerlink" title="*使用方更新"></a>*使用方更新</h4><p><code>go get/build</code>只能更新依赖的patch和minor版本，不能更新major版本。这里涉及到go-module与其他依赖管理不同的地方，因为根据语义化版本的规范，major版本可以不向前兼容，所以<code>go-module认为同一个库的不同大版本是两个完全独立的模块</code>。<br>我们先在测试代码中引入v2版本（<code>github.com/apeipo/go-mapkeys/v2</code>不影响代码中的使用名称）：<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/apeipo/go-mapkeys/v2"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="string">"A"</span> : <span class="number">20</span>,</span><br><span class="line">		<span class="string">"B"</span> : <span class="number">30</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	keys := maputil.MapKeys(m)</span><br><span class="line">	fmt.Println(keys)</span><br><span class="line">	keys, err := maputil.SafeMapKeys(<span class="string">""</span>)</span><br><span class="line">	fmt.Println(keys, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>再执行<code>go get</code>更新依赖，会发现go.mod文件中同时require了两个版本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//go.mod</span><br><span class="line">module <span class="built_in">test</span></span><br><span class="line">require (</span><br><span class="line">	github.com/apeipo/go-mapkeys v1.1.0</span><br><span class="line">	github.com/apeipo/go-mapkeys/v2 v2.0.1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>由于go-module中v1和v2是两个完全独立的模块，因此我们可以在代码中同时引入同一个依赖的不同版本：<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/apeipo/go-mapkeys"</span></span><br><span class="line">	maputilv2 <span class="string">"github.com/apeipo/go-mapkeys/v2"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="string">"A"</span> : <span class="number">20</span>,</span><br><span class="line">		<span class="string">"B"</span> : <span class="number">30</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//use v1.0</span></span><br><span class="line">	keys := maputil.MapKeys(m)</span><br><span class="line">	fmt.Println(keys)</span><br><span class="line">   <span class="comment">//use v2.0</span></span><br><span class="line">	keys, err := maputilv2.SafeMapKeys(<span class="string">""</span>)</span><br><span class="line">	fmt.Println(keys, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="下载路径"><a href="#下载路径" class="headerlink" title="下载路径"></a>下载路径</h3><p>模块使用<code>gomod</code>初始化后，执行<code>go get</code>时，依赖会被保存到<code>$GOPATH/pkg/mod/$gitpath</code>路径下，同时以版本号的形式区分。如<code>mapkeys</code>这个模块的下载路径时<a href="mailto:`$GOPATH/pkg/mod/github.com/apeipo/go-mapkeys@v1.1.0" target="_blank" rel="noopener">`$GOPATH/pkg/mod/github.com/apeipo/go-mapkeys@v1.1.0</a>`</p><h3 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h3><p>go-mod默认不使用<code>vendor</code>目录，依赖不保存在<code>vendor</code>目录下，在执行build时会忽略<code>vendor</code>目录。</p><p>如果要从<code>vendor</code>中加载依赖（一些不联通外部网络的环境下回用到），先要使用<code>go mod vendor</code>命令将依赖的源码全部拷贝到vendor目录下。再使用<code>go build -mod vendor</code>进行编译</p><h3 id="项目迁移"><a href="#项目迁移" class="headerlink" title="项目迁移"></a>项目迁移</h3><p>执行<code>go mod init modulename</code>后执行<code>go get</code>，后面的事情交给go就行，会自动扫描和下载依赖。<br>实际测试发现，如果原来的项目是glide，go-mod会直接从<code>glide.yml</code>中解析依赖生成go.mod文件。</p><h3 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h3><p><code>golang.org</code>下的库无法直接访问，可以再<code>go.mod</code>文件中使用replace进行路径替换<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">replace (</span><br><span class="line">	golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是，replace只对go.mod所在模块生效。例如A模块依赖B模块，B模块中使用了replace，对A模块的下载时不生效的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>go-mod的使用极其简单，不管是对于服务提供者还是调用方来说，基本上<code>go mod init</code>+<code>go get</code>就搞定了一切。</li><li>和其他依赖管理最大的区别在于不同Major版本认为是不同的模块。（这一点上不知道实践中反响如何，从上面的实践来看，major版本无法直接升级，需要修改代码中的import路径）</li><li>当前相关的工具链和文档还不够完善，因为使用了版本相关的路径，大部分IDE中还无法识别gomod导入的模块。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules</a></li><li><a href="https://colobu.com/2018/08/27/learn-go-module/" target="_blank" rel="noopener">跳出go-module的泥潭</a></li></ol></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2018/10/18/2018-10-18-go-modules/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>