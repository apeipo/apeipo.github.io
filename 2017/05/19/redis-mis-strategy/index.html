<!DOCTYPE html><html><head><meta charset="utf-8"><title>缓存失效的更新策略阅读思考 | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Redis,"><meta name="description" content="原文链接缓存失效的策略有很多种，详细的介绍参考原文，这里主要思考其中最常用的一种策略的问题。Cache Aside Pattern最常用的缓存设计模式：失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。命中：应用程序从cache中取数据，取到后返回。更新：先把数据存到数据库中，成功后，再让缓存失效。对比在读策略都一样时，对比先删缓存再更新数据库，两种方式在读写并"><meta name="keywords" content="Redis"><meta property="og:type" content="article"><meta property="og:title" content="缓存失效的更新策略阅读思考"><meta property="og:url" content="http://longlog.me/2017/05/19/redis-mis-strategy/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="原文链接缓存失效的策略有很多种，详细的介绍参考原文，这里主要思考其中最常用的一种策略的问题。Cache Aside Pattern最常用的缓存设计模式：失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。命中：应用程序从cache中取数据，取到后返回。更新：先把数据存到数据库中，成功后，再让缓存失效。对比在读策略都一样时，对比先删缓存再更新数据库，两种方式在读写并"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2018-08-06T12:12:41.826Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="缓存失效的更新策略阅读思考"><meta name="twitter:description" content="原文链接缓存失效的策略有很多种，详细的介绍参考原文，这里主要思考其中最常用的一种策略的问题。Cache Aside Pattern最常用的缓存设计模式：失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。命中：应用程序从cache中取数据，取到后返回。更新：先把数据存到数据库中，成功后，再让缓存失效。对比在读策略都一样时，对比先删缓存再更新数据库，两种方式在读写并"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-Aside-Pattern"><span class="toc-text">Cache Aside Pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对比"><span class="toc-text">对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方式一：先删缓存再更新数据库"><span class="toc-text">方式一：先删缓存再更新数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方式二：先更新数据库再删缓存"><span class="toc-text">方式二：先更新数据库再删缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方式三：读操作不更新缓存，写完数据后更新缓存"><span class="toc-text">方式三：读操作不更新缓存，写完数据后更新缓存</span></a></li></ol></li></ol></div><div class="content-post LEFT"><article id="post-redis-mis-strategy" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">缓存失效的更新策略阅读思考</h1><div class="article-meta"><span>2017-05-19</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/后端/">后端</a></span></div></header><div class="article-content"><p><a href="http://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">原文链接</a><br>缓存失效的策略有很多种，详细的介绍参考原文，这里主要思考其中最常用的一种策略的问题。</p><h2 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h2><p>最常用的缓存设计模式：</p><ul><li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从cache中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2>在读策略都一样时，对比先删缓存再更新数据库，两种方式在读写并发下都会出现脏数据的问题，但是出问题的条件存在很大的区别。</li></ul><h3 id="方式一：先删缓存再更新数据库"><a href="#方式一：先删缓存再更新数据库" class="headerlink" title="方式一：先删缓存再更新数据库"></a>方式一：先删缓存再更新数据库</h3><p>出问题的条件：</p><ol><li>缓存失效</li><li>读请求先进入（因为更新操作一般会加锁s），读数据耗时 &lt; 写数据耗时（读操作先完成）</li></ol><h3 id="方式二：先更新数据库再删缓存"><a href="#方式二：先更新数据库再删缓存" class="headerlink" title="方式二：先更新数据库再删缓存"></a>方式二：先更新数据库再删缓存</h3><p>出问题的条件：</p><ol><li>缓存失效</li><li>读请求先进入， 读耗时 &gt; 写耗时（读操作在写操作完成后完成）</li></ol><p>正常情况下，<strong>写数据都是比读耗时时间长</strong>。另外，在方式一中，先删缓存，增加了缓存失效的概率。因此可以看出来方式一出现脏数据的可能性明显大于使用方式二。实际上方式二出现脏数据的可能性很低。</p><h3 id="方式三：读操作不更新缓存，写完数据后更新缓存"><a href="#方式三：读操作不更新缓存，写完数据后更新缓存" class="headerlink" title="方式三：读操作不更新缓存，写完数据后更新缓存"></a>方式三：读操作不更新缓存，写完数据后更新缓存</h3><p>这种方式下，出问题的条件变得更加简单：当出现并发的写操作，如果更新缓存的耗时较长，就有可能出现。对于写操作并发高的网站，这种条件很容易满足。</p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2017/05/19/redis-mis-strategy/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>