<!DOCTYPE html><html><head><meta charset="utf-8"><title>swoole使用中踩的坑 | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="PHP,Swoole,"><meta name="description" content="从去年开始使用swoole开发内部的一些小的服务，中间遇到一些坑，在此记录多进程不能共用连接官方文档其实这个是所有多进程、多线程程序都需要注意的问题，当进程or线程共享资源的时候，一定要考虑资源冲突，否则会出现各种诡异的问题（死锁、数据返回异常、连接被关闭等等等）。如下代码，在swoole中，在server启动时创建了一个redis连接，在onRequest中使用。代码看上去没什么问题，但是实际使"><meta name="keywords" content="PHP,Swoole"><meta property="og:type" content="article"><meta property="og:title" content="swoole使用中踩的坑"><meta property="og:url" content="http://longlog.me/2017/04/10/swoole-error/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="从去年开始使用swoole开发内部的一些小的服务，中间遇到一些坑，在此记录多进程不能共用连接官方文档其实这个是所有多进程、多线程程序都需要注意的问题，当进程or线程共享资源的时候，一定要考虑资源冲突，否则会出现各种诡异的问题（死锁、数据返回异常、连接被关闭等等等）。如下代码，在swoole中，在server启动时创建了一个redis连接，在onRequest中使用。代码看上去没什么问题，但是实际使"><meta property="og:locale" content="default"><meta property="og:image" content="http://7xrhmq.com1.z0.glb.clouddn.com/2017-04-10-14918263781334.jpg"><meta property="og:updated_time" content="2018-08-06T12:12:41.827Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="swoole使用中踩的坑"><meta name="twitter:description" content="从去年开始使用swoole开发内部的一些小的服务，中间遇到一些坑，在此记录多进程不能共用连接官方文档其实这个是所有多进程、多线程程序都需要注意的问题，当进程or线程共享资源的时候，一定要考虑资源冲突，否则会出现各种诡异的问题（死锁、数据返回异常、连接被关闭等等等）。如下代码，在swoole中，在server启动时创建了一个redis连接，在onRequest中使用。代码看上去没什么问题，但是实际使"><meta name="twitter:image" content="http://7xrhmq.com1.z0.glb.clouddn.com/2017-04-10-14918263781334.jpg"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#多进程不能共用连接"><span class="toc-text">多进程不能共用连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方法"><span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp协议包完整性"><span class="toc-text">tcp协议包完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解决办法"><span class="toc-text">解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#open-eof-check"><span class="toc-text">open_eof_check</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#手动拼接请求数据"><span class="toc-text">手动拼接请求数据</span></a></li></ol></li></ol></li></ol></div><div class="content-post LEFT"><article id="post-swoole-error" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">swoole使用中踩的坑</h1><div class="article-meta"><span>2017-04-10</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/后端/">后端</a></span></div></header><div class="article-content"><p>从去年开始使用swoole开发内部的一些小的服务，中间遇到一些坑，在此记录</p><h2 id="多进程不能共用连接"><a href="#多进程不能共用连接" class="headerlink" title="多进程不能共用连接"></a>多进程不能共用连接</h2><p><a href="https://wiki.swoole.com/wiki/page/325.html" target="_blank" rel="noopener">官方文档</a><br>其实这个是所有多进程、多线程程序都需要注意的问题，当进程or线程共享资源的时候，一定要考虑资源冲突，否则会出现各种诡异的问题（死锁、数据返回异常、连接被关闭等等等）。<br>如下代码，在swoole中，在server启动时创建了一个redis连接，在onRequest中使用。<br>代码看上去没什么问题，但是实际使用时，如果压力很大，就会出现多进程抢占连接导致的问题。原因是因为创建的redis连接实际上是一个全局对象，每个work进程都在使用同一个连接。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> $redis;</span><br><span class="line">	<span class="keyword">public</span> $server;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//初始化函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//initServer</span></span><br><span class="line">		$server = <span class="keyword">new</span> swoole_http_server( <span class="keyword">$this</span>-&gt;productConfig[<span class="string">"server"</span>][<span class="string">"host"</span>], </span><br><span class="line">		                                  <span class="keyword">$this</span>-&gt;productConfig[<span class="string">"server"</span>][<span class="string">"port"</span>]);</span><br><span class="line">		$server-&gt;on(<span class="string">'request'</span>, <span class="keyword">array</span>(<span class="keyword">$this</span>, <span class="string">'onRequest'</span>));</span><br><span class="line">		$server-&gt;on(<span class="string">'workerstart'</span>, <span class="keyword">array</span>(<span class="keyword">$this</span>, <span class="string">'onWorkerStart'</span>));</span><br><span class="line">		<span class="keyword">$this</span>-&gt;server = $server;</span><br><span class="line">		<span class="comment">//initRedis</span></span><br><span class="line">		<span class="keyword">$this</span>-&gt;redis = <span class="keyword">new</span> Redis();</span><br><span class="line">		<span class="keyword">$this</span>-&gt;redis-&gt;connect(<span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"host"</span>], </span><br><span class="line">		<span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"port"</span>]);  </span><br><span class="line">		$server-&gt;start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//请求处理函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">($request, $response)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//do some thing with redis</span></span><br><span class="line">		<span class="keyword">$this</span>-&gt;redis-&gt;get(<span class="string">"somekey"</span>);</span><br><span class="line">		$response-&gt;end(json_encode([<span class="string">"errno"</span> =&gt; <span class="number">0</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//worker进程创建函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onWorkerStart</span><span class="params">($serv, $workerId)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$server = <span class="keyword">new</span> Server();</span><br><span class="line">$init   = $server-&gt;init();</span><br><span class="line"><span class="keyword">if</span> ($init[<span class="string">"errno"</span>] !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(json_encode($init));</span><br><span class="line">&#125; </span><br><span class="line">$server-&gt;run();</span><br></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li><p>不在server中创建，而在onRequest中，接收到请求时创建<br>简单粗暴的解决方案，每次收到请求时独立创建局部的redis连接，请求结束后释放。这种方式缺点很明显，连接没有复用，影响性能。</p></li><li><p>在onWorkerStart中创建连接，并按workerId索引每个worker进程的redis连接<br>代码如下（主体代码参考上面），在Server中增加一个redisPool，worker启动时创建连接后注册到pool中。这样能保证每次请求时，使用的都是各进程独立的redis连接。</p></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Server类中增加$redisPool变量，初始化为空数组</span></span><br><span class="line"><span class="keyword">public</span> $redisPool = [];</span><br><span class="line"><span class="comment">//worker进程创建函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onWorkerStart</span><span class="params">($serv, $workerId)</span> </span>&#123;</span><br><span class="line">	$redis   = <span class="keyword">new</span> \Redis();</span><br><span class="line">	$tmpRes  = $redis-&gt;connect(<span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"host"</span>], </span><br><span class="line">	                           <span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"port"</span>]);  </span><br><span class="line">	<span class="keyword">if</span> ($tmpRes === <span class="keyword">false</span>) &#123;</span><br><span class="line">	    <span class="keyword">$this</span>-&gt;logger-&gt;error(<span class="string">"Redis Init failed workerId:$workerId"</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	$redis-&gt;setOption(Redis::OPT_READ_TIMEOUT, </span><br><span class="line">	                  <span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"read_timeout"</span>]);</span><br><span class="line">	<span class="keyword">$this</span>-&gt;redisPool[$workerId] = $redis;<span class="comment">//将连接注册到pool中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求处理函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">($request, $response)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//do some thing with redis</span></span><br><span class="line">	$redis = <span class="keyword">$this</span>-&gt;redisPool[<span class="keyword">$this</span>-&gt;server-&gt;worker_id];</span><br><span class="line">	$response-&gt;end(json_encode([<span class="string">"errno"</span> =&gt; <span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tcp协议包完整性"><a href="#tcp协议包完整性" class="headerlink" title="tcp协议包完整性"></a>tcp协议包完整性</h2><p><a href="https://wiki.swoole.com/wiki/page/50.html" target="_blank" rel="noopener">官方文档</a><br><a href="http://blog.csdn.net/ldy3243942/article/details/40920743?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Swoole的自定义协议功能的使用</a><br>在默认情况下，使用swoole-server时（TCP协议），swoole不对包的进行完整性校验，在onReceive中接收到的包可能是不完整的，也有可能是多份数据。这是由于TCP协议的原理所造成的：</p><blockquote><p>TCP是一个流式协议。客户端向服务器发送的一段数据，可能并不会被服务器一次就完整的收到;客户端向服务器发送的多段数据，可能服务器一次就收到了全部的数据</p></blockquote><p>如下代码，在onReceive中接收到数据后，转给task进程进行处理，task进程处理结束后返回。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求处理（接收到客户端发送的数据）</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onReceive</span><span class="params">(swoole_server $serv, int $fd, int $from_id, string $data)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="keyword">$this</span>-&gt;logger-&gt;debug(<span class="string">"ReceiveMSG: "</span> . $data, [<span class="string">"fd"</span> =&gt; $fd]);</span><br><span class="line">		$params = [</span><br><span class="line">			<span class="string">"fd"</span> 	=&gt; $fd,</span><br><span class="line">			<span class="string">"data"</span> 	=&gt; $data</span><br><span class="line">		];</span><br><span class="line">		$conInfo = $serv-&gt;connection_info($fd);</span><br><span class="line">		<span class="keyword">$this</span>-&gt;logger-&gt;debug(<span class="string">"conninfo fd:$fd "</span>, [<span class="string">"info"</span> =&gt; $conInfo]);</span><br><span class="line">		<span class="keyword">$this</span>-&gt;server-&gt;task($params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际的task处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onTask</span><span class="params">($serv, $taskId, $srcWorkerId, $params)</span> </span>&#123;</span><br><span class="line">	$fd 	= $params[<span class="string">"fd"</span>];</span><br><span class="line">	$sendRes = $serv-&gt;send($fd, <span class="string">"hehe\t0\t[]\n"</span>);</span><br><span class="line">	<span class="keyword">$this</span>-&gt;logger-&gt;debug(<span class="string">"conninfo-InTask fd:$fd "</span>, [<span class="string">"sendRes"</span> =&gt; $sendRes]);</span><br><span class="line">	$serv-&gt;close($fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与客户端的连接被关闭</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onClose</span><span class="params">(swoole_server $server, int $fd, int $reactorId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;logger-&gt;debug(<span class="string">"fd:$fd is Close"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时（发送的数据比较大），有可能出现这样的日志。从日志里可以看到</p><ol><li>同一个server_fd(53)接收到了两份数据，两份数据来自同一个client_fd(22)</li><li>第一个task向客户端发送数据成功了，但是第二个发送失败（sendRes：false）<br><img src="http://7xrhmq.com1.z0.glb.clouddn.com/2017-04-10-14918263781334.jpg" alt=""><br>实际打印出数据（在onReceive中），会发现客户端发送的数据被拆成了两份，因此触发了两次onReceive。<br>第二个task中sendRes失败，是因为在处理第一份数据时，task中已经把客户端连接给关闭了。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="open-eof-check"><a href="#open-eof-check" class="headerlink" title="open_eof_check"></a>open_eof_check</h4><p>使用swoole提供的open_eof_check，保证数据包的完整性。</p><blockquote><p>此选项将检测客户端连接发来的数据，当数据包结尾是指定的字符串时才会投递给Worker进程。否则会一直拼接数据包，直到超过缓存区或者超时才会中止</p></blockquote><p>EOF即为数据的结束标记，具体由客户端使用的发送方式而定，比如Memcache协议以”\r\n”结尾，Java中BuffWriter.newLine()发送的数据在有可能是<code>&quot;\n&quot;</code>结尾，也有可能是<code>&quot;\r\n&quot;</code>。<br>注意：<strong>swoole的EOF检测不会从数据中间查找eof字符串，所以Worker进程可能会同时收到多个数据包，需要在应用层代码中自行explode(“\n”, $data) 来拆分</strong>，1.7.15版本增加了open_eof_split，支持从数据中查找EOF，并切分数据。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'open_eof_check'</span> =&gt; <span class="keyword">true</span>, <span class="comment">//打开EOF检测</span></span><br><span class="line"><span class="string">'package_eof'</span> 	 =&gt; <span class="string">"\n"</span>, <span class="comment">//设置EOF</span></span><br></pre></td></tr></table></figure><h4 id="手动拼接请求数据"><a href="#手动拼接请求数据" class="headerlink" title="手动拼接请求数据"></a>手动拼接请求数据</h4><p>默认情况下，同一个客户端fd会被分配到同一个worker中处理，所以数据可以拼接起来，当发现结尾是EOF字符时才进行处理。<br>例如可以在全局数据中保存一个数组buff，接收到数据后进行拼接和判断。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$buff[$fd] .= $data;</span><br><span class="line"><span class="keyword">if</span> (substr($buff[$fd], <span class="number">-1</span>) == <span class="string">"\n"</span>) &#123;<span class="comment">//\n也可以是其他的EOF字符</span></span><br><span class="line">	<span class="comment">//数据完整，执行具体的逻辑</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//数据不完整，返回等待下次接收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2017/04/10/swoole-error/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>