<!DOCTYPE html><html><head><meta charset="utf-8"><title>Python中实现PHP的魔术方法call和callStatic | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="PHP,Python,"><meta name="description" content="call和callStatic有PHP开发经验的同学应该对call和callStatic不陌生，__call方法： 当调用类的方法时，方法不存在或权限不足，会自动调用__call 方法。__callStatic方法： 当调用类的静态方法时，方法不存在或权限不足，会自动调用__callStatic方法。如下一个简单的例子，基于__callStatic实现一个Redis的简单代理，可以在请求redis"><meta name="keywords" content="PHP,Python"><meta property="og:type" content="article"><meta property="og:title" content="Python中实现PHP的魔术方法call和callStatic"><meta property="og:url" content="http://longlog.me/2017/07/24/python-call-callStatic/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="call和callStatic有PHP开发经验的同学应该对call和callStatic不陌生，__call方法： 当调用类的方法时，方法不存在或权限不足，会自动调用__call 方法。__callStatic方法： 当调用类的静态方法时，方法不存在或权限不足，会自动调用__callStatic方法。如下一个简单的例子，基于__callStatic实现一个Redis的简单代理，可以在请求redis"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2018-08-06T12:12:41.825Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Python中实现PHP的魔术方法call和callStatic"><meta name="twitter:description" content="call和callStatic有PHP开发经验的同学应该对call和callStatic不陌生，__call方法： 当调用类的方法时，方法不存在或权限不足，会自动调用__call 方法。__callStatic方法： 当调用类的静态方法时，方法不存在或权限不足，会自动调用__callStatic方法。如下一个简单的例子，基于__callStatic实现一个Redis的简单代理，可以在请求redis"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2018/08/06/2018-Target/">2018</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2018/08/06/2018-Target/">2018</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#call和callStatic"><span class="toc-text">call和callStatic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在Python中实现call"><span class="toc-text">在Python中实现call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现callStatic"><span class="toc-text">实现callStatic</span></a></li></ol></div><div class="content-post LEFT"><article id="post-python-call-callStatic" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">Python中实现PHP的魔术方法call和callStatic</h1><div class="article-meta"><span>2017-07-24</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/后端/">后端</a></span></div></header><div class="article-content"><h2 id="call和callStatic"><a href="#call和callStatic" class="headerlink" title="call和callStatic"></a>call和callStatic</h2><p>有PHP开发经验的同学应该对call和callStatic不陌生，<br><strong>__call</strong>方法： 当调用类的方法时，方法不存在或权限不足，会自动调用<code>__call</code> 方法。<br><strong>__callStatic</strong>方法： 当调用类的静态方法时，方法不存在或权限不足，会自动调用<code>__callStatic</code>方法。<br>如下一个简单的例子，基于<code>__callStatic</code>实现一个Redis的简单代理，可以在请求redis之前和之后做一些其他的操作，如耗时、日志。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> $redisIns;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//redis初始化</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">static</span>::$redisIns;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">($func, $args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//在请求执行做一些操作</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="comment">//请求具体的redis方法</span></span><br><span class="line">		$res = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">static</span>::$redisIns) &#123;</span><br><span class="line">			$res =  <span class="keyword">static</span>::$redisIns-&gt;$func(...$args)</span><br><span class="line">			<span class="comment">//return call_user_func_array([static::$redisIns, $func], $args)</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//请求完成后执行一些操作</span></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span> $res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Python中实现call"><a href="#在Python中实现call" class="headerlink" title="在Python中实现call"></a>在Python中实现call</h2><p>Python中当访问不存在的属性或者方法时，会调用类的<code>__getattr__</code>方法，基于这个方法我们可以实现类似<code>__call</code>的功能。（注意：Python中的类有一个<code>__call__</code>方法，不过该方法是在类被作为方法执行是调用的。）<br>如下代码，当访问hello这个不存在的属性时，会调用<code>MagicCall</code>这个类的<code>__getattr__</code>方法。注意：<code>__getattr__</code>方法<strong>只负责返回属性，而不负责执行方法</strong>，执行方法是在<code>ins.hello(&#39;xx&#39;, &#39;pp&#39;)</code>这一行执行<code>__getattr__</code>的返回结果，因此，<code>__getattr__</code>中需要返回一个闭包。<br>这里没有直接把<code>callMethod</code>方法直接返回，而是再套了一层，是为了<strong>保留调用的method_name</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicCall</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, method_name)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            self._callMethod(method_name, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callMethod</span><span class="params">(self, method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MagicCall)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callMethod</span><span class="params">(self, method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        print(method_name, args, kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    ins = MyClass()</span><br><span class="line">    ins.hello(<span class="string">'xx'</span>, <span class="string">'pp'</span>)</span><br></pre></td></tr></table></figure><p>当然，这种实现有个问题：<strong>如果没有调用不存在的方法，而是访问不存在的属性，会获取到一个闭包</strong>.. 这个问题要解决的话会比较复杂(可能得根据当前的执行栈进行判断)，这篇文章里不讨论这个。</p><h2 id="实现callStatic"><a href="#实现callStatic" class="headerlink" title="实现callStatic"></a>实现callStatic</h2><p>上一章的实现，当调用类实例不存在的方法时，会正确重定向到<code>callMethod</code>。<br>但是，如果是静态方法调用，比如调用一个不存在的静态方法<code>MyClass::hello(&quot;hehe&quot;)</code>时，就没法调用到<code>callMethod</code>方法了。因为，本质上来说，当调用<code>MyClass::hello()</code>时，访问的并不是<code>MyClass</code>的实例(上文代码中的ins才是MyClass的一个实例)。</p><p>那<code>MyClass</code>这个类是谁的实例？答案是它的<strong>元类</strong>，即type。当我们用class定义一个类时，实际上是用type创建了一个’类’并实例化了它。<br>关于元类的分析网上文章有很多，这里不在赘述，我们可以通过类的<code>__metaclass__</code>属性修改类的元类。</p><p>改进后的代码如下，修改了<code>MagicCall</code>的元类为<code>MagicMeta</code>，当调用<code>MyClass.hello()</code>时，因为<code>MyClass</code>这个类是<code>MagicMeta</code>的一个实例，所以会执行<code>MagicMeta</code>的<code>__getattr__</code>方法。</p><p>在<code>MagicMeta-&gt;__getattr__</code>中，self指向的是<code>MyClass</code>（self指向类的实例，MyClass是MagicMeta的实例），所以可以根据<code>self</code>调用到<code>MyClass</code>的<code>callStaticMethod</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    调用MagicCall不存在的方法时，会调用其元类的getattr方法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, method_name)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            getattr(self, <span class="string">'_callStaticMethod'</span>)(method_name, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicCall</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"重定义类的元类"</span></span><br><span class="line">    __metaclass__ = MagicMeta</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, method_name)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            self._callMethod(method_name, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callStaticMethod</span><span class="params">(method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        调用不存在的静态方法时执行的函数</span></span><br><span class="line"><span class="string">        :param method_name: 方法名</span></span><br><span class="line"><span class="string">        :param args:   方法参数</span></span><br><span class="line"><span class="string">        :param kwargs: 方法参数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callMethod</span><span class="params">(self, method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        调用不存在的方法时执行的函数</span></span><br><span class="line"><span class="string">        :param method_name: 方法名</span></span><br><span class="line"><span class="string">        :param args:   方法参数</span></span><br><span class="line"><span class="string">        :param kwargs: 方法参数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MagicCall)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callStaticMethod</span><span class="params">(method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        print(method_name, args, kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callMethod</span><span class="params">(self, method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        print(method_name, args, kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    ins = MyClass()</span><br><span class="line">    ins.hello(<span class="string">'xx'</span>, <span class="string">'pp'</span>)</span><br><span class="line">    MyClass.hello(<span class="string">'xxx'</span>, <span class="string">'ppp'</span>, xname=<span class="string">'linxianlong'</span>)</span><br><span class="line">    MethodProxy.hello()</span><br></pre></td></tr></table></figure></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2017/07/24/python-call-callStatic/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>