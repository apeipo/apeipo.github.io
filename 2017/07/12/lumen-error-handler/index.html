<!DOCTYPE html><html><head><meta charset="utf-8"><title>Lumen和Laravel错误处理机制修改 | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="PHP,LARAVEL,LUMEN,"><meta name="description" content="在使用Laravel或者Lumen时会碰到这种情况，如果php的代码中产生了Notice或者Warning，会导致Lumen跳到错误页，日志中会打印一个很长很长的stack trace，如下图：$app-&amp;gt;get(&apos;/test&apos;, function () use ($app) &amp;#123;	$arr = [];	print($arr[&apos;name&apos;]);&amp;#125;);#请求/test 产生的"><meta name="keywords" content="PHP,LARAVEL,LUMEN"><meta property="og:type" content="article"><meta property="og:title" content="Lumen和Laravel错误处理机制修改"><meta property="og:url" content="http://longlog.me/2017/07/12/lumen-error-handler/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="在使用Laravel或者Lumen时会碰到这种情况，如果php的代码中产生了Notice或者Warning，会导致Lumen跳到错误页，日志中会打印一个很长很长的stack trace，如下图：$app-&amp;gt;get(&apos;/test&apos;, function () use ($app) &amp;#123;	$arr = [];	print($arr[&apos;name&apos;]);&amp;#125;);#请求/test 产生的"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2019-08-29T07:09:16.056Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Lumen和Laravel错误处理机制修改"><meta name="twitter:description" content="在使用Laravel或者Lumen时会碰到这种情况，如果php的代码中产生了Notice或者Warning，会导致Lumen跳到错误页，日志中会打印一个很长很长的stack trace，如下图：$app-&amp;gt;get(&apos;/test&apos;, function () use ($app) &amp;#123;	$arr = [];	print($arr[&apos;name&apos;]);&amp;#125;);#请求/test 产生的"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#错误处理流程"><span class="toc-text">错误处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#错误Handler"><span class="toc-text">错误Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误触发"><span class="toc-text">错误触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ErrorException和Handler"><span class="toc-text">ErrorException和Handler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决"><span class="toc-text">解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法1-屏蔽错误"><span class="toc-text">方法1.屏蔽错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法2-修改Handler"><span class="toc-text">方法2.修改Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法3-在业务逻辑顶层中catch异常"><span class="toc-text">方法3.在业务逻辑顶层中catch异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法4-修改error-handler，不抛出异常"><span class="toc-text">方法4.修改error_handler，不抛出异常</span></a></li></ol></li></ol></div><div class="content-post LEFT"><article id="post-lumen-error-handler" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">Lumen和Laravel错误处理机制修改</h1><div class="article-meta"><span>2017-07-12</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/PHP/">PHP</a></span></div></header><div class="article-content"><p>在使用Laravel或者Lumen时会碰到这种情况，如果php的代码中产生了Notice或者Warning，会导致Lumen跳到错误页，日志中会打印一个很长很长的stack trace，如下图：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$app-&gt;get(<span class="string">'/test'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($app)</span> </span>&#123;</span><br><span class="line">	$arr = [];</span><br><span class="line">	<span class="keyword">print</span>($arr[<span class="string">'name'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">#请求/test 产生的日志</span></span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">55</span>:<span class="number">54</span>] lumen.ERROR: ErrorException: Undefined index: name in /home/vagrant/Code/featurestream/routes/web.php:<span class="number">16</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 /home/vagrant/Code/featurestream/routes/web.php(16): Laravel\Lumen\Application-&gt;Laravel\Lumen\Concerns\&#123;closure&#125;(8, 'Undefined index...', '/home/vagrant/C...', 16, Array)</span></span><br><span class="line"><span class="comment">#1 [internal function]: Closure-&gt;&#123;closure&#125;()</span></span><br><span class="line"><span class="comment">#2 /home/vagrant/Code/featurestream/vendor/illuminate/container/BoundMethod.php(29): call_user_func_array(Object(Closure), Array)</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>上面的日志只截取了一小部分，实际运行时最简单的api请求Lumen的stack trace会有30层左右，Laravel的会有60层..<br>另外一个重要的问题是，这种处理机制会让一些小错误把整个请求搞挂，代码中到处加<code>if(isset($arr[&#39;xx&#39;]))</code> 或者设置默认值。<br>对于这个问题，Laravel和Lumen设计的初衷是好的：<strong>所有的PHP错误都应该被处理，包括Notice和Warning</strong>。就是太严格了，有时候我们并不需要代码有这么严格的检查，出现Notice或者Warning时，只需要打印个模块日志或者有PHP日志就行。<br>先看下Lumen中的错误是如何处理的（Laravel中也差不多，不再单独讲）。</p><h2 id="错误处理流程"><a href="#错误处理流程" class="headerlink" title="错误处理流程"></a>错误处理流程</h2><h3 id="错误Handler"><a href="#错误Handler" class="headerlink" title="错误Handler"></a>错误Handler</h3><p>先看Lumen的入口：<code>bootstrap/app.php</code>，有一段错误处理相关的代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Debug\ExceptionHandler::class,</span><br><span class="line">    App\Exceptions\Handler::class</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>singleton是往app（Lumen的服务容器）里注入实例的方法，这里实例化了一个ExceptionHandler类，实例为Handler。后面的代码如果有从$app里取ExceptionHandler的实例的话，会返回Handler这个类的实例。<br>Handler类在App\Exceptions目录下，代码如下。比较简单，只包含两个方法，再去看父类(<code>Laravel\Lumen\Exceptions\Handler</code>)的方法逻辑会发现，<strong>report方法负责打印日志（也就是上文那个长长的trace），render方法会根据错误类型的不同构建错误页面</strong>。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">report</span><span class="params">(Exception $e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">parent</span>::report($e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">($request, Exception $e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">parent</span>::render($request, $e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误的处理逻辑找到了，如何触发进入这个逻辑的呢？</p><h3 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h3><p>正常情况下，PHP产生Notice或者Warning是不会抛出Exception的，会产生Exception肯定是框架内部做了更改。<br><code>bootstrap/app.php</code>中没找到设置错误处理的地方，接着往下看Lumen框架的容器类Application（Lumen的核心类和入口），目录：<code>vendor/laravel/lumen-framework/src/Application.php</code>。<br>可以看到在其构造函数中调用了一个registerErrorHandling方法，方法代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the error handling for the application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerErrorHandling</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    error_reporting(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    set_error_handler(<span class="function"><span class="keyword">function</span> <span class="params">($level, $message, $file = <span class="string">''</span>, $line = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error_reporting() &amp; $level) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorException($message, <span class="number">0</span>, $level, $file, $line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    set_exception_handler(<span class="function"><span class="keyword">function</span> <span class="params">($e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;handleUncaughtException($e);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    register_shutdown_function(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;handleShutdown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set_error_handler</code>是PHP设置错误处理的方法。registerErrorHandling下用<code>error_reporting(-1)</code>把PHP的报错开关都打开，这样所有级别的错误都会触发<code>error_handler</code>。在<code>error_handler</code>中抛出了一个ErrorException异常。<br>至此，我们知道ErrorException这个异常是怎么产生的了，知道异常会交由谁来处理了（上一节中的Handler类）。不过还有个疑问，ErrorException和Handler是怎么关联起来的？</p><h3 id="ErrorException和Handler"><a href="#ErrorException和Handler" class="headerlink" title="ErrorException和Handler"></a>ErrorException和Handler</h3><p><code>set_error_handler</code>设置的方法中会抛出异常，那肯定存在针对异常的try catch块。<br>从请求路口<code>public/index.php</code>往下看，<br>–&gt;<code>bootstrap/app.php</code> –&gt;<code>Application.php -&gt; run</code> –&gt;<code>Application.php -&gt; dispatch</code><br>在dispatch方法中发现了try catch的逻辑，在catch到Exception后调用了Handler的report和render方法。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($request = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">list</span>($method, $pathInfo) = <span class="keyword">$this</span>-&gt;parseIncomingRequest($request);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">			...</span><br><span class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;prepareResponse(<span class="keyword">$this</span>-&gt;sendExceptionToHandler($e));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;prepareResponse(<span class="keyword">$this</span>-&gt;sendExceptionToHandler($e));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">sendExceptionToHandler</span><span class="params">($e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   $handler = <span class="keyword">$this</span>-&gt;resolveExceptionHandler();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ($e <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">       $e = <span class="keyword">new</span> FatalThrowableError($e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   $handler-&gt;report($e);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> $handler-&gt;render(<span class="keyword">$this</span>-&gt;make(<span class="string">'request'</span>), $e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>知道了错误从触发到结束的整个流程，再来看怎么解决.</p><h3 id="方法1-屏蔽错误"><a href="#方法1-屏蔽错误" class="headerlink" title="方法1.屏蔽错误"></a>方法1.屏蔽错误</h3><p>简单粗暴的方法，既然框架用来<code>error_reporting(-1)</code>打开了所有错误开关，那我们再用<code>error_reporting</code>把我们不关心的错误给屏蔽了。把下面代码加在<code>bootstrap/app.php</code>中，<strong>注意得加在Applition实例化之后</strong>。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">error_reporting(E_ALL ^ E_NOTICE ^ E_WARNING);</span><br></pre></td></tr></table></figure><p>这种方法的弊端显而易见，我们只是不想让E_NOTICE搞挂请求，但是这类错误还是得关注和修复的。。</p><h3 id="方法2-修改Handler"><a href="#方法2-修改Handler" class="headerlink" title="方法2.修改Handler"></a>方法2.修改Handler</h3><p>既然是Handler负责错误处理，那我们修改Handler(<code>App\Exceptions\Handler</code>)的逻辑就行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">report</span><span class="params">(Exception $e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//parent::report($e);</span></span><br><span class="line">    Log::warning($e-&gt;getMessage(), [<span class="string">'file'</span> =&gt; $e-&gt;getFile(), <span class="string">'line'</span> =&gt; $e-&gt;getLine()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">($request, Exception $e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return parent::render($request, $e);</span></span><br><span class="line">    header(<span class="string">'Content-type: application/json'</span>);</span><br><span class="line">    <span class="keyword">echo</span> json_encode([<span class="string">'errmsg'</span> =&gt; $e-&gt;getMessage()]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，将错误处理逻辑进行更改，只打印简单的日志，并且也不跳到错误页了。<br>不过，这种方法还是有问题：</p><ol><li>代码产生的NOTICE和WARNING还是会中断执行流程（因为会抛出异常）。比如一个请求中执行A-&gt;B-&gt;C三个方法，如果B中产生了一个NOTICE，整个请求还是会被中断，C不会被执行。</li><li>如果一个请求原本不是返回json，是返回一个view，则上面的render方法就不适用了。</li></ol><h3 id="方法3-在业务逻辑顶层中catch异常"><a href="#方法3-在业务逻辑顶层中catch异常" class="headerlink" title="方法3.在业务逻辑顶层中catch异常"></a>方法3.在业务逻辑顶层中catch异常</h3><p>原理类似方法2，只不过把异常的处理从Handler中移到了业务逻辑里（比如Controller中）。<br>这个方法的问题和方法2一样，NOTICE还是会中断请求…</p><h3 id="方法4-修改error-handler，不抛出异常"><a href="#方法4-修改error-handler，不抛出异常" class="headerlink" title="方法4.修改error_handler，不抛出异常"></a>方法4.修改<code>error_handler</code>，不抛出异常</h3><p>罪魁祸首就在于那个<code>set_error_handler</code>注册的处理方法遇到PHP错误就会抛出异常，那我们修改他就行。<br><code>set_error_handler</code>所在的registerErrorHandling方法在框架的源代码中，最好不要直接修改，我们可以在它注册完之后再重新注册一个覆盖它。可以加在<code>bootstrap/app.php</code>中，Application实例化之后。代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">set_error_handler(<span class="function"><span class="keyword">function</span> <span class="params">($level, $message, $file = <span class="string">''</span>, $line = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($level == E_NOTICE || $level == E_WARNING) &#123;</span><br><span class="line">        Log::warning(<span class="string">"PHP NOTICE or WARNING; MSG:[$message]"</span>, [<span class="string">'file'</span> =&gt; $file, <span class="string">'line'</span> =&gt; $line]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error_reporting() &amp; $level) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ErrorException($message, <span class="number">0</span>, $level, $file, $line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，<strong>代码中因为使用了Log这个Facades，因此必须放在$app-&gt;withFacades()之后</strong><br>至此，NOTICE和WARNING不会产生烦人的日志，也不会搞挂请求，并且也保留了有效的提示信息。：）</p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2017/07/12/lumen-error-handler/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>