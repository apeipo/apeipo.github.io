<!DOCTYPE html><html><head><meta charset="utf-8"><title>Python2和3编码整理 | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Python,"><meta name="description" content="参考文章Python编码Python2 与 Python3 的编码对比UnicodeEncodeError&amp;amp; UnicodeDecodeError用 Python2 编写程序的时候经常会遇到 UnicodeEncodeError 和 UnicodeDecodeError，它们出现的根源就是如果代码里面混合使用了 str 类型和 unicode 类型的字符串，Python 会默认使用 asc"><meta name="keywords" content="Python"><meta property="og:type" content="article"><meta property="og:title" content="Python2和3编码整理"><meta property="og:url" content="http://longlog.me/2017/07/06/python23-codec/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="参考文章Python编码Python2 与 Python3 的编码对比UnicodeEncodeError&amp;amp; UnicodeDecodeError用 Python2 编写程序的时候经常会遇到 UnicodeEncodeError 和 UnicodeDecodeError，它们出现的根源就是如果代码里面混合使用了 str 类型和 unicode 类型的字符串，Python 会默认使用 asc"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2019-08-29T07:09:16.061Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Python2和3编码整理"><meta name="twitter:description" content="参考文章Python编码Python2 与 Python3 的编码对比UnicodeEncodeError&amp;amp; UnicodeDecodeError用 Python2 编写程序的时候经常会遇到 UnicodeEncodeError 和 UnicodeDecodeError，它们出现的根源就是如果代码里面混合使用了 str 类型和 unicode 类型的字符串，Python 会默认使用 asc"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-text">参考文章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UnicodeEncodeError-amp-UnicodeDecodeError"><span class="toc-text">UnicodeEncodeError&amp; UnicodeDecodeError</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python2和3的字符串"><span class="toc-text">Python2和3的字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串类型"><span class="toc-text">字符串类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#encode和decode"><span class="toc-text">encode和decode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串处理的前提"><span class="toc-text">字符串处理的前提</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他区别"><span class="toc-text">其他区别</span></a></li></ol></li></ol></div><div class="content-post LEFT"><article id="post-python23-codec" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">Python2和3编码整理</h1><div class="article-meta"><span>2017-07-06</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/后端/">后端</a></span></div></header><div class="article-content"><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://funhacks.net/explore-python/Basic/character_encoding.html" target="_blank" rel="noopener">Python编码</a><br><a href="http://kuanghy.github.io/2016/10/15/encoding-python2-vs-python3" target="_blank" rel="noopener">Python2 与 Python3 的编码对比</a></p><h2 id="UnicodeEncodeError-amp-UnicodeDecodeError"><a href="#UnicodeEncodeError-amp-UnicodeDecodeError" class="headerlink" title="UnicodeEncodeError&amp; UnicodeDecodeError"></a>UnicodeEncodeError&amp; UnicodeDecodeError</h2><p>用 Python2 编写程序的时候经常会遇到 UnicodeEncodeError 和 UnicodeDecodeError，它们出现的根源就是如果代码里面混合使用了 str 类型和 unicode 类型的字符串，<strong>Python 会默认使用 ascii 编码尝试对 unicode 类型的字符串编码 (encode)，或对 str 类型的字符串解码 (decode)</strong>。<br>例如：<strong>s = u’中文’ + ‘中国’</strong>, python2会隐式地调用 <code>&#39;中国&#39;.decode(&#39;ascii&#39;)</code>，发生decodeError。<br>同样的，如果某些方法要求str类型，而调用时传入了unicode类型，python会使用encode(‘ascii’)对传入值进行转换，如果穿入值存在非ascii字符，就会发送EncodeError</p><h2 id="Python2和3的字符串"><a href="#Python2和3的字符串" class="headerlink" title="Python2和3的字符串"></a>Python2和3的字符串</h2><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><strong>Python2 中字符的类型</strong>：<br>str： 某种编码（UTF-8，GBK等）类型的字节序列<br>unicode： Unicode类型的字符串<br><strong>Python3 中字符的类型</strong>：<br>str： Unicode类型的字符串<br>bytes： 某种编码（UTF-8，GBK等）类型的字节序列</p><p>不管是Python2还是3，我们可以认为字符串有两种状态：</p><ol><li>未编码的状态（unicode字节序列），如中文对应：u’\u4e2d\u6587’</li><li>编码后的状态（按指定编码转换字节序列），如中文按utf-8编码后是’\xe4\xb8\xad\xe6\x96\x87’</li></ol><p>Python2 和 Python3 中的两种字符类型都分别对应这两种状态，然后相互之间进行编解码转化。<br>实际上，Python3中的str可以认为是Python2中的unicode类型，而bytes相当于Python2中的str类型。</p><h3 id="encode和decode"><a href="#encode和decode" class="headerlink" title="encode和decode"></a>encode和decode</h3><p>编码(encode)就是将字符串转换成指定编码的字节码；解码(decode)就是按指定的编码解析字节序列，将比特位显示成字符。<br>Python2和3中两个方法的对比：</p><table><thead><tr><th></th><th>Python2</th><th>Python3</th></tr></thead><tbody><tr><td>encode</td><td>unicode 按指定编码转为 str（即字节码），默认ascii</td><td>str(unicode) 编码为 bytes,默认使用utf-8 <strong>只有str类型有该方法</strong></td></tr><tr><td>decode</td><td>str 按指定编码解码为 unicode，默认ascii)</td><td>bytes 解码为 str ，默认使用utf-8 <strong>只有bytes类型有该方法</strong></td></tr></tbody></table><p>在 Python2 中，str 和 unicode 都有 encode 和 decode 方法。但是不建议对 str 使用 encode(会内部隐式地先decode解码)，对 unicode 使用 decode(会内部隐式地先encode编码), 这是 Python2 设计上的缺陷。<br>Python3 则进行了优化，<strong>str 只有一个 encode 方法将字符串转化为一个字节码，而且 bytes 也只有一个 decode 方法将字节码转化为一个文本字符串</strong>。</p><h3 id="字符串处理的前提"><a href="#字符串处理的前提" class="headerlink" title="字符串处理的前提"></a>字符串处理的前提</h3><p>对于Python文件中字符串的解析，有一些前提：</p><ol><li>Python 文件开始已经声明对应的编码</li><li>Python 文件本身的确是使用该编码保存的</li><li>两者的编码类型要一样（比如都是 UTF-8 或者都是 GBK 等）</li></ol><p><strong>满足这些前提，Python解析器才能正确的把文本解析为对应的unicode</strong>。<br>同样的，在Python2中，如果用u’中文’这种方式定义字符串也得满足上诉前提，否则Python无法将其转为unicode字符（定义普通的str不存在该问题，因为Python2中的str就是字节序列，Python不会转为unicode）。</p><h3 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别"></a>其他区别</h3><ol><li>Python2 的 str 和 unicode 都是 basestring 的子类，所以两者可以直接进行拼接操作。而 Python3 中的 bytes 和 str 是两个独立的类型，两者不能进行拼接。</li><li>Python2 中，普通字符串（如：s = “中文”）的编码类型，对应着你的 Python 文件本身保存为何种编码有关，最常见的 Windows 平台中，默认用的是 GBK。Python3 中，定义的字符串就已经是 Unicode 类型的 str了（Python解释器根据文件编码转换而来）。</li></ol><p>总体来说，Python3的编码表示更直接，字符串总是unicode，二进制制是bytes，不像Python2中将两者混在一起造成处理上的混淆。</p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2017/07/06/python23-codec/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>