<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>swool2.0 协程 | apeipo的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="PHP,Swoole,"><meta name="description" content="2.0更新说明官方链接Swoole 2.0正式版发布了。2.0版本最大的更新是增加了对协程（Coroutine）的支持。正式版已同时支持PHP5和PHP7。基于Swoole2.0协程PHP开发者可以已同步的方式编写代码，底层自动进行协程调度，转变为异步IO。解决了传统异步编程嵌套回调的问题。与Node.js（ES6+）、Python等语言使用yield/generator、async/await的"><meta name="keywords" content="PHP,Swoole"><meta property="og:type" content="article"><meta property="og:title" content="swool2.0 协程"><meta property="og:url" content="http://longlog.me/2017/02/09/swoole2-coroutine/index.html"><meta property="og:site_name" content="apeipo的博客"><meta property="og:description" content="2.0更新说明官方链接Swoole 2.0正式版发布了。2.0版本最大的更新是增加了对协程（Coroutine）的支持。正式版已同时支持PHP5和PHP7。基于Swoole2.0协程PHP开发者可以已同步的方式编写代码，底层自动进行协程调度，转变为异步IO。解决了传统异步编程嵌套回调的问题。与Node.js（ES6+）、Python等语言使用yield/generator、async/await的"><meta property="og:locale" content="default"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-02-10-14867149196922.jpg"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-02-10-14867149572894.jpg"><meta property="og:updated_time" content="2019-08-29T07:09:16.053Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="swool2.0 协程"><meta name="twitter:description" content="2.0更新说明官方链接Swoole 2.0正式版发布了。2.0版本最大的更新是增加了对协程（Coroutine）的支持。正式版已同时支持PHP5和PHP7。基于Swoole2.0协程PHP开发者可以已同步的方式编写代码，底层自动进行协程调度，转变为异步IO。解决了传统异步编程嵌套回调的问题。与Node.js（ES6+）、Python等语言使用yield/generator、async/await的"><meta name="twitter:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-02-10-14867149196922.jpg"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-0更新说明"><span class="toc-text">2.0更新说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于协程"><span class="toc-text">关于协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异步IO-Reactor"><span class="toc-text">异步IO-Reactor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步IO"><span class="toc-text">同步IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步IO"><span class="toc-text">异步IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞和非阻塞"><span class="toc-text">阻塞和非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor模式"><span class="toc-text">Reactor模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor和观察者模式的区别"><span class="toc-text">Reactor和观察者模式的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程"><span class="toc-text">协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swoole的协程处理"><span class="toc-text">swoole的协程处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swoole2-0协程使用和性能测试"><span class="toc-text">swoole2.0协程使用和性能测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#开启协程："><span class="toc-text">开启协程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#测试代码："><span class="toc-text">测试代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试结果："><span class="toc-text">测试结果：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#传统方式："><span class="toc-text">传统方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协程方式："><span class="toc-text">协程方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他客户端的使用"><span class="toc-text">其他客户端的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-text">参考文章</span></a></li></ol></div><div class="content-post LEFT"><article id="post-swoole2-coroutine" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">swool2.0 协程</h1><div class="article-meta"><span>2017-02-09</span> <span>| </span><span class="article-author">apeipo</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/PHP/">PHP</a></span></div></header><div class="article-content"><h2 id="2-0更新说明"><a href="#2-0更新说明" class="headerlink" title="2.0更新说明"></a>2.0更新说明</h2><p><a href="https://wiki.swoole.com/wiki/page/672.html" target="_blank" rel="noopener">官方链接</a></p><blockquote><p>Swoole 2.0正式版发布了。2.0版本最大的更新是增加了对协程（Coroutine）的支持。正式版已同时支持PHP5和PHP7。基于Swoole2.0协程PHP开发者可以已同步的方式编写代码，底层自动进行协程调度，转变为异步IO。<strong>解决了传统异步编程嵌套回调的问题。</strong><br>与Node.js（ES6+）、Python等语言使用yield/generator、async/await的实现方式相比，Swoole协程无需修改代码添加额外的关键词。<br>与Go语言的goroutine相比，Swoole协程是内置式的，应用层代码无需添加go关键词启动协程，只需要使用封装好的协程客户端即可，使用更简单。另外Swoole协程的IO组件在底层内置了超时机制，不需要使用复杂的select/chan/timer实现客户端超时。<br>目前Swoole底层内置的协程客户端组件包括：udpclient、tcpclient、httpclient、redisclient、mysqlclient，基本涵盖了开发者常用的几种通信协议。协程组件只能在服务器的onConnect、onRequest、onReceive、onMessage 回调函数中使用。</p></blockquote><h2 id="关于协程"><a href="#关于协程" class="headerlink" title="关于协程"></a>关于协程</h2><h3 id="异步IO-Reactor"><a href="#异步IO-Reactor" class="headerlink" title="异步IO-Reactor"></a>异步IO-Reactor</h3><h4 id="同步IO"><a href="#同步IO" class="headerlink" title="同步IO"></a>同步IO</h4><p>当一个线程在进行io操作时，传统的处理方法线程会阻塞等待IO完成，等待过程无法接收其他请求，程序的并发能力存在很大的瓶颈。<br>可以通过多线程or多进程的方式提升程序的并发处理能力，但是没有本质上的提升。原因在于系统能创建的进程数量是有限的，并且阻塞IO这种等待自身就是对cpu资源的浪费。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>相对于同步IO，异步IO过程中，线程在IO开始时会注册系统回调，IO过程中线程可以进行其他工作，IO完成后执行回调进行后续操作。<br>可以看到，异步IO一个本质的区别是：<strong>同一个线程，能同时处理多个IO请求</strong>。这种情况下程序的并发能力有很大的提升。<br>例如某个IO请求的耗时为1s，在单线程同步IO方式下，理论上最大只能达到1qps，异步IO方式的qps远高于这个数。</p><h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><blockquote><p>一个IO操作其实分成了两个步骤：<strong>发起IO请求和实际的IO操作</strong><br><strong>阻塞IO和非阻塞IO的区别在于第一步</strong>：发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO;如果不阻塞，那么就是非阻塞IO<br><strong>同步IO和异步IO的区别就在于第二个步骤是否阻塞</strong>，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO;如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO</p></blockquote><h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h4><p>参考文章： <a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.html" target="_blank" rel="noopener">高性能IO</a><br>异步非阻塞的实现是应用了Reactor模式。用户线程向Reactor注册事件处理函数，Reactor负责管理EventHandler（注册、调用、删除）、轮询系统事件（通过epool或者select系统调用）。线程注册了EventHandler之后可以继续执行其他操作。<br>注意：</p><ol><li><strong>Reactor只是一个事件管理器，实际的IO操作是在EventHandler(用户实现)中完成的</strong>。</li><li><strong>异步非阻塞IO，实际上并不是真正的异步，因为程序接收的事件是：可读 or 可写，实际的读写操作都是需要应用自己完成（从socket读取）</strong>。</li><li><strong>完成的异步IO实现是Proactor模式，程序接收的事件是： 读取完成 or 写入完成了，读写操作由系统完成，应用从缓冲区读取</strong>。</li></ol><p>Reactor结构图：<img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-02-10-14867149196922.jpg" alt=""></p><p>Reactor时序图：<img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-02-10-14867149572894.jpg" alt=""></p><h4 id="Reactor和观察者模式的区别"><a href="#Reactor和观察者模式的区别" class="headerlink" title="Reactor和观察者模式的区别"></a>Reactor和观察者模式的区别</h4><p>观察者模式是一种一对多的<strong>发布-订阅</strong>的关系，更多应用于消息的分发。<br>Reactor更强调的是<strong>注册-回调</strong>，应用于高效率IO。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><blockquote><p>协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在。<br>个人理解，协程是应用层对异步IO的一种实现，封装了异步IO的回调、上下文切换等过程。</p></blockquote><h3 id="swoole的协程处理"><a href="#swoole的协程处理" class="headerlink" title="swoole的协程处理"></a>swoole的协程处理</h3><p>在swoole中使用自带协程的client，在进行io此操作时（如connect，query），swoole会保存当前的上下文信息保存在swoole开辟的栈内，然后将协程挂起等待返回。<br>io完成后，触发epool事件，协程切换，恢复上下文，继续执行php代码。<br>从处理流程可以看出，协程的实现是语言层面的实现，在操作系统中并没有这个概念，而进程和线程是操作系统级别的，其调度和上下文切换是由操作系统对外提供的api实现的。</p><h3 id="swoole2-0协程使用和性能测试"><a href="#swoole2-0协程使用和性能测试" class="headerlink" title="swoole2.0协程使用和性能测试"></a>swoole2.0协程使用和性能测试</h3><h4 id="开启协程："><a href="#开启协程：" class="headerlink" title="开启协程："></a>开启协程：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">phpize</span><br><span class="line">./configure --with-php-config=&#123;path-to-php-config&#125;  --<span class="built_in">enable</span>-coroutine</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>注意：<strong>目前只支持在onRequet, onReceive, onConnect事件回调函数中使用协程。</strong></p><h4 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$server = <span class="keyword">new</span> Swoole\Http\Server(<span class="string">'127.0.0.1'</span>, <span class="number">9501</span>);</span><br><span class="line">$dbConn = mysqli_connect(<span class="string">"127.0.0.1"</span> , <span class="string">"root"</span>, <span class="string">"secret"</span>, <span class="string">"homestead"</span>);</span><br><span class="line">$swooleDb = <span class="keyword">new</span> swoole_mysql;</span><br><span class="line">$server-&gt;set([</span><br><span class="line">     <span class="string">'worker_num'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="comment">/*触发on request事件时，SWOOLE会开辟一个协程栈，对协程栈进行初始化*/</span></span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($request, $response)</span> <span class="title">use</span> <span class="params">($dbConn, $swooleDb)</span></span>&#123;</span><br><span class="line">    $style = $request-&gt;get[<span class="string">"style"</span>];</span><br><span class="line">    <span class="comment">//传统方式，同步阻塞IO</span></span><br><span class="line">    <span class="keyword">if</span> ($style == <span class="string">"sync"</span>) &#123;</span><br><span class="line">        $res = mysqli_query($dbConn, <span class="string">"select sleep(1)"</span>);</span><br><span class="line">        $ret = mysqli_fetch_assoc($res);</span><br><span class="line">        <span class="keyword">echo</span> !<span class="keyword">empty</span>($ret) ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">        $response-&gt;end(<span class="string">"mysql sync is ok \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异步IO，swoole 1.8.5</span></span><br><span class="line">    <span class="keyword">if</span> ($style == <span class="string">"async"</span>) &#123;</span><br><span class="line">		$swooleDb-&gt;connect(</span><br><span class="line">			[<span class="string">"host"</span> =&gt; <span class="string">"127.0.0.1"</span>, </span><br><span class="line">			 <span class="string">"user"</span> =&gt; <span class="string">"root"</span>, </span><br><span class="line">			 <span class="string">"password"</span> =&gt; <span class="string">"secret"</span>, </span><br><span class="line">			 <span class="string">"database"</span> =&gt; <span class="string">"test"</span>], </span><br><span class="line">			 <span class="function"><span class="keyword">function</span> <span class="params">($swooleDb, $resp)</span> </span>&#123;</span><br><span class="line">			    $sql = <span class="string">'select sleep(1)'</span>;</span><br><span class="line">			    $swooleDb-&gt;query($sql, <span class="function"><span class="keyword">function</span><span class="params">(swoole_mysql $swooleDb, $res)</span> </span>&#123;</span><br><span class="line">			    	$response-&gt;end(<span class="string">"mysql async is ok \n"</span>);</span><br><span class="line">			    &#125;);</span><br><span class="line">			&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//协程方式, swoole 2.0</span></span><br><span class="line">    <span class="keyword">if</span> ($style == <span class="string">"coroutine"</span>) &#123;</span><br><span class="line">        $swoole_mysql = <span class="keyword">new</span> Swoole\Coroutine\MySQL();</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        client在调用connect函数后，SWOOLE会将PHP上下文信息保存到当前栈内</span></span><br><span class="line"><span class="comment">        然后将协程挂起，待确认连接成功后，触发epoll事件，然后协程切换</span></span><br><span class="line"><span class="comment">        恢复PHP上下文信息，返回结果，继续执行PHP代码</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        $swoole_mysql-&gt;connect([</span><br><span class="line">            <span class="string">'host'</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">            <span class="string">'user'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line">            <span class="string">'password'</span> =&gt; <span class="string">'secret'</span>,</span><br><span class="line">            <span class="string">'database'</span> =&gt; <span class="string">'homestead'</span></span><br><span class="line">        ]);</span><br><span class="line">        $res = $swoole_mysql-&gt;query(<span class="string">'select sleep(1)'</span>);</span><br><span class="line">        <span class="keyword">echo</span> !<span class="keyword">empty</span>($res) ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">        $response-&gt;end(<span class="string">"mysql async is ok \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h3><h4 id="传统方式："><a href="#传统方式：" class="headerlink" title="传统方式："></a>传统方式：</h4><p>./bin/siege -c 10 -r 20 “<a href="http://127.0.0.1:9501/?style=sync&quot;" target="_blank" rel="noopener">http://127.0.0.1:9501/?style=sync&quot;</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Transactions:                 200 hits</span><br><span class="line">Availability:              100.00 %</span><br><span class="line">Elapsed time:              200.33 secs</span><br><span class="line">Data transferred:            0.00 MB</span><br><span class="line">Response time:                9.26 secs</span><br><span class="line">Transaction rate:            1.00 trans/sec</span><br><span class="line">Throughput:                0.00 MB/sec</span><br><span class="line">Concurrency:                9.25</span><br><span class="line">Successful transactions:         200</span><br><span class="line">Failed transactions:               0</span><br><span class="line">Longest transaction:           10.03</span><br><span class="line">Shortest transaction:            1.00</span><br></pre></td></tr></table></figure><h4 id="协程方式："><a href="#协程方式：" class="headerlink" title="协程方式："></a>协程方式：</h4><p>./bin/siege -c 10 -r 20 “<a href="http://127.0.0.1:9501/?style=coroutine&quot;" target="_blank" rel="noopener">http://127.0.0.1:9501/?style=coroutine&quot;</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Transactions:                 200 hits</span><br><span class="line">Availability:              100.00 %</span><br><span class="line">Elapsed time:               34.18 secs</span><br><span class="line">Data transferred:            0.00 MB</span><br><span class="line">Response time:                1.01 secs</span><br><span class="line">Transaction rate:            5.85 trans/sec</span><br><span class="line">Throughput:                0.00 MB/sec</span><br><span class="line">Concurrency:                5.89</span><br><span class="line">Successful transactions:         200</span><br><span class="line">Failed transactions:               0</span><br><span class="line">Longest transaction:            1.09</span><br><span class="line">Shortest transaction:            1.00</span><br></pre></td></tr></table></figure><p><strong>可以看到，单个线程处理耗时为1s的程序，传统处理方式的只能达到1qps，而协程方式能达到6qps</strong><br>swoole2之前提供的异步客户端和协程本质上没有区别，都是异步IO Reactor模型，所以没有进行性能测试。<br>相比于老的异步客户端的各种回调，从代码上可以看出来，协程的方式大大降低了代码的复杂度。<br>注意：<strong>协程组件只能在服务器的onConnect、onRequest、onReceive、onMessage 回调函数中使用。因为只有这些函数中swoole才会创建协程。</strong></p><h3 id="其他客户端的使用"><a href="#其他客户端的使用" class="headerlink" title="其他客户端的使用"></a>其他客户端的使用</h3><p><a href="https://wiki.swoole.com/wiki/page/672.html" target="_blank" rel="noopener">2.0.5使用示例</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>关于reactor，个人知识有限，了解的比较片面，详细的可以阅读下面这几篇大神文章。参考文章：<br><a href="http://rango.swoole.com/archives/508" target="_blank" rel="noopener">PHP并发IO编程之路</a><br><a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.html" target="_blank" rel="noopener">高性能IO模型</a><br><a href="http://www.cnblogs.com/ivaneye/p/5731432.html" target="_blank" rel="noopener">Reactor模型</a><br><a href="http://blog.csdn.net/mango_song/article/details/42643971" target="_blank" rel="noopener">epool</a></p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2017/02/09/swoole2-coroutine/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>