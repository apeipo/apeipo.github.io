<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>从配置Chares抓包理解HTTPS | apeipo的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Web,"><meta name="description" content="这两天看了一些https的文章，想起来之前捣鼓chares抓https包时一知半解，借这个问题总结一下Https。问题在Chares里通过Proxy-&amp;gt;SSL ProxySettings可以打开https代理，没有经过任何配置的话，抓包中看到的https链接是这样的。要解决这个问题很简单，按照官方的说法，只需要安装Chares的证书并在系统设置中信任该证书即可。这中间经历了什么过程，为什么安"><meta name="keywords" content="Web"><meta property="og:type" content="article"><meta property="og:title" content="从配置Chares抓包理解HTTPS"><meta property="og:url" content="http://longlog.me/2017/03/02/https/index.html"><meta property="og:site_name" content="apeipo的博客"><meta property="og:description" content="这两天看了一些https的文章，想起来之前捣鼓chares抓https包时一知半解，借这个问题总结一下Https。问题在Chares里通过Proxy-&amp;gt;SSL ProxySettings可以打开https代理，没有经过任何配置的话，抓包中看到的https链接是这样的。要解决这个问题很简单，按照官方的说法，只需要安装Chares的证书并在系统设置中信任该证书即可。这中间经历了什么过程，为什么安"><meta property="og:locale" content="default"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884377678270.jpg"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884423572656.jpg"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884564685368.jpg"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884574921787.png"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884592962322.jpg"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884612467318.jpg"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884617468013.jpg"><meta property="og:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884622405300.jpg"><meta property="og:updated_time" content="2019-08-29T07:09:16.066Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="从配置Chares抓包理解HTTPS"><meta name="twitter:description" content="这两天看了一些https的文章，想起来之前捣鼓chares抓https包时一知半解，借这个问题总结一下Https。问题在Chares里通过Proxy-&amp;gt;SSL ProxySettings可以打开https代理，没有经过任何配置的话，抓包中看到的https链接是这样的。要解决这个问题很简单，按照官方的说法，只需要安装Chares的证书并在系统设置中信任该证书即可。这中间经历了什么过程，为什么安"><meta name="twitter:image" content="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884377678270.jpg"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题"><span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加密算法"><span class="toc-text">加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对称加密"><span class="toc-text">对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非对称加密"><span class="toc-text">非对称加密</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS"><span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#裸奔"><span class="toc-text">裸奔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开始加密"><span class="toc-text">开始加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加密我的加密"><span class="toc-text">加密我的加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#认证机构-CA"><span class="toc-text">认证机构(CA)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数字证书"><span class="toc-text">数字证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数字签名"><span class="toc-text">数字签名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回归问题"><span class="toc-text">回归问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></div><div class="content-post LEFT"><article id="post-https" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">从配置Chares抓包理解HTTPS</h1><div class="article-meta"><span>2017-03-02</span> <span>| </span><span class="article-author">apeipo</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/Web/">Web</a></span></div></header><div class="article-content"><p>这两天看了一些https的文章，想起来之前捣鼓chares抓https包时一知半解，借这个问题总结一下Https。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在Chares里通过Proxy-&gt;SSL ProxySettings可以打开https代理，没有经过任何配置的话，抓包中看到的https链接是这样的。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884377678270.jpg" alt=""><br>要解决这个问题很简单，按照官方的说法，只需要安装Chares的证书并在系统设置中信任该证书即可。<br>这中间经历了什么过程，为什么安装证书后就可以看到https包内容，这就需要我们对https的原理有一定的了解。</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>在了解https之前，先简单说下加密算法。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>顾名思义，对称加密算法加密和解密用相同的密钥(Key)，密钥越大加密性越强，越不容易被破解。<br>常见的对称加密算法有DES、3DES、RC5等。<br>对称加密算法的优点是加密效率高，密钥足够大时安全性很强。缺点也很明显，发送者和接受者使用相同的密钥，发送者在发送消息时需要将密钥要发送给接受者，这样相当于没加密，密钥安全性无法保障。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>对比对称加密，非对称加密有两个密钥，公钥（Public Key）和私钥（Private Key）。公钥加密的数据只能由私钥解密，私钥加密的数据只能由公钥解密。私钥由发送者保存，公钥对外发布。<br>使用最广泛的非对称加密算法是RSA算法。<br>非对称加密算法的有点是在私钥不泄露情况下，能保证发送的消息不被篡改，收到的消息无法被破解，缺点是算法复杂度高，性能不如对称加密算法。<br>可以看出，<strong>在实际使用的安全性上</strong>，非对称加密算法要比对称加密算法高。这里强调的是使用安全性，因为就算法安全性来说，只要密钥够长，破解难度都是很高的。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>了解了加密算法，开始说说Https，思路主要是根据自己对Https的理解过程。</p><h3 id="裸奔"><a href="#裸奔" class="headerlink" title="裸奔"></a>裸奔</h3><p>对于http请求，在没有加密的时代，所有的请求参数都是对外暴露的。<br>对于攻击者来说，只要想办法拦截到用户的请求，很容易就能获取到交互内容和进行伪造。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884423572656.jpg" alt=""></p><h3 id="开始加密"><a href="#开始加密" class="headerlink" title="开始加密"></a>开始加密</h3><p>要保证请求的内容即使被拦截也无法破解，最简单的方法就是对请求内容进行加密，但是用哪种加密算法呢？<br>从使用安全性上考虑，当然是非对称加密算法。但是对于网络请求来说，性能就是生命，性能是第一要考虑的，因此性能更好的对称加密算法是首选。<br>从对加密算法的介绍中了解到，对称加密最大的问题在于，对于http请求来说，加密解密的密钥需要在Client和Server之间传输。如何保证密钥不被泄露？</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################10s分割线##################</span></span><br></pre></td></tr></table></figure><p>容易想到的是一点：Server一般都是接收多个Client的请求，因此为了保护密钥，这一点是肯定的：<strong>不同的会话需要使用不同的密钥</strong>。因此，在Client和Server通讯前必须有一个阶段，<strong>商量用什么密钥</strong>，就是密钥生成密钥的过程。<br>这样问题来了，这个商量的过程怎么保证不被泄露呢？ 再对这个商量过程进行对称加密？那你的这个加密过程又怎么保证呢？…无线循环了。<br>这时候，非对称加密就派上用场了。</p><h3 id="加密我的加密"><a href="#加密我的加密" class="headerlink" title="加密我的加密"></a>加密我的加密</h3><p>我们可以用非对称加密对密钥的生成过程进行加密。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884564685368.jpg" alt=""><br>如上图是一个的加密传输过程，使用非对称加密进行密钥生成，使用对称加密进行信息加密和传输。</p><ol><li>客户端请求服务端得到公钥。</li><li>客户端生成MasterKey并用公钥加密后发给服务端。</li><li>服务端接收到加密的信息并用私钥解密得到MasterKey。</li><li>服务端使用MasterKey加密Message发给客户端</li><li>客户端收到消息后用MasterKey解密出消息<br>至此，消息传输完成，使用非对称加密保证了MasterKey只有客户端和服务端知晓，从而保证了对称加密交互过程的信息安全。一个简化版本的Https交互完成。</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################10s分割线，想想该过程有什么问题？##################</span></span><br></pre></td></tr></table></figure><h4 id="认证机构-CA"><a href="#认证机构-CA" class="headerlink" title="认证机构(CA)"></a>认证机构(CA)</h4><p>上图的方案，解决了<strong>密钥的保护问题</strong>，但是会有另外一个问题，就是<strong>身份认证</strong>。<br>在第一步中，客户端请求服务端得到公钥，<strong>怎么确定这个公钥就是服务端的呢？</strong>。如果这一步的请求被第三方拦截了，返回给客户端第三方自己的公钥，整个交互过程又全暴露了。<br>具体的过程如下，容我偷懒盗个图。<a href="https://showme.codes/2017-02-20/understand-https/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">原图链接</a><br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884574921787.png" alt=""><br>可见，在非对称加密过程中，<strong>需要有公钥的身份验证，确保公钥不被篡改</strong>。<br>这时候，认证机构(Certification Authority)出现了，由认证机构负责对各Server的公钥进行管理。Server向认证机构申请了资格后，认证机构用自己的私钥给Server的公钥加密，生成一个”证明”。下次客户端请求时，服务端将这个”证明”返回给客户端。客户端用认证机构的公钥可以从证明中获取服务端的公钥。<br>那认证机构的公钥哪里来呢？总不能每次请求都访问一下认证机构吧。实际上，每台电脑上都保存着认证机构的信息，认证机构的公钥可以从客户端本地查询。</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>上文所说的这个”证明”，就是Https中的数字证书。数字证书由服务端向第三方机构申请，用于Https握手阶段的公钥身份验证。证书由第三方机构用私钥对申请信息(公钥)进行加密生成。<br><strong>注意，这里说的证书还只是第一版，并非最终的Https证书</strong></p><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>有了数字证书之后，我们来看下现在获取服务端公钥的过程。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884592962322.jpg" alt=""><br>可以看到，在引入CA后，解决了公钥被伪造的问题。因为如果攻击者劫持请求并伪造了证书，证书的内容是没法被CA的公钥解密的。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################10s分割线，想想该过程有什么问题？##################</span></span><br></pre></td></tr></table></figure><p>我们聪明的攻击者又来了！，上面这个过程难道还有漏洞？<br>是的，刚刚说到，上面的证书没法被伪造，但是。。。如果攻击者补伪造证书，自己向第三方机构申请证书，并发给客户端呢？！！<br>大家在想一下这个过程，客户端收到攻击者自己的证书（该证书是合法申请的），用第三方机构公钥解密得到了<strong>客户端认为的服务端公钥</strong>，然后用这个实际上是攻击者的公钥进行密钥生成….信息又全暴露了。<br>所以，我们还需要<strong>对证书进行认证</strong>，数字签名的引入，就是为了解决该问题。<br>带数字签名的证书生成过程：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884612467318.jpg" alt=""><br>如上图，CA在生成证书时，对证书的内容进行单向加密(这里以Md5为例，可以是其他算法如SHA)生成<strong>摘要</strong>，对摘要用个人私钥进行加密生成了数字签名。<br>客户端获取到证书后，用CA的公钥对签名进行解密得到摘要，再用Md5对证书内容生成本地的摘要，只要对比两个摘要是否相同就能确认该证书是不是由机构签发的。这里的证书就是真正意义上的Https证书。<br>至此，Https的密钥生成和消息传递过程的安全问题解决了，<strong>@1不过大家可以再想想上面这个过程还有没有问题，什么情况下会被破解？</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的Https过程只说了最主要的部分，实际上Https的握手阶段还要更复杂一些。容我再偷张图：<br><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">原图链接</a> <img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884617468013.jpg" alt=""></p><ol><li>客户端发出协议版本号、一个客户端生成的随机数（<strong>RandomA</strong>），以及客户端支持的加密方法。</li><li>服务端确认双方使用的加密方法，并返回数字证书和一个服务端生成的随机数（<strong>RandomB</strong>）。</li><li>客户端确认数字证书有效（有效期、签名），然后生成一个新的随机数（<strong>RandomC</strong>），并使用数字证书中的公钥，加密这个随机数，发给服务端。</li><li>服务端使用私钥，解密得到发来的RandomC。</li><li>客户端和服务端根据约定的加密方法，使用RandomA、B、C生成对话密钥（<strong>Session Key</strong>），后续的对话由该Key进行加密解密。<br>过程中的三个随机数，可以保证之前所说的，对不同的客户端，使用不同的密钥。<h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2>回到之前的Chares配置的问题。现在想想，如果你是Chares的开发者，用户已经设置了Chares作为代理，要想查看Https的包内容，应该怎么办？</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################10s分割线##################</span></span><br></pre></td></tr></table></figure><p>根据上文理解的Https的过程，可以看到，第三方如果想查看和伪造https的内容，必须满足两点：</p><ol><li>自己当CA，给自己颁发个证书。</li><li>让客户端电脑信任自己(CA)。<br>这两个步骤实际上就是Chares配置https代理过程所做的事，配置完成后，可以查看https的包内容：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884622405300.jpg" alt=""></li></ol><p>从这里也可以回答上面@1的问题，<strong>当系统层面被被攻破后，https就不是安全的</strong>，这也是越狱的iPhone，Root的安卓、以前用安装盘安装的XP不安全的其中一个原因。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://mp.weixin.qq.com/s/7ImZolr7m3tUuyOgMJeFYg" target="_blank" rel="noopener">理解HTTPS为什么安全前，先看看这些东西</a><br><a href="https://showme.codes/2017-02-20/understand-https/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">也许，这样理解HTTPS更容易</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL</a></p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2017/03/02/https/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>