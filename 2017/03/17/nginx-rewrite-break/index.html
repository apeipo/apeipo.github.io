<!DOCTYPE html><html><head><meta charset="utf-8"><title>nginx中的last和break | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Nginx,"><meta name="description" content="last后的操作之前看大部分文档说的是：last是从server域开始重新请求。nginx官方解释：last：stops processing the current set of ngx_http_rewrite_module directives followed by a search for a new location matching the changed URI;break：sto"><meta name="keywords" content="Nginx"><meta property="og:type" content="article"><meta property="og:title" content="nginx中的last和break"><meta property="og:url" content="http://longlog.me/2017/03/17/nginx-rewrite-break/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="last后的操作之前看大部分文档说的是：last是从server域开始重新请求。nginx官方解释：last：stops processing the current set of ngx_http_rewrite_module directives followed by a search for a new location matching the changed URI;break：sto"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2019-08-29T07:09:16.064Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="nginx中的last和break"><meta name="twitter:description" content="last后的操作之前看大部分文档说的是：last是从server域开始重新请求。nginx官方解释：last：stops processing the current set of ngx_http_rewrite_module directives followed by a search for a new location matching the changed URI;break：sto"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#last后的操作"><span class="toc-text">last后的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#server域里的last和break"><span class="toc-text">server域里的last和break</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#location中rewrite的作用"><span class="toc-text">location中rewrite的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#有rewrite"><span class="toc-text">有rewrite</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-break"><span class="toc-text">1.break</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-last"><span class="toc-text">2.last</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-redirect-perminate"><span class="toc-text">3.redirect , perminate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-default-rewrite后不带指令"><span class="toc-text">4.default(rewrite后不带指令)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无rewrite"><span class="toc-text">无rewrite</span></a></li></ol></li></ol></div><div class="content-post LEFT"><article id="post-nginx-rewrite-break" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">nginx中的last和break</h1><div class="article-meta"><span>2017-03-17</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/Nginx/">Nginx</a></span></div></header><div class="article-content"><h2 id="last后的操作"><a href="#last后的操作" class="headerlink" title="last后的操作"></a>last后的操作</h2><p>之前看大部分文档说的是：<br><strong>last</strong>是从server域开始重新请求。<br>nginx官方解释：</p><blockquote><p><strong>last：</strong><br>stops processing the current set of ngx_http_rewrite_module directives followed by a search for a new location matching the changed URI;<br><strong>break：</strong><br>stops processing the current set of ngx_http_rewrite_module directives;</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#location中的last</span></span><br><span class="line">rewrite /test2 /tt <span class="built_in">break</span>;</span><br><span class="line">  location /<span class="built_in">test</span> &#123;</span><br><span class="line">      rewrite /test2 /test3 <span class="built_in">break</span>;</span><br><span class="line">      rewrite /<span class="built_in">test</span> /test2 last;</span><br><span class="line">      rewrite /test2 /test3 <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  location /test2 &#123;</span><br><span class="line">      <span class="built_in">return</span> 508;</span><br><span class="line">  &#125;</span><br><span class="line">  location /test3 &#123;</span><br><span class="line">      <span class="built_in">return</span> 503;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>请求/test的结果:508,说明：</p><ol><li>location域里的last终止当前location下的所有rewrite(因为没有跳到test3),重启location匹配</li><li>重新发起请求后是从匹配location开始,不是从server域的rewrite开始(如果这样的话，应该跳转/tt,返回404)</li></ol><h2 id="server域里的last和break"><a href="#server域里的last和break" class="headerlink" title="server域里的last和break"></a>server域里的last和break</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#server中的last</span></span><br><span class="line">     rewrite /tt /index.html <span class="built_in">break</span>;</span><br><span class="line">     rewrite /test2 /tt last;</span><br><span class="line">     //rewrite /tt /index.html <span class="built_in">break</span>;</span><br><span class="line">     location /<span class="built_in">test</span> &#123;</span><br><span class="line">         rewrite /test2 /test3 <span class="built_in">break</span>;</span><br><span class="line">         rewrite /<span class="built_in">test</span> /test2 last;</span><br><span class="line">         rewrite /test2 /test3 <span class="built_in">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     location /test2 &#123;</span><br><span class="line">         <span class="built_in">return</span> 508;</span><br><span class="line">     &#125;</span><br><span class="line">     location /test3 &#123;</span><br><span class="line">         <span class="built_in">return</span> 503;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     location / &#123;</span><br><span class="line">         root   html;</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>请求/test2,返回404,将rewrite /tt的位置调整后,请求test2的返回结果还是404，说明：<br>server域里的last，会终止server的rewrite，进入location匹配（而不是从server头发起请求）。<br>所以，<strong>server域里的break和last的作用没有区别</strong>，都是终止rewrite进入location匹配.<br>总结：<br>1.server中的break终止rewrite进入location匹配<br>2.location中的break，终止当前请求的匹配工作，进入执行阶段</p><h2 id="location中rewrite的作用"><a href="#location中rewrite的作用" class="headerlink" title="location中rewrite的作用"></a>location中rewrite的作用</h2><p>补充一个nginx配置的问题，之前在nginx中加了如下配置，配置一些url的日志不打印</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ ^/+receiver.php$</span> &#123;</span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php(.*)$</span> &#123;</span><br><span class="line">  <span class="attribute">fastcgi_pass</span>    unix:/home/app/php/var/php-cgi.sock;</span><br><span class="line">  <span class="attribute">fastcgi_split_path_info</span>           <span class="regexp"> ^(.+\.php)(.*)$</span>;</span><br><span class="line">  <span class="attribute">fastcgi_param</span>   SCRIPT_FILENAME    <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">  <span class="attribute">fastcgi_param</span>   PATH_INFO    <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">  <span class="attribute">include</span>         fastcgi_params;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，发现所有的<code>/receiver.php</code>请求都直接返回了，没有经过php处理<br>location阶段如果没有进行break的话，不是应该进入到下一个location么？如下的配置,当请求/test时，返回的是509。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /test2 &#123;</span><br><span class="line">    return 509;</span><br><span class="line">&#125;</span><br><span class="line">location /test &#123;</span><br><span class="line">    rewrite /test /test1;</span><br><span class="line">    rewrite /test1 /test2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此看来，rewrite指令也会影响location阶段的后续处理，整理了下location中rewrite指令最后一个参数几种情况分别进行实验。</p><h3 id="有rewrite"><a href="#有rewrite" class="headerlink" title="有rewrite"></a>有rewrite</h3><h4 id="1-break"><a href="#1-break" class="headerlink" title="1.break"></a>1.break</h4><p>终止rewrite，进入请求处理阶段</p><h4 id="2-last"><a href="#2-last" class="headerlink" title="2.last"></a>2.last</h4><p>终止rewrite，重新开始匹配location</p><h4 id="3-redirect-perminate"><a href="#3-redirect-perminate" class="headerlink" title="3.redirect , perminate"></a>3.redirect , perminate</h4><p>301和302</p><h4 id="4-default-rewrite后不带指令"><a href="#4-default-rewrite后不带指令" class="headerlink" title="4.default(rewrite后不带指令)"></a>4.default(rewrite后不带指令)</h4><p>继续执行下一条rewrite指令，如果该条指令为最后一条，则执行处理请求的指令（如fastcgi_pass，proxy_pass），没有则继续匹配其他location。</p><h3 id="无rewrite"><a href="#无rewrite" class="headerlink" title="无rewrite"></a>无rewrite</h3><p>直接进入请求处理阶段</p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2017/03/17/nginx-rewrite-break/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>