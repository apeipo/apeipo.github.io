<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>apeipo的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://longlog.me/"/>
  <updated>2019-08-29T09:05:05.961Z</updated>
  <id>http://longlog.me/</id>
  
  <author>
    <name>apeipo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go-Module实践</title>
    <link href="http://longlog.me/2019/01/02/2018-10-18-go-modules/"/>
    <id>http://longlog.me/2019/01/02/2018-10-18-go-modules/</id>
    <published>2019-01-02T04:00:14.000Z</published>
    <updated>2019-08-29T09:05:05.961Z</updated>
    
    <content type="html"><![CDATA[<p>go1.11版本的一大变化是新增了go-module支持，简化go项目的依赖管理。目前go-module的资料较少，只能通过<code>go help mod</code> 和 <code>go help modules</code>看一些简单的介绍。</p><p>本篇文章通过创建和发布一个lib并在项目中使用它来实践go-modules的版本管理有什么不同</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="go环境准备"><a href="#go环境准备" class="headerlink" title="go环境准备"></a>go环境准备</h3><ol><li>go-module要求go使用<strong>1.11</strong>以上版本，</li><li>执行<code>export GO111MODULE=on</code>开启go-module模式</li></ol><h3 id="lib环境"><a href="#lib环境" class="headerlink" title="lib环境"></a>lib环境</h3><p>先简单看下要发布的lib代码，比较简单，获取任意map类型的key并以数组（用interface包装）的形式返回<br>git仓库为：<code>github.com/apeipo/go-mapkeys</code><br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> maputil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// return map keys as interface</span></span><br><span class="line"><span class="comment">// panic if m is not map type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapKeys</span><span class="params">(m <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">mtyp := reflect.TypeOf(m)</span><br><span class="line"><span class="keyword">if</span> mtyp.Kind() != reflect.Map &#123;</span><br><span class="line">   <span class="built_in">panic</span>(<span class="string">"not a map type"</span>)</span><br><span class="line">&#125;</span><br><span class="line">v := reflect.ValueOf(m)</span><br><span class="line">keys := v.MapKeys() <span class="comment">// panic if not map type</span></span><br><span class="line">rkeys := reflect.MakeSlice(reflect.SliceOf(mtyp.Key()), <span class="number">0</span>, v.Len())</span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">rkeys = reflect.Append(rkeys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rkeys.Interface()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="创建go-module"><a href="#创建go-module" class="headerlink" title="创建go-module"></a>创建go-module</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">git clone github.com/apeipo/<span class="keyword">go</span>-mapkeys</span><br><span class="line">cd <span class="keyword">go</span>-mapkeys</span><br><span class="line"><span class="keyword">go</span> mod init github.com/apeipo/<span class="keyword">go</span>-mapkeys</span><br></pre></td></tr></table></figure><p>执行以上代码就完成了一个go-module的初始化，会在目录下创建<code>go.mod</code>文件。文件内容如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">module github.com/apeipo/go-mapkeys</span><br></pre></td></tr></table></figure><p>注意：<strong>go-mapkeys不能放在GOPATH路径下</strong>，否则会报错。这一点官方的说法是<strong>未来GOPATH可能会取消</strong>，不希望Go的开发者总是理解不了为什么模块需要放到GOPATH下。</p><p>如果提示<code>go: modules disabled inside GOPATH/src by GO111MODULE=auto</code>，则执行<code>export GO111MODULE=on</code>，因为在auto模式下不会自动生成go.mod文件。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>创建好module后，需要给module加上版本以便其他模块使用。<br>go-module的版本遵循语义化版本标准<a href="https://semver.org/" target="_blank" rel="noopener">semver</a>，并且通过github的tag对版本进行控制，给mapkeys模块创建一个版本：<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag v1.0.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p></p><p>至此，一个简单的go-module已经创建并且发布了版本<code>1.0.0</code>，接下来看看怎么在其他模块中使用</p><h2 id="使用go-module"><a href="#使用go-module" class="headerlink" title="使用go-module"></a>使用go-module</h2><p>先找个目录创建一段测试代码（同样的，<strong>该目录也不能在GOPATH路径下</strong>）<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/apeipo/go-mapkeys"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"A"</span> : <span class="number">20</span>,</span><br><span class="line"><span class="string">"B"</span> : <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line">keys := maputil.MapKeys(m)</span><br><span class="line">fmt.Println(keys)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>创建代码后执行：<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init testmod</span><br><span class="line"><span class="keyword">go</span> build</span><br><span class="line"><span class="comment">//find github.com/apeipo/go-mapkeysa</span></span><br><span class="line"><span class="comment">//download github.com/apeipo/go-mapkeys</span></span><br></pre></td></tr></table></figure><p></p><p>执行过程go会自动扫描代码的仓库依赖并拉取依赖的module，执行完成后go.mod文件中会更新相关的依赖及版本<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go.mod</span></span><br><span class="line">module test</span><br><span class="line">require (</span><br><span class="line">github.com/apeipo/<span class="keyword">go</span>-mapkeys v1<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>同时，目录下回生成一个go.sum文件，文件中记录了依赖包的hash，保证所下载版本的正确性<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//go.sum</span><br><span class="line">github.com/apeipo/go-mapkeys v1.0.0 h1:bPfcNKs0sKWi/cZRkhjv6eNmIeRuymjIBM98ihvlzPc=</span><br><span class="line">github.com/apeipo/go-mapkeys v1.0.0/go.mod h1:bPDRb2IUmwPjag8rByI+zdL3d4/+RkIPggHCioYUhdA=</span><br></pre></td></tr></table></figure><p></p><h2 id="module更新"><a href="#module更新" class="headerlink" title="module更新"></a>module更新</h2><p>完成go-module的创建和使用后，接下来再来看下go-module的更新。</p><h3 id="小版本-Patch-Minor-更新"><a href="#小版本-Patch-Minor-更新" class="headerlink" title="小版本(Patch/Minor)更新"></a>小版本(Patch/Minor)更新</h3><p>第一个版本的改动很小，由于<code>reflect.MapKeys</code>调用中已经有了map类型的校验，因此<code>MapKeys</code>方法就不需要再多校验一次。我们将代码中的类型校验去掉，并发布版本1.0.1<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return map keys as interface</span></span><br><span class="line"><span class="comment">// panic if m is not map type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapKeys</span><span class="params">(m <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">mtyp := reflect.TypeOf(m)</span><br><span class="line">v := reflect.ValueOf(m)</span><br><span class="line">keys := v.MapKeys() <span class="comment">// panic if not map type</span></span><br><span class="line">rkeys := reflect.MakeSlice(reflect.SliceOf(mtyp.Key()), <span class="number">0</span>, v.Len())</span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">rkeys = reflect.Append(rkeys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rkeys.Interface()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>发布版本<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cd <span class="keyword">go</span>-mapkeys</span><br><span class="line">git commit -m <span class="string">"remove type check"</span> -a</span><br><span class="line">git tag v1<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p></p><h4 id="使用方更新"><a href="#使用方更新" class="headerlink" title="使用方更新"></a>使用方更新</h4><p>使用方可以通过以下三种方式进行依赖的小版本更新，假设初始版本位<code>1.0.0</code>，三种方式的更新策略如下：<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go get -u       //更新为最近的minor或者patch版本，如1.0.0会被更新为1.0.1或者1.1.0（存在的话）</span><br><span class="line">$ go get -u=patch //更新为最近的patch版本，1.0.0会更新为1.0.1但是不会更新为1.1.0</span><br><span class="line">$ go get github.com/apeipo/go-mapkeys@v1.0.1 //指定版本</span><br></pre></td></tr></table></figure><p></p><p>进入testmod目录执行<code>go get/build</code>，会发现go.mod文件中依赖的版本自动更新为了1.0.1</p><h3 id="大版本-Major-更新"><a href="#大版本-Major-更新" class="headerlink" title="大版本(Major)更新"></a>大版本(Major)更新</h3><p>第二个版本我们给mapkeys增加一个接口，由于MapKeys有可能产生panic，因此我们提供了一个安全版本的接口，对panic进行捕获并以错误的形式返回。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map_keys.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeMapKeys</span><span class="params">(m <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(r <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">r = <span class="literal">nil</span></span><br><span class="line">err = fmt.Errorf(<span class="string">"%s"</span>, p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">mtyp := reflect.TypeOf(m)</span><br><span class="line">v := reflect.ValueOf(m)</span><br><span class="line">keys := v.MapKeys() <span class="comment">// panic if not map type</span></span><br><span class="line">rkeys := reflect.MakeSlice(reflect.SliceOf(mtyp.Key()), <span class="number">0</span>, v.Len())</span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">rkeys = reflect.Append(rkeys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rkeys.Interface(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该版本新增了功能，因此我们发布一个2.0版本。<br>先需要修改go.mod文件：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module github.com/apeipo/go-mapkeys/v2</span><br></pre></td></tr></table></figure><p></p><p>git发布2.0版本，此步骤与之前相同<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cd <span class="keyword">go</span>-mapkeys</span><br><span class="line">git commit -m <span class="string">"add safe mapkeys"</span> -a</span><br><span class="line">git tag v2<span class="number">.0</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p></p><h4 id="使用方更新-1"><a href="#使用方更新-1" class="headerlink" title="*使用方更新"></a>*使用方更新</h4><p><code>go get/build</code>只能更新依赖的patch和minor版本，不能更新major版本。这里涉及到go-module与其他依赖管理不同的地方，因为根据语义化版本的规范，major版本可以不向前兼容，所以<code>go-module认为同一个库的不同大版本是两个完全独立的模块</code>。<br>我们先在测试代码中引入v2版本（<code>github.com/apeipo/go-mapkeys/v2</code>不影响代码中的使用名称）：<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/apeipo/go-mapkeys/v2"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"A"</span> : <span class="number">20</span>,</span><br><span class="line"><span class="string">"B"</span> : <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line">keys := maputil.MapKeys(m)</span><br><span class="line">fmt.Println(keys)</span><br><span class="line">keys, err := maputil.SafeMapKeys(<span class="string">""</span>)</span><br><span class="line">fmt.Println(keys, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>再执行<code>go get</code>更新依赖，会发现go.mod文件中同时require了两个版本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//go.mod</span><br><span class="line">module <span class="built_in">test</span></span><br><span class="line">require (</span><br><span class="line">github.com/apeipo/go-mapkeys v1.1.0</span><br><span class="line">github.com/apeipo/go-mapkeys/v2 v2.0.1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>由于go-module中v1和v2是两个完全独立的模块，因此我们可以在代码中同时引入同一个依赖的不同版本：<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/apeipo/go-mapkeys"</span></span><br><span class="line">maputilv2 <span class="string">"github.com/apeipo/go-mapkeys/v2"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"A"</span> : <span class="number">20</span>,</span><br><span class="line"><span class="string">"B"</span> : <span class="number">30</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//use v1.0</span></span><br><span class="line">keys := maputil.MapKeys(m)</span><br><span class="line">fmt.Println(keys)</span><br><span class="line">   <span class="comment">//use v2.0</span></span><br><span class="line">keys, err := maputilv2.SafeMapKeys(<span class="string">""</span>)</span><br><span class="line">fmt.Println(keys, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="下载路径"><a href="#下载路径" class="headerlink" title="下载路径"></a>下载路径</h3><p>模块使用<code>gomod</code>初始化后，执行<code>go get</code>时，依赖会被保存到<code>$GOPATH/pkg/mod/$gitpath</code>路径下，同时以版本号的形式区分。如<code>mapkeys</code>这个模块的下载路径时<a href="mailto:`$GOPATH/pkg/mod/github.com/apeipo/go-mapkeys@v1.1.0" target="_blank" rel="noopener">`$GOPATH/pkg/mod/github.com/apeipo/go-mapkeys@v1.1.0</a>`</p><h3 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h3><p>go-mod默认不使用<code>vendor</code>目录，依赖不保存在<code>vendor</code>目录下，在执行build时会忽略<code>vendor</code>目录。</p><p>如果要从<code>vendor</code>中加载依赖（一些不联通外部网络的环境下回用到），先要使用<code>go mod vendor</code>命令将依赖的源码全部拷贝到vendor目录下。再使用<code>go build -mod vendor</code>进行编译</p><h3 id="项目迁移"><a href="#项目迁移" class="headerlink" title="项目迁移"></a>项目迁移</h3><p>执行<code>go mod init modulename</code>后执行<code>go get</code>，后面的事情交给go就行，会自动扫描和下载依赖。<br>实际测试发现，如果原来的项目是glide，go-mod会直接从<code>glide.yml</code>中解析依赖生成go.mod文件。</p><h3 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h3><p><code>golang.org</code>下的库无法直接访问，可以再<code>go.mod</code>文件中使用replace进行路径替换<br></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">replace (</span><br><span class="line">golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是，replace只对go.mod所在模块生效。例如A模块依赖B模块，B模块中使用了replace，对A模块的下载时不生效的。</p><h4 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h4><p>也可以使用GOPROXY，具体的proxy地址可以网上搜刮<br><code>export GOPROXY=http://goproxy.xxxx.com</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>go-mod的使用极其简单，不管是对于服务提供者还是调用方来说，基本上<code>go mod init</code>+<code>go get</code>就搞定了一切。</li><li>和其他依赖管理最大的区别在于不同Major版本认为是不同的模块。（这一点上不知道实践中反响如何，从上面的实践来看，major版本无法直接升级，需要修改代码中的import路径）</li><li>当前相关的工具链和文档还不够完善，因为使用了版本相关的路径，大部分IDE中还无法识别gomod导入的模块。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://roberto.selbach.ca/intro-to-go-modules/" target="_blank" rel="noopener">Introduction to Go Modules</a></li><li><a href="https://colobu.com/2018/08/27/learn-go-module/" target="_blank" rel="noopener">跳出go-module的泥潭</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go1.11版本的一大变化是新增了go-module支持，简化go项目的依赖管理。目前go-module的资料较少，只能通过&lt;code&gt;go help mod&lt;/code&gt; 和 &lt;code&gt;go help modules&lt;/code&gt;看一些简单的介绍。&lt;/p&gt;&lt;p&gt;本篇文章
      
    
    </summary>
    
      <category term="后端" scheme="http://longlog.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Golang" scheme="http://longlog.me/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang内存模型</title>
    <link href="http://longlog.me/2018/09/12/2018-09-12-golang-mem/"/>
    <id>http://longlog.me/2018/09/12/2018-09-12-golang-mem/</id>
    <published>2018-09-12T04:12:14.000Z</published>
    <updated>2019-08-29T07:09:16.074Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://hugozhu.myalert.info/2013/04/20/31-golang-memory-model.html" target="_blank" rel="noopener">参考链接-Go语言内存模型</a><br>本文章主要是结合个人理解对官方文章<a href="https://golang.org/ref/mem" target="_blank" rel="noopener">The Go Memory Model</a>的翻译</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>内存模型的定义：<br><a href="https://mp.weixin.qq.com/s/ME_rVwhstQ7FGLPVcfpugQ" target="_blank" rel="noopener">参考链接-内存模型和Java内存模型</a><br><a href="http://www.infoq.com/cn/articles/cache-coherency-prime" target="_blank" rel="noopener">参考链接-CPU缓存一致性入门</a><br>简单来说，内存模型定义了并发环境下操作变量的规范，以保证共享数据的可见性、原子性。<br>不同的语言有各自的内存模型，如Java通过volite、sync等一些列关键字来保证。<br>Golang的内存模型规定了保证变量在不同gorotune之间可见性（一个G中对变量地更改能被其他读取该变量的G观测到）的条件。</p><h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h2><p>在单个gorotune中，读写和代码中的顺序一致，即编译器和CPU对程序的优化必须以不改变语言规范定义的行为为前提。如下代码，在编译执行期间，编译器和CPU都可能优化指令，比如先执行<code>b=2</code>在执行<code>a=1</code>。但是<code>c=a+2</code>一定是在<code>a=1</code>之后执行的。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    c = a + <span class="number">2</span></span><br><span class="line">    log.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>由于指令重排和优化的存在，一个gorotune中对变量的操作顺序和在另一个gorotune中观测到更改的顺序可能是不一样的。如下顺序，可能输出<code>000 122 023（先观测到b的更改）</code><br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        b = <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c = a + <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line">    log.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>happens-before</code>用来描述go程序中局部的内存操作顺序。如果一个内存操作<code>e1 happens-before e2</code>，则<code>e2 happens-after e1</code>。如果<code>e1 not happens-before e2 并且e1 not happens-after e2</code>则e1和e2是并发的（顺序无法判断）。</p><ol><li>在单个gorotune内，happends-before就是程序代码的顺序。</li><li>两个事件之间存在三种关系：<code>happens-before</code> <code>concurrent</code> <code>happens-after</code>，concurrent表示两个事件的顺序是不确定的。（这儿也可以看出来，<code>not happens-before != happens-after</code>，因为还可能有<code>coucurrent</code>）</li><li>happens-before是可推导的，<code>A happens-before B happens-before C =&gt; A happens-before C</code></li></ol><h4 id="1-允许可见"><a href="#1-允许可见" class="headerlink" title="1.允许可见"></a>1.允许可见</h4><p>当满足以下两个条件时，对变量v的读操作<strong>允许</strong>观测到对变量w的写操作（有点绕口，或者说v的写操作对v的读操作是<code>允许</code>可见的）：</p><ol><li>r not happens-before w（<strong>r在w之后或者并发</strong>）</li><li>w和r之间没有其他写操作 (其他w可以和w并发)</li></ol><h4 id="2-保证可见（garuantee）"><a href="#2-保证可见（garuantee）" class="headerlink" title="2.保证可见（garuantee）"></a>2.保证可见（garuantee）</h4><p>如果要保证w对r可见，就需要确保w是r唯一允许可见的写操作。当满足以下两个条件时，对变量v地写操作对读操作是<code>保证</code>可见的：</p><ol><li>w happens-before r</li><li>所有其他队v的写操作，只happens-before w或 happens-afer r</li></ol><p><strong>2.保证可见的要求比1.允许可见严格，它要求没有其他的写和wr并发</strong>。<br>在单个gorotune中，由于没有并发，1和2是等价的：对一个变量地读能读到最近一次对变量地写。<br>在多个gororune并发时，如果想让写对某个期望的读可见（读到期望的值），则必须使用同步事件来确定读写的顺序。</p><blockquote><p>从本质上来讲，happens-before规则确定了CPU缓冲和主存的同步时间点（通过内存屏障等指令），从而使得对变量的读写顺序可被确定–也就是我们通常说的“同步”</p></blockquote><p>go中可以通过锁和channel通讯来进行同步，同时有以下一系列happens-before规则可以用来确定事件的顺序。</p><h2 id="同步规则"><a href="#同步规则" class="headerlink" title="同步规则"></a>同步规则</h2><h3 id="包初始化"><a href="#包初始化" class="headerlink" title="包初始化"></a>包初始化</h3><ol><li>如果package-p引用了package-q，则q的init方法happens-before p的任意方法执行</li><li>main.main方法开始执行 happens-after 所有init方法执行完成。</li></ol><h3 id="Gorotune创建"><a href="#Gorotune创建" class="headerlink" title="Gorotune创建"></a>Gorotune创建</h3><p>gorotune创建语句happens-before 该gorotune的执行语句开始执行<br>如下代码，可以保证能输出<code>hello</code>，因为语句<code>@1 happens-before @2</code> <code>@2 happens-before @3</code>可以推导出<code>@1 happens-before @3</code>.<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(a)           <span class="comment">//@3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span>   <span class="comment">//@1</span></span><br><span class="line"><span class="keyword">go</span> f()               <span class="comment">//@2</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Gorotune销毁"><a href="#Gorotune销毁" class="headerlink" title="Gorotune销毁"></a>Gorotune销毁</h3><p>gorotune的退出不保证happens-before任意事件。如下代码，@1和@2之间没有同步事件，不能保证@1 happens-before @2，因此输出是不确定的，可能是空也可能是hello。<br>在极端情况下，编译器可能优化删除整个gorotune声明。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">        a = <span class="string">"hello"</span>  <span class="comment">//@1</span></span><br><span class="line">    &#125;()  </span><br><span class="line">    <span class="built_in">print</span>(a) <span class="comment">//@2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Channel通讯"><a href="#Channel通讯" class="headerlink" title="Channel通讯"></a>Channel通讯</h3><p>channel通讯是go中的主要同步方法，每个channel的发送操作都会有一个与之匹配的receive操作，receive大多数都是在其他gorotune中，因此定义了以下规则来确定happens顺序：</p><ul><li>channel发送操作happens-before对应的receive操作完成</li></ul><p>根据该规则，如下代码能保证输出helloworld.(@2 happens-before @3 happens-before @1==@4)<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span> <span class="comment">//@2</span></span><br><span class="line">c &lt;- <span class="number">0</span>            <span class="comment">//@3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">&lt;-c               <span class="comment">//@1</span></span><br><span class="line"><span class="built_in">print</span>(a)          <span class="comment">//@4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>channel的关闭操作happens-before接受操作接收到最后的0值</li></ul><p>根据该规则，同样是上面代码，将@3语句修改为<code>close(c)</code>同样能保证输出hello-world</p><ul><li>无缓冲channel的receive happens-before对应的send操作完成</li></ul><p>根据该规则，如果上面代码中将c修改为无缓冲的channel，则需要调换@3和@1语句才能保证输出hello-world<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span> <span class="comment">//@2</span></span><br><span class="line">&lt;-c           <span class="comment">//@3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">c&lt;<span class="number">-0</span>               <span class="comment">//@1</span></span><br><span class="line"><span class="built_in">print</span>(a)          <span class="comment">//@4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>对于容量为C的缓冲通道，第n次receive happens-before第n+k次send.</li></ul><p>这条规则保证了任意时刻缓冲通道中的元素不会超过其容量。当C=0时，这条规则等同于无缓冲通道的happens-before规则。<br>这个特性常用于限制并发资源的数量，如下代码，限制同一时刻，最多三个gorotune在运行<code>w()</code><br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(w <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">limit &lt;- <span class="number">1</span></span><br><span class="line">w()</span><br><span class="line">&lt;-limit</span><br><span class="line">&#125;(w)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h3><p>sync包提供了两种锁的数据结构<code>sync.Mutex</code>和<code>sync.RWMutex</code>，锁的happens-before规则：</p><ul><li>对于任意锁变量l，定义<code>n&lt;m</code>，第n次l.Unlock() happens-before 第m次l.Lock()</li></ul><p>这个定义看着有点绕，简单点说就是：<code>mutex.Unlock happens-before 下一次（或者多次）Lock</code><br>如下代码，能保证输出hello-world，第一次unlock happens-before 第二次lock<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>For any call to l.RLock on a sync.RWMutex variable l, there is an n such that the l.RLock happens (returns) after call n to l.Unlock and the matching l.RUnlock happens before call n+1 to l.Lock.</li></ul><p>这段描述了读写锁的happens规则，实在找不到好的翻译。读写锁有4个操作<code>Lock,UnLock,RLock,RUnlock</code>，第n次RLock happens-after 第n次UnLock，与该RLock对应的RUnlock happens-before 第n+1次Lock</p><h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>Once.Do实现了单例模式，在并发下，Do调用的函数只会被执行一次。</p><ul><li>对于<code>Once.Do(f)</code>，对于函数f的调用f() happens-before 任意Once.Do返回。</li></ul><h2 id="错误的同步方法"><a href="#错误的同步方法" class="headerlink" title="错误的同步方法"></a>错误的同步方法</h2><p>在并发环境下，如果不关注gorotune之间的同步，会引发很多可见性造成的问题（不稳定）</p><h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><p>如下代码，可能输出2和0，因为在主gorotune中观测到的变量a，b的写顺序是无法保证的。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><p>有时为了保证变量在多个gorotune中只被初始化一次，会用共享变量来做状态检查.<br>如下代码是一个常见的错误，由于可见性的问题，在某个gorotune中，<code>done=true</code>不能保证在<code>a=&quot;hello,world&quot;</code>被读取到，因此这个可能打印空字符串。<br>另外，这个例子中once.Do只保证setup被执行一次，但是无法保证可见性。<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !done &#123;</span><br><span class="line">once.Do(setup)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h3><p>有时我们为了程序等待某个事件结束后退出，会用共享变量来同步处理状态。<br>如下代码，存在两个问题:</p><ol><li>done赋值和a变量赋值的顺序在主gorotune中不保证，因此可能输出空字符串</li><li>done的更改对主gorotune不保证可见（没有同步事件保证），因此程序可能陷入死循环</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h3><p>另外一个例子，问题同case3，即使主程序观测到了g==nil的变化退出循环，也无法保证读取到的msg是hello-world</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := <span class="built_in">new</span>(T)</span><br><span class="line">t.msg = <span class="string">"hello, world"</span></span><br><span class="line">g = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line"><span class="keyword">for</span> g == <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(g.msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上诉这些case，解决的办法都是一样的，在多个gorotune之间加入同步事件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://hugozhu.myalert.info/2013/04/20/31-golang-memory-model.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接-Go语言内存模型&lt;/a&gt;&lt;br&gt;本文章主要是结合
      
    
    </summary>
    
      <category term="后端" scheme="http://longlog.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Golang，内存" scheme="http://longlog.me/tags/Golang%EF%BC%8C%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Golang模拟一致性哈希</title>
    <link href="http://longlog.me/2018/08/06/2018-08-06-dist-hash/"/>
    <id>http://longlog.me/2018/08/06/2018-08-06-dist-hash/</id>
    <published>2018-08-06T08:18:14.000Z</published>
    <updated>2019-08-29T07:09:16.058Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">参考链接- 一致性哈希原理与实践</a><br>关于一致性哈希算法的原理网上很多讲解和实践，这里不再赘述。本文主要是通过代码验证一致性哈希带来的变化以及问题。</p><h2 id="普通哈希"><a href="#普通哈希" class="headerlink" title="普通哈希"></a>普通哈希</h2><p>直接对数据进行哈希计算后取模确定数据存入的节点，如果集群的节点数量发生变更时，几乎需要对所有数据进行重新映射。 普通哈希的优势在于数据的分布比较均匀。<br>程序测试结果如下，增加一个节点的情况下，<strong>需要转移的数据比例达到99%</strong>，几乎所有数据都需要进行节点迁移。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CaculateChange needTransNum:990173  Percentage:0.990173 </span><br><span class="line">CaculateDist Avg:10000.00  Max:10254(102.54) Min:9791(97.91)</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NodesNum = <span class="number">100</span>      <span class="comment">//原始节点数量</span></span><br><span class="line"><span class="keyword">const</span> NewNodesNum = <span class="number">101</span>   <span class="comment">//扩充后的节点数量</span></span><br><span class="line"><span class="keyword">const</span> ItemsNum = <span class="number">1000000</span>  <span class="comment">//数据数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HashTest <span class="keyword">interface</span> &#123;</span><br><span class="line">CaculateDist()    <span class="comment">//计算各个节点的数据数量，可以反馈出数据的均匀成都</span></span><br><span class="line">CaculateChange()  <span class="comment">//计算在增加一个节点的情况下，数据迁移量及占比</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NormalHash <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NormalHash)</span> <span class="title">CaculateDist</span><span class="params">()</span></span> &#123;</span><br><span class="line">nodeStat := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ItemsNum; i++ &#123;</span><br><span class="line">hashi := GetHash(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line"></span><br><span class="line">saveNode := GetByteMode(hashi, NodesNum)  <span class="comment">//普通哈希算法，直接取模得到节点数</span></span><br><span class="line">nodeStat[saveNode] += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avg := ItemsNum * <span class="number">1.0</span> / NodesNum</span><br><span class="line"><span class="keyword">var</span> max <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> min <span class="keyword">int64</span> = math.MaxInt64</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> nodeStat &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; max &#123;</span><br><span class="line">max = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n &lt; min &#123;</span><br><span class="line">min = n</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"CaculateDist Avg:%.2f  Max:%d(%.2f) Min:%d(%.2f)"</span>, avg, max, <span class="keyword">float64</span>(max) / avg * <span class="number">100</span>, min, <span class="keyword">float64</span>(min) / avg * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当增加一个节点时，需要进行迁移的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NormalHash)</span> <span class="title">CaculateChange</span><span class="params">()</span></span> &#123;</span><br><span class="line">needTrans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ItemsNum; i++ &#123;</span><br><span class="line">hashi := GetHash(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line"></span><br><span class="line">saveNode := GetByteMode(hashi, NodesNum)</span><br><span class="line">saveNodeNew := GetByteMode(hashi, NewNodesNum)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (saveNode != saveNodeNew) &#123;</span><br><span class="line">needTrans += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"CaculateChange needTransNum:%d  Percentage:%f \n"</span>, needTrans, <span class="keyword">float64</span>(needTrans) / ItemsNum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>一致性哈希如图，通过将节点进行哈希后映射到环上，数据计算哈希后存储到最近的节点中。优势是节点数量变更时，迁移的数据量大大减少，问题是会带来数据分布不均。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2018-08-06-15335478450167.png" alt=""></p><p>测试结果，<strong>在增加一个节点场景下，数据转移比例只有0.4%</strong>。但是也可以看出来，数据的分布极其不均匀</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ConsistHash:</span><br><span class="line">CaculateChange needTransNum:4057  Percentage:0.004057 </span><br><span class="line">CaculateDist Avg:10000.00  Max:39257(392.57) Min:32(0.32)</span><br></pre></td></tr></table></figure><h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConsistHash <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ConsistHash)</span> <span class="title">CaculateDist</span><span class="params">()</span></span> &#123;</span><br><span class="line">nodeStat := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>)</span><br><span class="line">chInstance := ConsistHashInstance&#123;&#125;</span><br><span class="line">chInstance.Init(NodesNum)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ItemsNum; i++ &#123;</span><br><span class="line">node := chInstance.GetItemNode(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line">nodeStat[node]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">avg := ItemsNum * <span class="number">1.0</span> / NodesNum</span><br><span class="line"><span class="keyword">var</span> max <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> min <span class="keyword">int64</span> = math.MaxInt64</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> nodeStat &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; max &#123;</span><br><span class="line">max = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n &lt; min &#123;</span><br><span class="line">min = n</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"CaculateDist Avg:%.2f  Max:%d(%.2f) Min:%d(%.2f)"</span>, avg, max, <span class="keyword">float64</span>(max) / avg * <span class="number">100</span>, min, <span class="keyword">float64</span>(min) / avg * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当增加一个节点时，需要进行迁移的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ConsistHash)</span> <span class="title">CaculateChange</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">chInstance := ConsistHashInstance&#123;&#125;</span><br><span class="line">chInstance.Init(NodesNum)</span><br><span class="line"></span><br><span class="line">chInstance2 := ConsistHashInstance&#123;&#125;</span><br><span class="line">chInstance2.Init(NodesNum + <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line">needTrans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ItemsNum; i++ &#123;</span><br><span class="line">node := chInstance.GetItemNode(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line">nodeNew := chInstance2.GetItemNode(<span class="string">"item:"</span> + strconv.Itoa(i))</span><br><span class="line"><span class="keyword">if</span>(node != nodeNew) &#123;</span><br><span class="line">needTrans++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"CaculateChange needTransNum:%d  Percentage:%f \n"</span>, needTrans, <span class="keyword">float64</span>(needTrans) / ItemsNum)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConsistHashInstance <span class="keyword">struct</span> &#123;</span><br><span class="line">hashToNode <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span></span><br><span class="line">nodeHashs NodeHashArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NodeHashArray []<span class="keyword">string</span></span><br><span class="line"><span class="comment">//实现排序接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p NodeHashArray)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p NodeHashArray)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p NodeHashArray)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p NodeHashArray)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123;sort.Sort(p)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据分配的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ConsistHashInstance)</span> <span class="title">GetItemNode</span><span class="params">(item <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="comment">//计算item-hash</span></span><br><span class="line">hashi := GetHash(item)</span><br><span class="line">hashiStr := hex.EncodeToString(hashi)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取距离hash最近的node, sort.Search返回第一个f(i) == true 的index</span></span><br><span class="line"><span class="comment">//注意此处的i并非实际的节点索引，而是环上的slot索引</span></span><br><span class="line">i := sort.Search(<span class="built_in">len</span>(ci.nodeHashs), <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ci.nodeHashs[idx] &gt;= hashiStr</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="built_in">len</span>(ci.nodeHashs)) &#123;</span><br><span class="line">i = <span class="built_in">len</span>(ci.nodeHashs) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">nodeI := ci.hashToNode[ci.nodeHashs[i]]  <span class="comment">//根据slot中的哈希值找到实际的节点索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(nodeI)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ConsistHashInstance)</span> <span class="title">Init</span><span class="params">(nodeN <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">ci.hashToNode = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>)</span><br><span class="line">ci.nodeHashs = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, nodeN)</span><br><span class="line"></span><br><span class="line">i := nodeN</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; nodeN; i++ &#123;</span><br><span class="line">hashi := GetHash(<span class="string">"node:"</span> + strconv.FormatInt(i, <span class="number">10</span>))</span><br><span class="line">hashiStr := hex.EncodeToString(hashi)</span><br><span class="line"></span><br><span class="line">ci.hashToNode[hashiStr] = <span class="keyword">int64</span>(i)</span><br><span class="line">ci.nodeHashs = <span class="built_in">append</span>(ci.nodeHashs, hashiStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序（将节点映射到环中）</span></span><br><span class="line">ci.nodeHashs.Sort()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>一致性哈希的分布不均本质上是由于节点在环上的分布不均造成的，一种解决办法是增加节点数量，即可以把一个节点映射为多个虚拟节点。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2018-08-06-15335480401709.png" alt=""></p><p>测试结果，同样的节点数量，每个节点建立10个虚拟节点，测试结果如下，可以看出数据比普通的一致性哈希更均匀</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ConsistVirtualHash:</span><br><span class="line">CaculateChange needTransNum:13334  Percentage:0.013334 </span><br><span class="line">CaculateDist Avg:10000.00  Max:19887(198.87) Min:3344(33.44)</span><br></pre></td></tr></table></figure><h3 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h3><p>在实现上，和普通的一致性算法相比，区别只在于节点数量增加</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *ConsistVirtualHashInstance)</span> <span class="title">Init</span><span class="params">(nodeN <span class="keyword">int64</span>, virtualNum <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">allVirtualNum := nodeN * virtualNum</span><br><span class="line"></span><br><span class="line">ci.hashToNode = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>)</span><br><span class="line">ci.nodeHashs = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, allVirtualNum)</span><br><span class="line"></span><br><span class="line">i := nodeN</span><br><span class="line">j := virtualNum</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; nodeN; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j = <span class="number">0</span>; j &lt; virtualNum; j++ &#123;</span><br><span class="line">nodehash := GetHash(<span class="string">"node:"</span> + strconv.FormatInt(i, <span class="number">10</span>) + strconv.FormatInt(j, <span class="number">10</span>))</span><br><span class="line">hashiStr := hex.EncodeToString(nodehash)</span><br><span class="line"></span><br><span class="line">ci.hashToNode[hashiStr] = <span class="keyword">int64</span>(i) <span class="comment">//记录虚拟节点对应的实际节点</span></span><br><span class="line">ci.nodeHashs = <span class="built_in">append</span>(ci.nodeHashs, hashiStr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序（将节点映射到环中）</span></span><br><span class="line">ci.nodeHashs.Sort()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附-测试主程序"><a href="#附-测试主程序" class="headerlink" title="附-测试主程序"></a>附-测试主程序</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"NormalHash:"</span>)</span><br><span class="line">normal := dist_hash.NormalHash&#123;&#125;</span><br><span class="line">normal.CaculateChange()</span><br><span class="line">normal.CaculateDist()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"\n\nConsistHash:"</span>)</span><br><span class="line">consist := dist_hash.ConsistHash&#123;&#125;</span><br><span class="line">consist.CaculateChange()</span><br><span class="line">consist.CaculateDist()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"\n\nConsistVirtualHash:"</span>)</span><br><span class="line">consistV := dist_hash.ConsistVirtualHash&#123;&#125;</span><br><span class="line">consistV.CaculateChange()</span><br><span class="line">consistV.CaculateDist()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4
      
    
    </summary>
    
      <category term="架构" scheme="http://longlog.me/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Golang" scheme="http://longlog.me/tags/Golang/"/>
    
      <category term="分布式" scheme="http://longlog.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MY-2018</title>
    <link href="http://longlog.me/2018/08/06/2018-Target/"/>
    <id>http://longlog.me/2018/08/06/2018-Target/</id>
    <published>2018-08-06T02:30:42.000Z</published>
    <updated>2019-08-29T07:09:16.060Z</updated>
    
    <content type="html"><![CDATA[<p>个人2018年的学习规划。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;个人2018年的学习规划。&lt;/p&gt;
      
    
    </summary>
    
      <category term="NOTE" scheme="http://longlog.me/categories/NOTE/"/>
    
    
      <category term="NOTE" scheme="http://longlog.me/tags/NOTE/"/>
    
  </entry>
  
  <entry>
    <title>Python中实现PHP的魔术方法call和callStatic</title>
    <link href="http://longlog.me/2017/07/24/python-call-callStatic/"/>
    <id>http://longlog.me/2017/07/24/python-call-callStatic/</id>
    <published>2017-07-24T04:41:22.000Z</published>
    <updated>2019-08-29T07:09:16.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="call和callStatic"><a href="#call和callStatic" class="headerlink" title="call和callStatic"></a>call和callStatic</h2><p>有PHP开发经验的同学应该对call和callStatic不陌生，<br><strong>__call</strong>方法： 当调用类的方法时，方法不存在或权限不足，会自动调用<code>__call</code> 方法。<br><strong>__callStatic</strong>方法： 当调用类的静态方法时，方法不存在或权限不足，会自动调用<code>__callStatic</code>方法。<br>如下一个简单的例子，基于<code>__callStatic</code>实现一个Redis的简单代理，可以在请求redis之前和之后做一些其他的操作，如耗时、日志。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> $redisIns;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//redis初始化</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static</span>::$redisIns;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">($func, $args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//在请求执行做一些操作</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//请求具体的redis方法</span></span><br><span class="line">$res = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">static</span>::$redisIns) &#123;</span><br><span class="line">$res =  <span class="keyword">static</span>::$redisIns-&gt;$func(...$args)</span><br><span class="line"><span class="comment">//return call_user_func_array([static::$redisIns, $func], $args)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求完成后执行一些操作</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> $res</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Python中实现call"><a href="#在Python中实现call" class="headerlink" title="在Python中实现call"></a>在Python中实现call</h2><p>Python中当访问不存在的属性或者方法时，会调用类的<code>__getattr__</code>方法，基于这个方法我们可以实现类似<code>__call</code>的功能。（注意：Python中的类有一个<code>__call__</code>方法，不过该方法是在类被作为方法执行是调用的。）<br>如下代码，当访问hello这个不存在的属性时，会调用<code>MagicCall</code>这个类的<code>__getattr__</code>方法。注意：<code>__getattr__</code>方法<strong>只负责返回属性，而不负责执行方法</strong>，执行方法是在<code>ins.hello(&#39;xx&#39;, &#39;pp&#39;)</code>这一行执行<code>__getattr__</code>的返回结果，因此，<code>__getattr__</code>中需要返回一个闭包。<br>这里没有直接把<code>callMethod</code>方法直接返回，而是再套了一层，是为了<strong>保留调用的method_name</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicCall</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, method_name)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            self._callMethod(method_name, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callMethod</span><span class="params">(self, method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MagicCall)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callMethod</span><span class="params">(self, method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        print(method_name, args, kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    ins = MyClass()</span><br><span class="line">    ins.hello(<span class="string">'xx'</span>, <span class="string">'pp'</span>)</span><br></pre></td></tr></table></figure><p>当然，这种实现有个问题：<strong>如果没有调用不存在的方法，而是访问不存在的属性，会获取到一个闭包</strong>.. 这个问题要解决的话会比较复杂(可能得根据当前的执行栈进行判断)，这篇文章里不讨论这个。</p><h2 id="实现callStatic"><a href="#实现callStatic" class="headerlink" title="实现callStatic"></a>实现callStatic</h2><p>上一章的实现，当调用类实例不存在的方法时，会正确重定向到<code>callMethod</code>。<br>但是，如果是静态方法调用，比如调用一个不存在的静态方法<code>MyClass::hello(&quot;hehe&quot;)</code>时，就没法调用到<code>callMethod</code>方法了。因为，本质上来说，当调用<code>MyClass::hello()</code>时，访问的并不是<code>MyClass</code>的实例(上文代码中的ins才是MyClass的一个实例)。</p><p>那<code>MyClass</code>这个类是谁的实例？答案是它的<strong>元类</strong>，即type。当我们用class定义一个类时，实际上是用type创建了一个’类’并实例化了它。<br>关于元类的分析网上文章有很多，这里不在赘述，我们可以通过类的<code>__metaclass__</code>属性修改类的元类。</p><p>改进后的代码如下，修改了<code>MagicCall</code>的元类为<code>MagicMeta</code>，当调用<code>MyClass.hello()</code>时，因为<code>MyClass</code>这个类是<code>MagicMeta</code>的一个实例，所以会执行<code>MagicMeta</code>的<code>__getattr__</code>方法。</p><p>在<code>MagicMeta-&gt;__getattr__</code>中，self指向的是<code>MyClass</code>（self指向类的实例，MyClass是MagicMeta的实例），所以可以根据<code>self</code>调用到<code>MyClass</code>的<code>callStaticMethod</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    调用MagicCall不存在的方法时，会调用其元类的getattr方法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, method_name)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            getattr(self, <span class="string">'_callStaticMethod'</span>)(method_name, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicCall</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"重定义类的元类"</span></span><br><span class="line">    __metaclass__ = MagicMeta</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, method_name)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            self._callMethod(method_name, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callStaticMethod</span><span class="params">(method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        调用不存在的静态方法时执行的函数</span></span><br><span class="line"><span class="string">        :param method_name: 方法名</span></span><br><span class="line"><span class="string">        :param args:   方法参数</span></span><br><span class="line"><span class="string">        :param kwargs: 方法参数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callMethod</span><span class="params">(self, method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        调用不存在的方法时执行的函数</span></span><br><span class="line"><span class="string">        :param method_name: 方法名</span></span><br><span class="line"><span class="string">        :param args:   方法参数</span></span><br><span class="line"><span class="string">        :param kwargs: 方法参数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(MagicCall)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callStaticMethod</span><span class="params">(method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        print(method_name, args, kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_callMethod</span><span class="params">(self, method_name, *args, **kwargs)</span>:</span></span><br><span class="line">        print(method_name, args, kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    ins = MyClass()</span><br><span class="line">    ins.hello(<span class="string">'xx'</span>, <span class="string">'pp'</span>)</span><br><span class="line">    MyClass.hello(<span class="string">'xxx'</span>, <span class="string">'ppp'</span>, xname=<span class="string">'linxianlong'</span>)</span><br><span class="line">    MethodProxy.hello()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;call和callStatic&quot;&gt;&lt;a href=&quot;#call和callStatic&quot; class=&quot;headerlink&quot; title=&quot;call和callStatic&quot;&gt;&lt;/a&gt;call和callStatic&lt;/h2&gt;&lt;p&gt;有PHP开发经验的同学应该对call
      
    
    </summary>
    
      <category term="后端" scheme="http://longlog.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="PHP" scheme="http://longlog.me/tags/PHP/"/>
    
      <category term="Python" scheme="http://longlog.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Lumen和Laravel错误处理机制修改</title>
    <link href="http://longlog.me/2017/07/12/lumen-error-handler/"/>
    <id>http://longlog.me/2017/07/12/lumen-error-handler/</id>
    <published>2017-07-12T13:50:42.000Z</published>
    <updated>2019-08-29T07:09:16.056Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Laravel或者Lumen时会碰到这种情况，如果php的代码中产生了Notice或者Warning，会导致Lumen跳到错误页，日志中会打印一个很长很长的stack trace，如下图：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$app-&gt;get(<span class="string">'/test'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($app)</span> </span>&#123;</span><br><span class="line">$arr = [];</span><br><span class="line"><span class="keyword">print</span>($arr[<span class="string">'name'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">#请求/test 产生的日志</span></span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">55</span>:<span class="number">54</span>] lumen.ERROR: ErrorException: Undefined index: name in /home/vagrant/Code/featurestream/routes/web.php:<span class="number">16</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 /home/vagrant/Code/featurestream/routes/web.php(16): Laravel\Lumen\Application-&gt;Laravel\Lumen\Concerns\&#123;closure&#125;(8, 'Undefined index...', '/home/vagrant/C...', 16, Array)</span></span><br><span class="line"><span class="comment">#1 [internal function]: Closure-&gt;&#123;closure&#125;()</span></span><br><span class="line"><span class="comment">#2 /home/vagrant/Code/featurestream/vendor/illuminate/container/BoundMethod.php(29): call_user_func_array(Object(Closure), Array)</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>上面的日志只截取了一小部分，实际运行时最简单的api请求Lumen的stack trace会有30层左右，Laravel的会有60层..<br>另外一个重要的问题是，这种处理机制会让一些小错误把整个请求搞挂，代码中到处加<code>if(isset($arr[&#39;xx&#39;]))</code> 或者设置默认值。<br>对于这个问题，Laravel和Lumen设计的初衷是好的：<strong>所有的PHP错误都应该被处理，包括Notice和Warning</strong>。就是太严格了，有时候我们并不需要代码有这么严格的检查，出现Notice或者Warning时，只需要打印个模块日志或者有PHP日志就行。<br>先看下Lumen中的错误是如何处理的（Laravel中也差不多，不再单独讲）。</p><h2 id="错误处理流程"><a href="#错误处理流程" class="headerlink" title="错误处理流程"></a>错误处理流程</h2><h3 id="错误Handler"><a href="#错误Handler" class="headerlink" title="错误Handler"></a>错误Handler</h3><p>先看Lumen的入口：<code>bootstrap/app.php</code>，有一段错误处理相关的代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$app-&gt;singleton(</span><br><span class="line">    Illuminate\Contracts\Debug\ExceptionHandler::class,</span><br><span class="line">    App\Exceptions\Handler::class</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>singleton是往app（Lumen的服务容器）里注入实例的方法，这里实例化了一个ExceptionHandler类，实例为Handler。后面的代码如果有从$app里取ExceptionHandler的实例的话，会返回Handler这个类的实例。<br>Handler类在App\Exceptions目录下，代码如下。比较简单，只包含两个方法，再去看父类(<code>Laravel\Lumen\Exceptions\Handler</code>)的方法逻辑会发现，<strong>report方法负责打印日志（也就是上文那个长长的trace），render方法会根据错误类型的不同构建错误页面</strong>。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">report</span><span class="params">(Exception $e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">parent</span>::report($e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">($request, Exception $e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">parent</span>::render($request, $e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误的处理逻辑找到了，如何触发进入这个逻辑的呢？</p><h3 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h3><p>正常情况下，PHP产生Notice或者Warning是不会抛出Exception的，会产生Exception肯定是框架内部做了更改。<br><code>bootstrap/app.php</code>中没找到设置错误处理的地方，接着往下看Lumen框架的容器类Application（Lumen的核心类和入口），目录：<code>vendor/laravel/lumen-framework/src/Application.php</code>。<br>可以看到在其构造函数中调用了一个registerErrorHandling方法，方法代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the error handling for the application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerErrorHandling</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    error_reporting(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    set_error_handler(<span class="function"><span class="keyword">function</span> <span class="params">($level, $message, $file = <span class="string">''</span>, $line = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error_reporting() &amp; $level) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorException($message, <span class="number">0</span>, $level, $file, $line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    set_exception_handler(<span class="function"><span class="keyword">function</span> <span class="params">($e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;handleUncaughtException($e);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    register_shutdown_function(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;handleShutdown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set_error_handler</code>是PHP设置错误处理的方法。registerErrorHandling下用<code>error_reporting(-1)</code>把PHP的报错开关都打开，这样所有级别的错误都会触发<code>error_handler</code>。在<code>error_handler</code>中抛出了一个ErrorException异常。<br>至此，我们知道ErrorException这个异常是怎么产生的了，知道异常会交由谁来处理了（上一节中的Handler类）。不过还有个疑问，ErrorException和Handler是怎么关联起来的？</p><h3 id="ErrorException和Handler"><a href="#ErrorException和Handler" class="headerlink" title="ErrorException和Handler"></a>ErrorException和Handler</h3><p><code>set_error_handler</code>设置的方法中会抛出异常，那肯定存在针对异常的try catch块。<br>从请求路口<code>public/index.php</code>往下看，<br>–&gt;<code>bootstrap/app.php</code> –&gt;<code>Application.php -&gt; run</code> –&gt;<code>Application.php -&gt; dispatch</code><br>在dispatch方法中发现了try catch的逻辑，在catch到Exception后调用了Handler的report和render方法。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($request = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">list</span>($method, $pathInfo) = <span class="keyword">$this</span>-&gt;parseIncomingRequest($request);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">...</span><br><span class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;prepareResponse(<span class="keyword">$this</span>-&gt;sendExceptionToHandler($e));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;prepareResponse(<span class="keyword">$this</span>-&gt;sendExceptionToHandler($e));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">sendExceptionToHandler</span><span class="params">($e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   $handler = <span class="keyword">$this</span>-&gt;resolveExceptionHandler();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ($e <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">       $e = <span class="keyword">new</span> FatalThrowableError($e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   $handler-&gt;report($e);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> $handler-&gt;render(<span class="keyword">$this</span>-&gt;make(<span class="string">'request'</span>), $e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>知道了错误从触发到结束的整个流程，再来看怎么解决.</p><h3 id="方法1-屏蔽错误"><a href="#方法1-屏蔽错误" class="headerlink" title="方法1.屏蔽错误"></a>方法1.屏蔽错误</h3><p>简单粗暴的方法，既然框架用来<code>error_reporting(-1)</code>打开了所有错误开关，那我们再用<code>error_reporting</code>把我们不关心的错误给屏蔽了。把下面代码加在<code>bootstrap/app.php</code>中，<strong>注意得加在Applition实例化之后</strong>。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">error_reporting(E_ALL ^ E_NOTICE ^ E_WARNING);</span><br></pre></td></tr></table></figure><p>这种方法的弊端显而易见，我们只是不想让E_NOTICE搞挂请求，但是这类错误还是得关注和修复的。。</p><h3 id="方法2-修改Handler"><a href="#方法2-修改Handler" class="headerlink" title="方法2.修改Handler"></a>方法2.修改Handler</h3><p>既然是Handler负责错误处理，那我们修改Handler(<code>App\Exceptions\Handler</code>)的逻辑就行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">report</span><span class="params">(Exception $e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//parent::report($e);</span></span><br><span class="line">    Log::warning($e-&gt;getMessage(), [<span class="string">'file'</span> =&gt; $e-&gt;getFile(), <span class="string">'line'</span> =&gt; $e-&gt;getLine()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">($request, Exception $e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return parent::render($request, $e);</span></span><br><span class="line">    header(<span class="string">'Content-type: application/json'</span>);</span><br><span class="line">    <span class="keyword">echo</span> json_encode([<span class="string">'errmsg'</span> =&gt; $e-&gt;getMessage()]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，将错误处理逻辑进行更改，只打印简单的日志，并且也不跳到错误页了。<br>不过，这种方法还是有问题：</p><ol><li>代码产生的NOTICE和WARNING还是会中断执行流程（因为会抛出异常）。比如一个请求中执行A-&gt;B-&gt;C三个方法，如果B中产生了一个NOTICE，整个请求还是会被中断，C不会被执行。</li><li>如果一个请求原本不是返回json，是返回一个view，则上面的render方法就不适用了。</li></ol><h3 id="方法3-在业务逻辑顶层中catch异常"><a href="#方法3-在业务逻辑顶层中catch异常" class="headerlink" title="方法3.在业务逻辑顶层中catch异常"></a>方法3.在业务逻辑顶层中catch异常</h3><p>原理类似方法2，只不过把异常的处理从Handler中移到了业务逻辑里（比如Controller中）。<br>这个方法的问题和方法2一样，NOTICE还是会中断请求…</p><h3 id="方法4-修改error-handler，不抛出异常"><a href="#方法4-修改error-handler，不抛出异常" class="headerlink" title="方法4.修改error_handler，不抛出异常"></a>方法4.修改<code>error_handler</code>，不抛出异常</h3><p>罪魁祸首就在于那个<code>set_error_handler</code>注册的处理方法遇到PHP错误就会抛出异常，那我们修改他就行。<br><code>set_error_handler</code>所在的registerErrorHandling方法在框架的源代码中，最好不要直接修改，我们可以在它注册完之后再重新注册一个覆盖它。可以加在<code>bootstrap/app.php</code>中，Application实例化之后。代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">set_error_handler(<span class="function"><span class="keyword">function</span> <span class="params">($level, $message, $file = <span class="string">''</span>, $line = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($level == E_NOTICE || $level == E_WARNING) &#123;</span><br><span class="line">        Log::warning(<span class="string">"PHP NOTICE or WARNING; MSG:[$message]"</span>, [<span class="string">'file'</span> =&gt; $file, <span class="string">'line'</span> =&gt; $line]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error_reporting() &amp; $level) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ErrorException($message, <span class="number">0</span>, $level, $file, $line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，<strong>代码中因为使用了Log这个Facades，因此必须放在$app-&gt;withFacades()之后</strong><br>至此，NOTICE和WARNING不会产生烦人的日志，也不会搞挂请求，并且也保留了有效的提示信息。：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Laravel或者Lumen时会碰到这种情况，如果php的代码中产生了Notice或者Warning，会导致Lumen跳到错误页，日志中会打印一个很长很长的stack trace，如下图：&lt;/p&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="PHP" scheme="http://longlog.me/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://longlog.me/tags/PHP/"/>
    
      <category term="LUMEN" scheme="http://longlog.me/tags/LUMEN/"/>
    
      <category term="LARAVEL" scheme="http://longlog.me/tags/LARAVEL/"/>
    
  </entry>
  
  <entry>
    <title>Lumen自定义配置</title>
    <link href="http://longlog.me/2017/07/06/lumen-config/"/>
    <id>http://longlog.me/2017/07/06/lumen-config/</id>
    <published>2017-07-06T15:42:22.000Z</published>
    <updated>2019-08-29T07:09:16.054Z</updated>
    
    <content type="html"><![CDATA[<p>先从一个问题说起，Lumen在使用Redis时，文档中有一段说明：</p><blockquote><p>If you have not called $app-&gt;withEloquent() in your bootstrap/app.php file, then you should call app-&gt;configure(‘database’); in the bootstrap/app.php file to ensure the Redis database configuration is properly loaded.</p></blockquote><p>如果没有调用<code>$app-&gt;withEloquent()</code>的话，需要调用<code>$app-&gt;configure(&#39;database&#39;)</code>来加载redis的配置。为什么需要这么做呢？</p><h3 id="redis使用的配置"><a href="#redis使用的配置" class="headerlink" title="redis使用的配置"></a>redis使用的配置</h3><p>Redis使用的配置比较容易查看，在安装<code>illuminate/redis</code>后查看<code>vendor/illuminate/redis/RedisServiceProvider.php</code>，可以看到该Service使用的配置是<code>database.redis</code><br><strong>注意区分CacheService使用的配置，Cache使用的配置是config/cache.php</strong></p><h3 id="database-php在什么时候加载？"><a href="#database-php在什么时候加载？" class="headerlink" title="database.php在什么时候加载？"></a>database.php在什么时候加载？</h3><p>按照文档的说法，需要调用<code>$app-&gt;withEloquent()</code> 或者 <code>$app-&gt;configure(&#39;database&#39;)</code>。<br>withEloquent做了什么？</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#withEloquent调用了make，创建db模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">withEloquent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;make(<span class="string">'db'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#make是Appliation提供的注册模块实例的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">make</span><span class="params">($abstract)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">#先从this-&gt;alias中获取模块对应的别名</span></span><br><span class="line">$abstract = <span class="keyword">$this</span>-&gt;getAlias($abstract);</span><br><span class="line"><span class="comment">#根据名称在availableBindings中查找对应的注册方法进行初始化</span></span><br><span class="line"><span class="keyword">if</span> (array_key_exists($abstract, <span class="keyword">$this</span>-&gt;availableBindings) &amp;&amp;</span><br><span class="line">  ! array_key_exists(<span class="keyword">$this</span>-&gt;availableBindings[$abstract], <span class="keyword">$this</span>-&gt;ranServiceBinders)) &#123;</span><br><span class="line">  <span class="keyword">$this</span>-&gt;&#123;$method = <span class="keyword">$this</span>-&gt;availableBindings[$abstract]&#125;();</span><br><span class="line">  <span class="keyword">$this</span>-&gt;ranServiceBinders[$method] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">parent</span>::make($abstract);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#availableBindings定义了模块和其对应的初始化方法</span></span><br><span class="line"> <span class="keyword">public</span> $availableBindings = [</span><br><span class="line">...</span><br><span class="line">   <span class="string">'db'</span> =&gt; <span class="string">'registerDatabaseBindings'</span>,</span><br><span class="line">   <span class="string">'config'</span> =&gt; <span class="string">'registerConfigBindings'</span>,</span><br><span class="line">   ...</span><br><span class="line">];</span><br><span class="line"><span class="comment">#registerDatabaseBindings方法中调用loadComponent初始化db模块，并注册到Application中，</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerDatabaseBindings</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;singleton(<span class="string">'db'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;loadComponent(</span><br><span class="line">           <span class="string">'database'</span>, [</span><br><span class="line">               <span class="string">'Illuminate\Database\DatabaseServiceProvider'</span>,</span><br><span class="line">               <span class="string">'Illuminate\Pagination\PaginationServiceProvider'</span>,</span><br><span class="line">           ], <span class="string">'db'</span></span><br><span class="line">       );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#loadComponent会调用configure加载配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">loadComponent</span><span class="params">($config, $providers, $return = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;configure($config);</span><br><span class="line">   <span class="keyword">foreach</span> ((<span class="keyword">array</span>) $providers <span class="keyword">as</span> $provider) &#123;</span><br><span class="line">       <span class="keyword">$this</span>-&gt;register($provider);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;make($return ?: $config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果调用了withEloquent，则database就已经被加载进来，不要再用configure注册了。</p><h2 id="配置加载"><a href="#配置加载" class="headerlink" title="配置加载"></a>配置加载</h2><p>再来看Lumen的配置加载方式</p><h3 id="Laravel的配置加载方式"><a href="#Laravel的配置加载方式" class="headerlink" title="Laravel的配置加载方式"></a>Laravel的配置加载方式</h3><p>比较简单，在boostraps中调用LoadConfiguration，扫描config目录下的所有文件，使用Illuminate\Contracts\Config\Repository（Config实际使用的类）保存配置。<br>如果开启了配置cache，则会加载bootstrap/cache/config.php。</p><h3 id="Lumen的配置加载方式"><a href="#Lumen的配置加载方式" class="headerlink" title="Lumen的配置加载方式"></a>Lumen的配置加载方式</h3><p>从上一节可以看到，Lumen的配置加载是按照模块的需要，最终调用configure方法进行加载。configure方法的调用代码如下。<br>从代码中可以看出来，configure会先从<strong>“项目根目录/config”</strong>目录下加载配置，如果不存在则从<strong>“Application.php所在目录/../config”</strong>加载。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置加载方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">configure</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;loadedConfigurations[$name])) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;loadedConfigurations[$name] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">#获取配置路径</span></span><br><span class="line">   $path = <span class="keyword">$this</span>-&gt;getConfigurationPath($name);</span><br><span class="line">   <span class="keyword">if</span> ($path) &#123;</span><br><span class="line">   <span class="comment">#生成config模块的实例</span></span><br><span class="line">       <span class="keyword">$this</span>-&gt;make(<span class="string">'config'</span>)-&gt;set($name, <span class="keyword">require</span> $path);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#从上一节中的availableBindings数组可以看出，config模块实例初始化方法为registerConfigBindings</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerConfigBindings</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;singleton(<span class="string">'config'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">#Illuminate\Config\Repository as ConfigRepository;</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ConfigRepository;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#配置路径获取方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getConfigurationPath</span><span class="params">($name = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (! $name) &#123;</span><br><span class="line">       $appConfigDir = <span class="keyword">$this</span>-&gt;basePath(<span class="string">'config'</span>).<span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (file_exists($appConfigDir)) &#123;</span><br><span class="line">           <span class="keyword">return</span> $appConfigDir;</span><br><span class="line">       &#125; <span class="keyword">elseif</span> (file_exists($path = <span class="keyword">__DIR__</span>.<span class="string">'/../config/'</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> $path;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       $appConfigPath = <span class="keyword">$this</span>-&gt;basePath(<span class="string">'config'</span>).<span class="string">'/'</span>.$name.<span class="string">'.php'</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (file_exists($appConfigPath)) &#123;</span><br><span class="line">           <span class="keyword">return</span> $appConfigPath;</span><br><span class="line">       &#125; <span class="keyword">elseif</span> (file_exists($path = <span class="keyword">__DIR__</span>.<span class="string">'/../config/'</span>.$name.<span class="string">'.php'</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> $path;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从Lumen的配置加载可以看出来，<strong>Lumen没有像Laravel那样自动加载config下的所有配置文件</strong>（从这里也可以看出，Lumen按需加载的原则）。因此，如果我们需要增加自定义的配置文件，需要在bootstrap/app.php中或者其他地方调用<code>$app-&gt;configure(&#39;xxx.php&#39;)</code></p><p>另外，从configure获取路径的方式也会发现，可以将<code>vendor/laravel/lumen-framework/src/../config</code>文件夹拷贝到项目根目录，以方便配置的修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先从一个问题说起，Lumen在使用Redis时，文档中有一段说明：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;If you have not called $app-&amp;gt;withEloquent() in your bootstrap/app.php file, then y
      
    
    </summary>
    
      <category term="后端" scheme="http://longlog.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="PHP" scheme="http://longlog.me/tags/PHP/"/>
    
      <category term="LUMEN" scheme="http://longlog.me/tags/LUMEN/"/>
    
      <category term="LARAVEL" scheme="http://longlog.me/tags/LARAVEL/"/>
    
  </entry>
  
  <entry>
    <title>Python2和3编码整理</title>
    <link href="http://longlog.me/2017/07/06/python23-codec/"/>
    <id>http://longlog.me/2017/07/06/python23-codec/</id>
    <published>2017-07-06T06:42:22.000Z</published>
    <updated>2019-08-29T07:09:16.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://funhacks.net/explore-python/Basic/character_encoding.html" target="_blank" rel="noopener">Python编码</a><br><a href="http://kuanghy.github.io/2016/10/15/encoding-python2-vs-python3" target="_blank" rel="noopener">Python2 与 Python3 的编码对比</a></p><h2 id="UnicodeEncodeError-amp-UnicodeDecodeError"><a href="#UnicodeEncodeError-amp-UnicodeDecodeError" class="headerlink" title="UnicodeEncodeError&amp; UnicodeDecodeError"></a>UnicodeEncodeError&amp; UnicodeDecodeError</h2><p>用 Python2 编写程序的时候经常会遇到 UnicodeEncodeError 和 UnicodeDecodeError，它们出现的根源就是如果代码里面混合使用了 str 类型和 unicode 类型的字符串，<strong>Python 会默认使用 ascii 编码尝试对 unicode 类型的字符串编码 (encode)，或对 str 类型的字符串解码 (decode)</strong>。<br>例如：<strong>s = u’中文’ + ‘中国’</strong>, python2会隐式地调用 <code>&#39;中国&#39;.decode(&#39;ascii&#39;)</code>，发生decodeError。<br>同样的，如果某些方法要求str类型，而调用时传入了unicode类型，python会使用encode(‘ascii’)对传入值进行转换，如果穿入值存在非ascii字符，就会发送EncodeError</p><h2 id="Python2和3的字符串"><a href="#Python2和3的字符串" class="headerlink" title="Python2和3的字符串"></a>Python2和3的字符串</h2><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><strong>Python2 中字符的类型</strong>：<br>str： 某种编码（UTF-8，GBK等）类型的字节序列<br>unicode： Unicode类型的字符串<br><strong>Python3 中字符的类型</strong>：<br>str： Unicode类型的字符串<br>bytes： 某种编码（UTF-8，GBK等）类型的字节序列</p><p>不管是Python2还是3，我们可以认为字符串有两种状态：</p><ol><li>未编码的状态（unicode字节序列），如中文对应：u’\u4e2d\u6587’</li><li>编码后的状态（按指定编码转换字节序列），如中文按utf-8编码后是’\xe4\xb8\xad\xe6\x96\x87’</li></ol><p>Python2 和 Python3 中的两种字符类型都分别对应这两种状态，然后相互之间进行编解码转化。<br>实际上，Python3中的str可以认为是Python2中的unicode类型，而bytes相当于Python2中的str类型。</p><h3 id="encode和decode"><a href="#encode和decode" class="headerlink" title="encode和decode"></a>encode和decode</h3><p>编码(encode)就是将字符串转换成指定编码的字节码；解码(decode)就是按指定的编码解析字节序列，将比特位显示成字符。<br>Python2和3中两个方法的对比：</p><table><thead><tr><th></th><th>Python2</th><th>Python3</th></tr></thead><tbody><tr><td>encode</td><td>unicode 按指定编码转为 str（即字节码），默认ascii</td><td>str(unicode) 编码为 bytes,默认使用utf-8 <strong>只有str类型有该方法</strong></td></tr><tr><td>decode</td><td>str 按指定编码解码为 unicode，默认ascii)</td><td>bytes 解码为 str ，默认使用utf-8 <strong>只有bytes类型有该方法</strong></td></tr></tbody></table><p>在 Python2 中，str 和 unicode 都有 encode 和 decode 方法。但是不建议对 str 使用 encode(会内部隐式地先decode解码)，对 unicode 使用 decode(会内部隐式地先encode编码), 这是 Python2 设计上的缺陷。<br>Python3 则进行了优化，<strong>str 只有一个 encode 方法将字符串转化为一个字节码，而且 bytes 也只有一个 decode 方法将字节码转化为一个文本字符串</strong>。</p><h3 id="字符串处理的前提"><a href="#字符串处理的前提" class="headerlink" title="字符串处理的前提"></a>字符串处理的前提</h3><p>对于Python文件中字符串的解析，有一些前提：</p><ol><li>Python 文件开始已经声明对应的编码</li><li>Python 文件本身的确是使用该编码保存的</li><li>两者的编码类型要一样（比如都是 UTF-8 或者都是 GBK 等）</li></ol><p><strong>满足这些前提，Python解析器才能正确的把文本解析为对应的unicode</strong>。<br>同样的，在Python2中，如果用u’中文’这种方式定义字符串也得满足上诉前提，否则Python无法将其转为unicode字符（定义普通的str不存在该问题，因为Python2中的str就是字节序列，Python不会转为unicode）。</p><h3 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别"></a>其他区别</h3><ol><li>Python2 的 str 和 unicode 都是 basestring 的子类，所以两者可以直接进行拼接操作。而 Python3 中的 bytes 和 str 是两个独立的类型，两者不能进行拼接。</li><li>Python2 中，普通字符串（如：s = “中文”）的编码类型，对应着你的 Python 文件本身保存为何种编码有关，最常见的 Windows 平台中，默认用的是 GBK。Python3 中，定义的字符串就已经是 Unicode 类型的 str了（Python解释器根据文件编码转换而来）。</li></ol><p>总体来说，Python3的编码表示更直接，字符串总是unicode，二进制制是bytes，不像Python2中将两者混在一起造成处理上的混淆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://funhacks.net/explore-python/Basic/character_e
      
    
    </summary>
    
      <category term="后端" scheme="http://longlog.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Python" scheme="http://longlog.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CSS的box-sizing属性引起的一个问题</title>
    <link href="http://longlog.me/2017/06/26/css-border-box/"/>
    <id>http://longlog.me/2017/06/26/css-border-box/</id>
    <published>2017-06-26T06:42:22.000Z</published>
    <updated>2019-08-29T07:09:16.067Z</updated>
    
    <content type="html"><![CDATA[<p>整理一个box-sizing引起的样式问题。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用腾讯地图的api展示地图时，发现地图的比例尺展示空白了。<br>如图：<img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-26-14984499285621.jpg" alt="-w100">，正常应该是：<img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-26-14984502329840.jpg" alt="-w100"></p><p>Chrome下，元素的盒子模型如下：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-26-14984500426038.jpg" alt="-w200"><br>关键的几个css样式：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-26-14984501217132.jpg" alt="-w200"><br>元素的border-color设置了白色，因此元素实际要展示的颜色应该是由background-color决定的，但是从盒子上可以看出，<strong>元素内容部分(content)的高度为0</strong>，导致元素没有展示实际的黑色。<br>元素的样式设置了height为2px，样式都是在style属性中定义，不存在被覆盖的情况，为什么实际高度是0呢？看着好像高度被border占了？<br>先回顾下CSS的盒子模型。</p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>如下图，盒子模型描述了一个元素在页面中<strong>占用的空间</strong>。注意，<strong>占用空间 != 高度X宽度</strong>。<br><strong>默认情况下，当你指定一个CSS元素的宽度和高度属性时，你只是设置内容区域（下图中的content）的宽度和高度</strong>。一个元素实际占用的空间还需要加上padding、border和margin。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-26-14984486313104.gif" alt=""></p><p>回到上文中的问题，style中设定了div的高度为2，也就是上图中Content区域的高度为2。但是Chrome中实际渲染出来Content的高度为0。也就是盒子模型发生了变化？？是有什么属性会改变浏览器的盒子模型计算高度、宽度的方式么？<br>是的，这个属性就是box-sizing属性。</p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" target="_blank" rel="noopener">MDN文档链接</a><br>box-sizing 属性用于更改用于更改CSS盒子模型计算元素宽度和高度的方式。<br>该属性有两个取值，<strong>content-box</strong>和<strong>border-box</strong></p><h3 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a>content-box</h3><p>默认值，标准盒子模型。 width与height只包括Content的宽和高， 不包括边框（border）、内边距（padding）、外边距（margin）。<br>如一个元素的width=20px，border=10px。则在浏览器中实际的<strong>占用宽度</strong>是40px;</p><h3 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a>border-box</h3><p>width 和 height 属性包括Content，Padding和Border，不包括Margin。<br>如一个元素的width=20px，border=10px。则在浏览器中实际的占用宽度是20px。<br>注意，在这种情况下（width=border+padding），<strong>则会挤压Content的空间</strong>，也就是Content的width=0。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，问题原因应该明朗了，查看出问题的div的box-sizing属性，果然是border-box（页面用了bootstrap.css，将全局的div的box-sizing都设置成了border-box）。<br>解决方案也很简单，在页面里增加css样式，将包含地图控件下所有div的box-sizing属性设置为content-box。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="border-box，如果border-padding超过了width会怎么样？"><a href="#border-box，如果border-padding超过了width会怎么样？" class="headerlink" title="border-box，如果border+padding超过了width会怎么样？"></a>border-box，如果border+padding超过了width会怎么样？</h3><p>先说结果：这种情况下，Content区域会被挤压为0，元素实际占用的宽度会是border+padding。<br>例如 width:20px; padding:10px; border: 1px; box-sizing:border-box; 则元素的占用宽度为22，Content区域宽度为0。其盒子模型如下：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-26-14984595662080.jpg" alt="-w200"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理一个box-sizing引起的样式问题。&lt;/p&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在使用腾讯地图的api展示地图时，发现地图的比例尺展示空白了。&lt;br&gt;如图：&lt;im
      
    
    </summary>
    
      <category term="前端" scheme="http://longlog.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://longlog.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降笔记</title>
    <link href="http://longlog.me/2017/06/14/ml-gradient/"/>
    <id>http://longlog.me/2017/06/14/ml-gradient/</id>
    <published>2017-06-14T09:02:22.000Z</published>
    <updated>2019-08-29T07:09:16.068Z</updated>
    
    <content type="html"><![CDATA[<p>关于梯度下降两篇比较易懂的文章：<br><a href="http://www.cnblogs.com/jianxinzhou/p/3950518.html" target="_blank" rel="noopener">从导数谈起</a><br><a href="http://blog.csdn.net/xiazdong/article/details/7950084" target="_blank" rel="noopener">线性回归及梯度下降</a></p><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><blockquote><p>一个函数在某一点的导数描述了这个函数在这一点附近的变化率</p></blockquote><p>先从1维上来说，例如对于函数y = x^2 。 要求得他的极值点，很简单：对x求导 y’ = 2x，令2x = 0，求解得到当x=0时，y取得极值。<br>如果拓展到2维呢？如 z(x, y) = x^2 + y^2 。还是一样的方法，不同的是需要对x和y分别求<strong>偏导</strong>。<br>z’(x) = 2x ; z’(y) = 2y。令z’(x)和z’(y)等于0，可以解方程得到z(x, y)的极值点为（0, 0）。<br>同样的方法可以拓展到多维，对每个变量求偏导，并分别求得偏导为0时的变量值，结果向量就是函数的极值点。</p><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><p>导数描述了函数的变化率<br>对于平面上的曲线，一个点的导数可以理解该点切线的斜率，切线的正方向，是函数的上升方向。<br>对于多维的空间，就是该点的梯度，梯度的正方向，是函数的上升反向，反之就是下降方向。</p><blockquote><p>对于函数F(X)（X = {x0,x1,…,xn})而言，梯度是F(X)对各个分量求偏导后的结果,代表了F(X)在各个方向的变化率</p></blockquote><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>既然让导数为0可以得到函数的极值点，那为什么要梯度下降？<br>因为很多时候，我们知道导数的表达式，但是没法求导数为0的方程（比如导数是 exp(x)+(ln(x))^2 + x^5 这种..）。这种情况下，我们只能根据根据每个点的导数值（即梯度），选择梯度的反方向去逼近函数的极小值点，这种方法就是梯度下降，反之就是梯度上升。</p><h3 id="梯度下降步骤"><a href="#梯度下降步骤" class="headerlink" title="梯度下降步骤"></a>梯度下降步骤</h3><p>例如对于单变量线性回归（theta0 + theta1 * x）的损失函数：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14974242248427.jpg" alt="-w300"><br>其梯度下降的方法：<br>(1)先确定向下一步的步伐大小，称为Learning rate；<br>(2)任意给定一个初始值：theta0, theta1；<br>(3)确定一个向下的方向，并向下走预先规定的步伐，并更新；<br>(4)当下降的高度小于某个定义的值，则停止下降；<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14974243096274.jpg" alt="-w392"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>初始点不同，获得的最小值也不同，因此梯度下降求得的只是局部最小值</li><li>降的步伐大小非常重要，因为如果太小，则找到函数最小值的速度就很慢，如果太大，有可能呈之字型下降。如图：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14974245759806.jpg" alt="-w200"></li><li>如果Learning rate取值后发现J function 增长了，则需要减小Learning rate的值。</li><li>梯度下降是通过不停的迭代，为了减少迭代次数，因此引入了Feature Scaling（<strong>特征标准化</strong>），使得取值范围<strong>大致</strong>都在-1&lt;=x&lt;=1之间。</li></ol><p>如果不同scale的特征，没有进行标准化，例如某个特征范围是[0, 1]，而另外一个特征是[100w, 200w]。可以想象，等高线的图会特别扁或者特别细。此时，梯度下降的步长得取得特别小，会导致另外一个特征的收敛特别慢。</p><h2 id="梯度下降的种类"><a href="#梯度下降的种类" class="headerlink" title="梯度下降的种类"></a>梯度下降的种类</h2><p><a href="http://www.cnblogs.com/maybe2030/p/5089753.html" target="_blank" rel="noopener">梯度下降法的三种形式BGD、SGD以及MBGD</a><br>这篇文章有详细的介绍，这里只进行简单的总结。</p><h3 id="BGD（批量梯度下降）"><a href="#BGD（批量梯度下降）" class="headerlink" title="BGD（批量梯度下降）"></a>BGD（批量梯度下降）</h3><p>最原始的梯度下降方法， 每次迭代时都使用所有的样本来进行更新。<br>对于上文中线性回归的损失函数，对每个变量求偏导后可以得出梯度下降的变化式：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14974267407348.jpg" alt="-w300"><br>可以看出，每次参数的迭代，都需要全体的样本参与。由于是全体参与迭代，参数稳定收敛，但是在训练集很大时，训练效率会非常低。</p><h3 id="SGD（随机梯度下降）"><a href="#SGD（随机梯度下降）" class="headerlink" title="SGD（随机梯度下降）"></a>SGD（随机梯度下降）</h3><p><a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" target="_blank" rel="noopener">维基百科</a><br>利用单个样本来进行迭代，解决样本量大时BGD迭代速度慢的问题。<br>如上文，将线性回归的损失函数进行转换：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14974280777979.jpg" alt="-w400"><br>这个式子可以解释为，整体的损失可以拆解为单个样本的损失之和，如果能将单个样本的损失减小，则总的损失也会减小（<strong>减小单个样本的损失来逼近总体损失的极小值</strong>）。<br><strong>可以将SGD理解样本全集只有1个时的BGD。</strong><br>对单个样本的cost函数求偏导后得出theta的变化式：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14974284080883.jpg" alt="-w300"><br>SGD每次迭代只有一个样本参与，因此可以大大增加迭代速度，提升训练速度。但是由于每次迭代都是局部进行，迭代比较”盲目”。学习过程，目标函数可能会存在波动：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14974298909255.png" alt="-w200"><br>SGD 收敛过程中的波动，可能会帮助目标函数跳入另一个可能的更小的极小值，但是也有可能跳出原来全局的极小值。</p><h4 id="SGD和BGD的伪代码"><a href="#SGD和BGD的伪代码" class="headerlink" title="SGD和BGD的伪代码"></a>SGD和BGD的伪代码</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#BGD</span></span><br><span class="line">choose initial vector of parameters <span class="keyword">and</span> learning rate</span><br><span class="line">Repeat until an approximate minimum <span class="keyword">is</span> obtained:</span><br><span class="line">  params_grad = evaluate_gradient(loss_function, data, params)</span><br><span class="line">  params = params - learning_rate * params_grad</span><br><span class="line"></span><br><span class="line"><span class="comment">#SGD</span></span><br><span class="line">choose initial vector of parameters <span class="keyword">and</span> learning rate</span><br><span class="line">Repeat until an approximate minimum <span class="keyword">is</span> obtained:</span><br><span class="line">  np.random.shuffle(data)</span><br><span class="line">  <span class="keyword">for</span> example <span class="keyword">in</span> data:</span><br><span class="line">    params_grad = evaluate_gradient(loss_function, example, params)</span><br><span class="line">    params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><h3 id="MBGD（小批量梯度下降法）"><a href="#MBGD（小批量梯度下降法）" class="headerlink" title="MBGD（小批量梯度下降法）"></a>MBGD（小批量梯度下降法）</h3><p>SGD和BGD的折衷方法，即每次迭代使用指定数量的一批样本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于梯度下降两篇比较易懂的文章：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/jianxinzhou/p/3950518.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从导数谈起&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="机器学习" scheme="http://longlog.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MachineLearning" scheme="http://longlog.me/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>逻辑回归思考</title>
    <link href="http://longlog.me/2017/06/14/ml-logic/"/>
    <id>http://longlog.me/2017/06/14/ml-logic/</id>
    <published>2017-06-14T09:01:22.000Z</published>
    <updated>2019-08-29T07:09:16.079Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<br><a href="http://blog.csdn.net/bitcarmanlee/article/details/51154481" target="_blank" rel="noopener">logistic回归详解一：为什么要使用logistic函数</a><br><a href="http://blog.csdn.net/bitcarmanlee/article/details/51165444" target="_blank" rel="noopener">logistic回归详解二：损失函数（cost function）详解</a><br><a href="https://chenrudan.github.io/blog/2016/01/09/logisticregression.html" target="_blank" rel="noopener">*浅析Logistic Regression</a></p><h2 id="从线性回归到逻辑回归"><a href="#从线性回归到逻辑回归" class="headerlink" title="从线性回归到逻辑回归"></a>从线性回归到逻辑回归</h2><p>对于线性回归来说，模型的假设是输入向量x和真实值y之间存在关系：y = wx + b，即用wx + b去逼近样本的真实值。<br>拓展到广义的线性模型（机器学习第三章P56），可以令wx + b去逼近y的衍生函数，例如 ln^y = wx + b。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14973232448037.jpg" alt=""><br>对于二分类问题，逻辑回归提出的假设是，令wx + b逼近样本为正例的概率。参考上图，即假设：P = g^-1 * (wx + b)。此时，需要一个合适的函数g，能将wx + b 映射到概率[0, 1]之间，因此引入了sigmoid函数。</p><h2 id="为什么要用sigmoid函数？"><a href="#为什么要用sigmoid函数？" class="headerlink" title="为什么要用sigmoid函数？"></a>为什么要用sigmoid函数？</h2><p>理想的模型函数是如图3.2的红色函数，其中z = wx + b，即线性模型的预测结果。如果z&gt;0则判定为正例，z&lt;0则为反例。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14972714947069.jpg" alt="-w500"><br>但是，这个函数存在不连续，在z=0的点不可导等特点，数学上处理起来不方便。而<strong>sigmoid函数，刚好满足二分类的需求，并且具有良好的连续性</strong>。</p><blockquote><p>线性函数的值越接近正无穷，概率值就越接近1；线性值越接近负无穷，概率值越接近0，这样的模型是逻辑斯蒂回归模型(李航.《统计机器学习》)</p></blockquote><h2 id="逻辑回归损失函数怎么来的？"><a href="#逻辑回归损失函数怎么来的？" class="headerlink" title="逻辑回归损失函数怎么来的？"></a>逻辑回归损失函数怎么来的？</h2><p>机器学习或者统计机器学习常见的损失函数：</p><ol><li>平方损失函数（quadratic loss function): L(Y,f(X))=(Y−f(x))^2</li><li>绝对值损失函数(absolute loss function): L(Y,f(x))=|Y−f(X)|</li><li>对数损失函数（logarithmic loss function) 或<strong>对数似然损失函数</strong>(log-likehood loss function):<br>L(Y,P(Y|X))=−logP(Y|X), P(Y|X)表示样本X标记正确的概率。<br>逻辑回归使用的是对数损失函数，根据对数损失定义，可以得出单个样本的损失函数如下：</li></ol><p><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14973239587272.jpg" alt="-w400"><br>将两个式子合并为一个：</p><p><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14973241686186.jpg" alt="-w400"></p><p>全体样本的损失函数可以表示为：</p><p><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-06-14-14973241924422.jpg" alt="-w400"></p><p>定义损失函数之后，剩下的就是求解的过程，逻辑回归求解方法有梯度下降、牛顿法、BFGS等。</p><h2 id="最小二乘、极大似然、梯度下降"><a href="#最小二乘、极大似然、梯度下降" class="headerlink" title="最小二乘、极大似然、梯度下降"></a>最小二乘、极大似然、梯度下降</h2><p><a href="https://www.zhihu.com/question/24900876" target="_blank" rel="noopener">知乎问题</a><br>机器学习的框架是：<strong>模型、目标和算法</strong>。模型是指输入到输出的映射方式，目标是让模型”更好”地拟合数据，或者说让模型损失(Cost Function)达到最小，算法是指达到目标使用的方法。<br>最小二乘和梯度下降都属于求解方法（优化算法），最小二乘一般用于线性模型，梯度下降很多模型都会使用，比如逻辑回归（线性模型也可以用梯度下降）。<br>极大似然法是一种推导方式，使用极大似然法可以从概率的角度推导出模型的损失函数（比如逻辑回归的对数似然）。</p><blockquote><p>极大似然估计：在已经得到试验结果的情况下，我们应该寻找<strong>使这个结果出现的可能性最大的那个theta作为真实theta的估计</strong></p></blockquote><p>对应到逻辑回归中，就是寻找参数theta，使得每个样本属于其真实标记的概率越大越好（机器学习 - P59）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考链接：&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/bitcarmanlee/article/details/51154481&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;logistic回归详解一：为什么要使用logistic
      
    
    </summary>
    
      <category term="机器学习" scheme="http://longlog.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MachineLearning" scheme="http://longlog.me/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>博文阅读笔记 - 四月</title>
    <link href="http://longlog.me/2017/05/19/read-note-44/"/>
    <id>http://longlog.me/2017/05/19/read-note-44/</id>
    <published>2017-05-19T08:02:22.000Z</published>
    <updated>2019-08-29T07:09:16.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-04-06-检查Linux服务器性能命令"><a href="#2017-04-06-检查Linux服务器性能命令" class="headerlink" title="2017-04-06 检查Linux服务器性能命令"></a>2017-04-06 检查Linux服务器性能命令</h2><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650994146&amp;idx=1&amp;sn=f6b0987a06831805b4c343c417121827&amp;chksm=bdbf0db18ac884a7166b4f440f577148b72d08b6ec72f368a4e7898877cbadfa36b2a1cba1c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">原文链接</a></p><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>查看系统1分钟、5分钟、15分钟内的负载，表示等待CPU的进程和阻塞的进程(D状态)数量。如果15分钟的负载高1分钟的负载低，说明机器说明机器紧张状态在缓解。如果15分钟的低而1分钟的高，说明机器负载在加大，需要排查CPU占用。</p><h3 id="vmstat-1"><a href="#vmstat-1" class="headerlink" title="vmstat 1"></a>vmstat 1</h3><ol><li><code>vmstat 1</code>表示每秒输出一次</li><li>r是等待在CPU资源的进程数</li><li>si，so是交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足</li><li>us（用户时间）, sy（系统时间）, id（空闲时间）, wa（IO等待时间）</li></ol><p>如果IO等待时间长，那么瓶颈在于磁盘IO。如果用户时间长，说明是应用程序在消耗CPU时间</p><h3 id="mpstat-P-ALL-1"><a href="#mpstat-P-ALL-1" class="headerlink" title="mpstat-P ALL 1"></a>mpstat-P ALL 1</h3><p>查看每个CPU的时间占用</p><h3 id="pidstat-1"><a href="#pidstat-1" class="headerlink" title="pidstat 1"></a>pidstat 1</h3><p>查看每个进程的CPU占用率</p><h3 id="iostat-xz-1"><a href="#iostat-xz-1" class="headerlink" title="iostat -xz 1"></a>iostat -xz 1</h3><ol><li><code>r/s w/s</code> 表示读写秒读写次数</li><li>await：IO操作平均等待时间（ms）</li><li>%util：设备利用率。表示设备的繁忙程度，超过60会影响IO性能，达到100%说明硬件已经饱和</li></ol><h3 id="sar-n-DEV-1"><a href="#sar-n-DEV-1" class="headerlink" title="sar -n DEV 1"></a>sar -n DEV 1</h3><p>查看网络设备的吞吐率。rxkB表示每秒吞吐的数据量。</p><h3 id="sar-n-TCP-ETCP-1"><a href="#sar-n-TCP-ETCP-1" class="headerlink" title="sar -n TCP,ETCP 1"></a>sar -n TCP,ETCP 1</h3><p>查看TCP连接状态</p><ol><li><code>active/s</code> ：每秒本地发起的TCP（connect）连接数</li><li><code>passive/s</code>：每秒远程发起的TCP（accept）连接数</li><li><code>retrans/s</code>：每秒TCP重传数量</li></ol><h2 id="2017-04-01-从日志统计到大数据分析"><a href="#2017-04-01-从日志统计到大数据分析" class="headerlink" title="2017-04-01 从日志统计到大数据分析"></a>2017-04-01 从日志统计到大数据分析</h2><p><a href="https://zhuanlan.zhihu.com/p/20477493?columnSlug=sangwf" target="_blank" rel="noopener">原文链接</a><br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-05-19-14909389945639.jpg" alt=""></p><p>不管是推进公司的日志采集结构化，还是提供更强大的查询引擎，都是在尝试把这条流建设的更好。</p><h3 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h3><ol><li>初始的数据源尽量全而细</li><li>源头进行结构化、预处理能大大降低后期成本</li><li>对存储的数据进行抽象，区分类型（行为数据、业务数据）<br>ETL（Extract-Transform-Load）是对对数据进行抽取、变换和加载的过程。数据源预处理的越好，ETL过程就能越简单。</li></ol><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>避免重复造轮子</p><ol><li>Sqoop：用于传统数据库和Hadoop之间的数据传输。</li><li>Scribe：Facebook开源的一套日志传输系统，将源日志传输到Hadoop等分布式文件系统中。</li><li>Flume：Cloudera开源的一套日志传输系统，和Scribe类似。</li><li>Kafka：Linkedin开源的一套消息传输系统。</li></ol><h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>理想状态：服务方数据准备好，又提供强大的工具，需求方自行处理数据分析需求。</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>漏斗分析和留存分析<br><a href="https://zhuanlan.zhihu.com/p/20512931?columnSlug=sangwf" target="_blank" rel="noopener">分析case</a><br><strong>数据分析的最终目的是数据驱动产品</strong></p><h3 id="数据系统的架构"><a href="#数据系统的架构" class="headerlink" title="数据系统的架构"></a>数据系统的架构</h3><p><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-05-19-14909466663411.jpg" alt=""><br>横向为上文说的数据流，纵向包含三个重要的系统：调度系统、监控系统、元数据系统。<br>调度器的核心功能：一是定时器；二是优化资源利用，特别是任务优先级的控制；三是管理任务依赖关系</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><ul><li>数据的Schema：表、字段定义等。</li><li>数据的就绪状态：数据就绪时间、存放位置等动态信息。</li><li>元数据的访问API。<br>拓展：</li><li>权限控制</li><li>元数据变更记录</li></ul><h4 id="元数据的好处"><a href="#元数据的好处" class="headerlink" title="元数据的好处"></a>元数据的好处</h4><ol><li>可以作为数据平台内部模块间通讯的接口</li><li>数据发现</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2017-04-06-检查Linux服务器性能命令&quot;&gt;&lt;a href=&quot;#2017-04-06-检查Linux服务器性能命令&quot; class=&quot;headerlink&quot; title=&quot;2017-04-06 检查Linux服务器性能命令&quot;&gt;&lt;/a&gt;2017-04-06 
      
    
    </summary>
    
      <category term="NOTE" scheme="http://longlog.me/categories/NOTE/"/>
    
    
      <category term="NOTE" scheme="http://longlog.me/tags/NOTE/"/>
    
  </entry>
  
  <entry>
    <title>缓存失效的更新策略阅读思考</title>
    <link href="http://longlog.me/2017/05/19/redis-mis-strategy/"/>
    <id>http://longlog.me/2017/05/19/redis-mis-strategy/</id>
    <published>2017-05-19T08:02:22.000Z</published>
    <updated>2019-08-29T07:09:16.076Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">原文链接</a><br>缓存失效的策略有很多种，详细的介绍参考原文，这里主要思考其中最常用的一种策略的问题。</p><h2 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h2><p>最常用的缓存设计模式：</p><ul><li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从cache中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2>在读策略都一样时，对比先删缓存再更新数据库，两种方式在读写并发下都会出现脏数据的问题，但是出问题的条件存在很大的区别。</li></ul><h3 id="方式一：先删缓存再更新数据库"><a href="#方式一：先删缓存再更新数据库" class="headerlink" title="方式一：先删缓存再更新数据库"></a>方式一：先删缓存再更新数据库</h3><p>出问题的条件：</p><ol><li>缓存失效</li><li>读请求先进入（因为更新操作一般会加锁s），读数据耗时 &lt; 写数据耗时（读操作先完成）</li></ol><h3 id="方式二：先更新数据库再删缓存"><a href="#方式二：先更新数据库再删缓存" class="headerlink" title="方式二：先更新数据库再删缓存"></a>方式二：先更新数据库再删缓存</h3><p>出问题的条件：</p><ol><li>缓存失效</li><li>读请求先进入， 读耗时 &gt; 写耗时（读操作在写操作完成后完成）</li></ol><p>正常情况下，<strong>写数据都是比读耗时时间长</strong>。另外，在方式一中，先删缓存，增加了缓存失效的概率。因此可以看出来方式一出现脏数据的可能性明显大于使用方式二。实际上方式二出现脏数据的可能性很低。</p><h3 id="方式三：读操作不更新缓存，写完数据后更新缓存"><a href="#方式三：读操作不更新缓存，写完数据后更新缓存" class="headerlink" title="方式三：读操作不更新缓存，写完数据后更新缓存"></a>方式三：读操作不更新缓存，写完数据后更新缓存</h3><p>这种方式下，出问题的条件变得更加简单：当出现并发的写操作，如果更新缓存的耗时较长，就有可能出现。对于写操作并发高的网站，这种条件很容易满足。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://coolshell.cn/articles/17416.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;br&gt;缓存失效的策略有很多种，详细的介绍参考原文，这里主要思考其中最常用的一种策略的问题。&lt;/
      
    
    </summary>
    
      <category term="后端" scheme="http://longlog.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Redis" scheme="http://longlog.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>swoole使用中踩的坑</title>
    <link href="http://longlog.me/2017/04/10/swoole-error/"/>
    <id>http://longlog.me/2017/04/10/swoole-error/</id>
    <published>2017-04-10T13:05:14.000Z</published>
    <updated>2019-08-29T07:09:16.064Z</updated>
    
    <content type="html"><![CDATA[<p>从去年开始使用swoole开发内部的一些小的服务，中间遇到一些坑，在此记录</p><h2 id="多进程不能共用连接"><a href="#多进程不能共用连接" class="headerlink" title="多进程不能共用连接"></a>多进程不能共用连接</h2><p><a href="https://wiki.swoole.com/wiki/page/325.html" target="_blank" rel="noopener">官方文档</a><br>其实这个是所有多进程、多线程程序都需要注意的问题，当进程or线程共享资源的时候，一定要考虑资源冲突，否则会出现各种诡异的问题（死锁、数据返回异常、连接被关闭等等等）。<br>如下代码，在swoole中，在server启动时创建了一个redis连接，在onRequest中使用。<br>代码看上去没什么问题，但是实际使用时，如果压力很大，就会出现多进程抢占连接导致的问题。原因是因为创建的redis连接实际上是一个全局对象，每个work进程都在使用同一个连接。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $redis;</span><br><span class="line"><span class="keyword">public</span> $server;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//initServer</span></span><br><span class="line">$server = <span class="keyword">new</span> swoole_http_server( <span class="keyword">$this</span>-&gt;productConfig[<span class="string">"server"</span>][<span class="string">"host"</span>], </span><br><span class="line">                                  <span class="keyword">$this</span>-&gt;productConfig[<span class="string">"server"</span>][<span class="string">"port"</span>]);</span><br><span class="line">$server-&gt;on(<span class="string">'request'</span>, <span class="keyword">array</span>(<span class="keyword">$this</span>, <span class="string">'onRequest'</span>));</span><br><span class="line">$server-&gt;on(<span class="string">'workerstart'</span>, <span class="keyword">array</span>(<span class="keyword">$this</span>, <span class="string">'onWorkerStart'</span>));</span><br><span class="line"><span class="keyword">$this</span>-&gt;server = $server;</span><br><span class="line"><span class="comment">//initRedis</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;redis = <span class="keyword">new</span> Redis();</span><br><span class="line"><span class="keyword">$this</span>-&gt;redis-&gt;connect(<span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"host"</span>], </span><br><span class="line"><span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"port"</span>]);  </span><br><span class="line">$server-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求处理函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">($request, $response)</span> </span>&#123;</span><br><span class="line"><span class="comment">//do some thing with redis</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;redis-&gt;get(<span class="string">"somekey"</span>);</span><br><span class="line">$response-&gt;end(json_encode([<span class="string">"errno"</span> =&gt; <span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//worker进程创建函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onWorkerStart</span><span class="params">($serv, $workerId)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$server = <span class="keyword">new</span> Server();</span><br><span class="line">$init   = $server-&gt;init();</span><br><span class="line"><span class="keyword">if</span> ($init[<span class="string">"errno"</span>] !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(json_encode($init));</span><br><span class="line">&#125; </span><br><span class="line">$server-&gt;run();</span><br></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li><p>不在server中创建，而在onRequest中，接收到请求时创建<br>简单粗暴的解决方案，每次收到请求时独立创建局部的redis连接，请求结束后释放。这种方式缺点很明显，连接没有复用，影响性能。</p></li><li><p>在onWorkerStart中创建连接，并按workerId索引每个worker进程的redis连接<br>代码如下（主体代码参考上面），在Server中增加一个redisPool，worker启动时创建连接后注册到pool中。这样能保证每次请求时，使用的都是各进程独立的redis连接。</p></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Server类中增加$redisPool变量，初始化为空数组</span></span><br><span class="line"><span class="keyword">public</span> $redisPool = [];</span><br><span class="line"><span class="comment">//worker进程创建函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onWorkerStart</span><span class="params">($serv, $workerId)</span> </span>&#123;</span><br><span class="line">$redis   = <span class="keyword">new</span> \Redis();</span><br><span class="line">$tmpRes  = $redis-&gt;connect(<span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"host"</span>], </span><br><span class="line">                           <span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"port"</span>]);  </span><br><span class="line"><span class="keyword">if</span> ($tmpRes === <span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;logger-&gt;error(<span class="string">"Redis Init failed workerId:$workerId"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">$redis-&gt;setOption(Redis::OPT_READ_TIMEOUT, </span><br><span class="line">                  <span class="keyword">$this</span>-&gt;productConfig[<span class="string">"redis"</span>][<span class="string">"read_timeout"</span>]);</span><br><span class="line"><span class="keyword">$this</span>-&gt;redisPool[$workerId] = $redis;<span class="comment">//将连接注册到pool中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求处理函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">($request, $response)</span> </span>&#123;</span><br><span class="line"><span class="comment">//do some thing with redis</span></span><br><span class="line">$redis = <span class="keyword">$this</span>-&gt;redisPool[<span class="keyword">$this</span>-&gt;server-&gt;worker_id];</span><br><span class="line">$response-&gt;end(json_encode([<span class="string">"errno"</span> =&gt; <span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tcp协议包完整性"><a href="#tcp协议包完整性" class="headerlink" title="tcp协议包完整性"></a>tcp协议包完整性</h2><p><a href="https://wiki.swoole.com/wiki/page/50.html" target="_blank" rel="noopener">官方文档</a><br><a href="http://blog.csdn.net/ldy3243942/article/details/40920743?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Swoole的自定义协议功能的使用</a><br>在默认情况下，使用swoole-server时（TCP协议），swoole不对包的进行完整性校验，在onReceive中接收到的包可能是不完整的，也有可能是多份数据。这是由于TCP协议的原理所造成的：</p><blockquote><p>TCP是一个流式协议。客户端向服务器发送的一段数据，可能并不会被服务器一次就完整的收到;客户端向服务器发送的多段数据，可能服务器一次就收到了全部的数据</p></blockquote><p>如下代码，在onReceive中接收到数据后，转给task进程进行处理，task进程处理结束后返回。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求处理（接收到客户端发送的数据）</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onReceive</span><span class="params">(swoole_server $serv, int $fd, int $from_id, string $data)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;logger-&gt;debug(<span class="string">"ReceiveMSG: "</span> . $data, [<span class="string">"fd"</span> =&gt; $fd]);</span><br><span class="line">$params = [</span><br><span class="line"><span class="string">"fd"</span> =&gt; $fd,</span><br><span class="line"><span class="string">"data"</span> =&gt; $data</span><br><span class="line">];</span><br><span class="line">$conInfo = $serv-&gt;connection_info($fd);</span><br><span class="line"><span class="keyword">$this</span>-&gt;logger-&gt;debug(<span class="string">"conninfo fd:$fd "</span>, [<span class="string">"info"</span> =&gt; $conInfo]);</span><br><span class="line"><span class="keyword">$this</span>-&gt;server-&gt;task($params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际的task处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onTask</span><span class="params">($serv, $taskId, $srcWorkerId, $params)</span> </span>&#123;</span><br><span class="line">$fd = $params[<span class="string">"fd"</span>];</span><br><span class="line">$sendRes = $serv-&gt;send($fd, <span class="string">"hehe\t0\t[]\n"</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;logger-&gt;debug(<span class="string">"conninfo-InTask fd:$fd "</span>, [<span class="string">"sendRes"</span> =&gt; $sendRes]);</span><br><span class="line">$serv-&gt;close($fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与客户端的连接被关闭</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onClose</span><span class="params">(swoole_server $server, int $fd, int $reactorId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;logger-&gt;debug(<span class="string">"fd:$fd is Close"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时（发送的数据比较大），有可能出现这样的日志。从日志里可以看到</p><ol><li>同一个server_fd(53)接收到了两份数据，两份数据来自同一个client_fd(22)</li><li>第一个task向客户端发送数据成功了，但是第二个发送失败（sendRes：false）<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-04-10-14918263781334.jpg" alt=""><br>实际打印出数据（在onReceive中），会发现客户端发送的数据被拆成了两份，因此触发了两次onReceive。<br>第二个task中sendRes失败，是因为在处理第一份数据时，task中已经把客户端连接给关闭了。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="open-eof-check"><a href="#open-eof-check" class="headerlink" title="open_eof_check"></a>open_eof_check</h4><p>使用swoole提供的open_eof_check，保证数据包的完整性。</p><blockquote><p>此选项将检测客户端连接发来的数据，当数据包结尾是指定的字符串时才会投递给Worker进程。否则会一直拼接数据包，直到超过缓存区或者超时才会中止</p></blockquote><p>EOF即为数据的结束标记，具体由客户端使用的发送方式而定，比如Memcache协议以”\r\n”结尾，Java中BuffWriter.newLine()发送的数据在有可能是<code>&quot;\n&quot;</code>结尾，也有可能是<code>&quot;\r\n&quot;</code>。<br>注意：<strong>swoole的EOF检测不会从数据中间查找eof字符串，所以Worker进程可能会同时收到多个数据包，需要在应用层代码中自行explode(“\n”, $data) 来拆分</strong>，1.7.15版本增加了open_eof_split，支持从数据中查找EOF，并切分数据。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'open_eof_check'</span> =&gt; <span class="keyword">true</span>, <span class="comment">//打开EOF检测</span></span><br><span class="line"><span class="string">'package_eof'</span>  =&gt; <span class="string">"\n"</span>, <span class="comment">//设置EOF</span></span><br></pre></td></tr></table></figure><h4 id="手动拼接请求数据"><a href="#手动拼接请求数据" class="headerlink" title="手动拼接请求数据"></a>手动拼接请求数据</h4><p>默认情况下，同一个客户端fd会被分配到同一个worker中处理，所以数据可以拼接起来，当发现结尾是EOF字符时才进行处理。<br>例如可以在全局数据中保存一个数组buff，接收到数据后进行拼接和判断。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$buff[$fd] .= $data;</span><br><span class="line"><span class="keyword">if</span> (substr($buff[$fd], <span class="number">-1</span>) == <span class="string">"\n"</span>) &#123;<span class="comment">//\n也可以是其他的EOF字符</span></span><br><span class="line"><span class="comment">//数据完整，执行具体的逻辑</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//数据不完整，返回等待下次接收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从去年开始使用swoole开发内部的一些小的服务，中间遇到一些坑，在此记录&lt;/p&gt;&lt;h2 id=&quot;多进程不能共用连接&quot;&gt;&lt;a href=&quot;#多进程不能共用连接&quot; class=&quot;headerlink&quot; title=&quot;多进程不能共用连接&quot;&gt;&lt;/a&gt;多进程不能共用连接&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="后端" scheme="http://longlog.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="PHP" scheme="http://longlog.me/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://longlog.me/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>Twemproxy + SSDB 性能测试</title>
    <link href="http://longlog.me/2017/04/06/twemprxy-ssdb-performance/"/>
    <id>http://longlog.me/2017/04/06/twemprxy-ssdb-performance/</id>
    <published>2017-04-06T04:18:14.000Z</published>
    <updated>2019-08-29T07:09:16.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol><li>SSDB是一个高性能的NoSql数据库，底层使用LevelDB，兼容Redis协议。主要用于解决Redis无法存储海量数据的问题。<a href="http://ssdb.io/zh_cn/" target="_blank" rel="noopener">官网链接</a></li><li>Twemproxy 是twitter开源的高性能、轻量级redis集群代理</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如下图，线上ssdb集群的耗时随着时间的增长耗时不断增长，最高时达到6.5s<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-04-06-14914576091140.jpg" alt=""></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol><li>线上部署采用的是twemproxy + ssdb的方式。2台proxy下挂4台ssdb</li><li>服务请求方为4台机器，每台机器50个线程，每个线程单次读取1000条数据（hget请求）</li><li>twemproxy和ssdb均采用官方推荐配置，ssdb开启缓存为20G</li><li><strong>客户端连接proxy使用的是jedis客户端，使用pipline方式进行批量请求</strong>。</li></ol><p>可以推算出：<br>最高QPS： <code>4 * 50 * 1000 = 20w</code><br>SSDB单机最高QPS： 5w<br>PROXY单机最高QPS：10w<br>上图中6.5s耗时为单个线程请求三份数据的总耗时（串行），每份数据为1000条，因此可以推算出单<strong>次请求1000条数据的耗时在2s上下</strong>，无法满足要求。</p><h3 id="问题推测"><a href="#问题推测" class="headerlink" title="问题推测"></a>问题推测</h3><ol><li>除了ssdb耗时高以外， 服务请求方机器内存、CPU、IO、网络均正常，并且重启客户端耗时无变化，可以排除是客户端的问题。</li><li>SSDB机器和Proxy机器的内存、CPU、IO、网络均正常，可以排除是系统层面的问题</li><li>客户端请求读取的都是半小时内刚写入的数据，可以排除是读取请求都落在磁盘上导致的性能下降</li></ol><p>因此，问题原因基本可以判定是出现在Proxy或者SSDB自身上，测试也主要针对这两个部分分别进行。</p><h2 id="Proxy-性能测试"><a href="#Proxy-性能测试" class="headerlink" title="Proxy 性能测试"></a>Proxy 性能测试</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ol><li>测试环境使用单台proxy下挂2台ssdb（相当于线上一半的配置）</li><li>SSDB数据量分别为107G和117G。</li><li>客户端连接使用jedis的pipeline批量请求</li></ol><h3 id="Proxy测试场景和结果"><a href="#Proxy测试场景和结果" class="headerlink" title="Proxy测试场景和结果"></a>Proxy测试场景和结果</h3><p><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-04-06-14914492594626.jpg" alt=""></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>提高server_connection对性能的影响明显，在线下环境下，设置为15<strong>提升约1倍的性能</strong>（对比场景11和场景9）</li><li>修改启动的-m选项，<strong>提升性能约10%</strong>（对比场景13和12）</li></ol><p>关于server_connection和mbuf的官方说明：<a href="https://github.com/twitter/twemproxy/blob/master/notes/recommendation.md" target="_blank" rel="noopener">twemproxy文档</a></p><h4 id="server-connection"><a href="#server-connection" class="headerlink" title="server_connection"></a>server_connection</h4><ol><li>Twemproxy与SSDB客户端之间的保持的连接数。<strong>默认为1</strong>，即Proxy和SSDB实例之间只使用一个连接。</li><li>Twemproxy对该连接的使用是基于epool事件循环，因此该连接能支持很高的并发。</li></ol><p>提高server_connection对性能影响很大，猜测是当前的并发已经达到了单个连接的上限。不过继续当达到一定数量后提高server_connection对性能的不大（对比场景14和13），甚至有可能下降，这个原因没有细查，猜测可能是连接数大了后Proxy的维护和切换成本会提高。</p><h4 id="mbuf"><a href="#mbuf" class="headerlink" title="mbuf"></a>mbuf</h4><p>Twemproxy存储request数据使用的最小单位，默认为16M。当并发高时，官方建议调小该值，否则很可能造成很高的内存占用。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>在线上修改了server_connection和mbuf参数后，耗时下降明显，接近ssdb的极限性能。</p><p><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-04-06-14914517106043.jpg" alt=""></p><h2 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h2><h3 id="Redis替换SSDB能否提升性能"><a href="#Redis替换SSDB能否提升性能" class="headerlink" title="Redis替换SSDB能否提升性能?"></a>Redis替换SSDB能否提升性能?</h3><p>可以看出，redis对ssdb的性能提升不明显。原因是测试中读取的都是热数据，ssdb的读取都是内存操作，和redis读取的差别不大。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-04-06-14914518753097.jpg" alt=""></p><h3 id="使用get-set能否提升性能"><a href="#使用get-set能否提升性能" class="headerlink" title="使用get/set能否提升性能?"></a>使用get/set能否提升性能?</h3><p>将存储数据进行转换，测试脚本中的hget操作修改为get操作，get的性能相比hget提升约1/3。<br>但是改为get后，实际的请求量会增长（如果hash结构中有4个key，则改为get后请求增长4倍），因此修改为get请求对整体并没有帮助。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-04-06-14914521918853.jpg" alt=""></p><h3 id="Proxy的数量多少合适？"><a href="#Proxy的数量多少合适？" class="headerlink" title="Proxy的数量多少合适？"></a>Proxy的数量多少合适？</h3><p>从结果数据来看：</p><ol><li>proxy和ssdb数量达到2：1后，再增加proxy对性能已经基本没有提升（此时实际上已经到了ssdb的性能上限）。</li><li>proxy和ssdb数量2：1相对于1：1的性能提升约为15%</li></ol><p>所以，2：1的话能使性能最大化，但是比较浪费资源，1：1是合理的方案。<br>实际线上部署时，一台机器可以部署2~4个proxy，线下在单台机器部署3个proxy时，在100并发每次2000数据的情况下，影响CPU-IDLE约5，网卡占用约15%。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-04-06-14914520378195.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;SSDB是一个高性能的NoSql数据库，底层使用LevelDB，兼容Redis协议。主要用于解决Redis无法存储海量数据的问题。
      
    
    </summary>
    
      <category term="后端" scheme="http://longlog.me/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="SSDB" scheme="http://longlog.me/tags/SSDB/"/>
    
      <category term="Twemproxy" scheme="http://longlog.me/tags/Twemproxy/"/>
    
  </entry>
  
  <entry>
    <title>MY-2017</title>
    <link href="http://longlog.me/2017/03/28/MY-2017/"/>
    <id>http://longlog.me/2017/03/28/MY-2017/</id>
    <published>2017-03-28T11:30:42.000Z</published>
    <updated>2019-08-29T07:09:16.077Z</updated>
    
    <content type="html"><![CDATA[<p>个人2017年的学习规划。</p><h2 id="总规划第一版-2017-03-28"><a href="#总规划第一版-2017-03-28" class="headerlink" title="总规划第一版-2017-03-28"></a>总规划第一版-2017-03-28</h2><p><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-28-14906900294250.jpg" alt=""></p><h2 id="五月份目标"><a href="#五月份目标" class="headerlink" title="五月份目标"></a>五月份目标</h2><p>主要是填4月份的坑。</p><ul><li style="list-style:none"><input type="checkbox">《Spark大数据分析》（精读 + 笔记）<ul><li style="list-style:none"><input type="checkbox">Spark官网文档阅读（粗读 + 笔记）</li><li style="list-style:none"><input type="checkbox">SparkStreaming官网文档阅读笔记（粗读 + 笔记）</li></ul></li><li style="list-style:none"><input type="checkbox">InfoQSpark系列文章</li><li style="list-style:none"><input type="checkbox">机器学习视频NG - 1 ~ 4节</li><li style="list-style:none"><input type="checkbox" checked>《机器学习》- 前三章</li><li style="list-style:none"><input type="checkbox">《Modern-PHP》</li><li style="list-style:none"><input type="checkbox">Laravel文档-系统架构部分<br><del>* [ ] ES文档阅读笔记更新到Blog</del></li><li style="list-style:none"><input type="checkbox">ES中文插件学习</li><li style="list-style:none"><input type="checkbox">Vue.js基础</li><li style="list-style:none"><input type="checkbox" checked>博文阅读笔记X4</li><li style="list-style:none"><input type="checkbox" checked>写一篇博文</li></ul><h2 id="四月份目标"><a href="#四月份目标" class="headerlink" title="四月份目标"></a>四月份目标</h2><ul><li style="list-style:none"><input type="checkbox" checked>《Python教程 - 廖雪峰》<ul><li style="list-style:none"><input type="checkbox" checked>04-05 泛读并做笔记。</li></ul></li><li style="list-style:none"><input type="checkbox">《Spark大数据分析》精读</li><li style="list-style:none"><input type="checkbox">InfoQSpark系列文章</li><li style="list-style:none"><input type="checkbox">机器学习视频-NG</li><li style="list-style:none"><input type="checkbox">《机器学习》- 前三章</li><li style="list-style:none"><input type="checkbox">ES中文插件学习</li><li style="list-style:none"><input type="checkbox">《Modern-PHP》</li><li style="list-style:none"><input type="checkbox">Laravel文档-系统架构部分</li><li style="list-style:none"><input type="checkbox" checked>写一篇博文<ul><li style="list-style:none"><input type="checkbox" checked>04-06 TwemProxy+SSDB性能测试</li></ul></li><li style="list-style:none"><input type="checkbox" checked>博客增加一个2017目标的页面</li><li style="list-style:none"><input type="checkbox">ES文档阅读笔记更新到Blog</li><li style="list-style:none"><input type="checkbox">Vue.js基础(3.31 增加)</li><li style="list-style:none"><input type="checkbox" checked>博文阅读笔记X10 - InfoQ-全年精选博文-挑选文章阅读概要<ul><li style="list-style:none"><input type="checkbox" checked>03-28 <a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650994868&amp;idx=1&amp;sn=c79e0217ce2b3454c654fa9d90212d09&amp;chksm=bdbf00e78ac889f11e65c4cbbcb9ea903b65422da93e61936e7badc828aa98d9df5460a0f3d7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">新浪微博升级PHP7</a></li><li style="list-style:none"><input type="checkbox" checked>03-28 <a href="http://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug" target="_blank" rel="noopener">Redis架构之防雪崩设计</a></li><li style="list-style:none"><input type="checkbox" checked>04-01 <a href="https://zhuanlan.zhihu.com/p/20477493?columnSlug=sangwf" target="_blank" rel="noopener">从日志统计到大数据分析</a></li><li style="list-style:none"><input type="checkbox" checked>04-06 <a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650994146&amp;idx=1&amp;sn=f6b0987a06831805b4c343c417121827&amp;chksm=bdbf0db18ac884a7166b4f440f577148b72d08b6ec72f368a4e7898877cbadfa36b2a1cba1c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">检查Linux服务器性能命令</a></li></ul></li></ul><p><del>* [ ] 《HeadFirst Python》</del> 改成看廖雪峰的教程<br><del>* [ ] Spark官网文档阅读笔记</del> Spark程序设计中已包含<br><del>* [ ] SparkStreaming官网文档阅读笔记</del> Spark程序设计中已包含</p><h3 id="四月份总结"><a href="#四月份总结" class="headerlink" title="四月份总结"></a>四月份总结</h3><ol><li>主要成就只有系统地学了一遍Python。</li><li>没有完成书的阅读任务</li><li>学习要安排在基础的工作时间以外。上个月因为工作比较闲，这个月安排时把很多工作时间都给排进去了，导致最后大量未完成。</li><li>周末、早上到公司后的1小时、晚上饭后1小时这三个是平常最适合学习的时间。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;个人2017年的学习规划。&lt;/p&gt;&lt;h2 id=&quot;总规划第一版-2017-03-28&quot;&gt;&lt;a href=&quot;#总规划第一版-2017-03-28&quot; class=&quot;headerlink&quot; title=&quot;总规划第一版-2017-03-28&quot;&gt;&lt;/a&gt;总规划第一版-2017-03-
      
    
    </summary>
    
      <category term="NOTE" scheme="http://longlog.me/categories/NOTE/"/>
    
    
      <category term="NOTE" scheme="http://longlog.me/tags/NOTE/"/>
    
  </entry>
  
  <entry>
    <title>博文阅读笔记 - 三月</title>
    <link href="http://longlog.me/2017/03/28/read-note-4/"/>
    <id>http://longlog.me/2017/03/28/read-note-4/</id>
    <published>2017-03-28T10:30:42.000Z</published>
    <updated>2019-08-29T07:09:16.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-3-28-新浪微博升级PHP7实践"><a href="#2017-3-28-新浪微博升级PHP7实践" class="headerlink" title="2017-3-28 新浪微博升级PHP7实践"></a>2017-3-28 新浪微博升级PHP7实践</h2><p>原文链接：<a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650994868&amp;idx=1&amp;sn=c79e0217ce2b3454c654fa9d90212d09&amp;chksm=bdbf00e78ac889f11e65c4cbbcb9ea903b65422da93e61936e7badc828aa98d9df5460a0f3d7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">新浪微博升级PHP7</a><br>原生的PHP，Zend引擎将php代码编译成opcode，再解释执行（执行C语言级的函数）。<br>HHVM替代了sZend引擎，PHP代码编译成字节码后，直接解释成机器的机器码执行。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-28-14906944807555.jpg" alt=""></p><h3 id="代码升级"><a href="#代码升级" class="headerlink" title="代码升级"></a>代码升级</h3><ol><li>一些Fatal可以通过catch Error进行捕获。</li><li>被0除，PHP7之前会产生WARNING并返回false，PHP7会返回+INF（正无穷），-INF（负无穷），INF（0/0）</li><li>取模0时，PHP7之前产生WARNING，PHP7抛出 DivisionByZeroError 异常</li><li>警告级别变更<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-28-14906967611663.jpg" alt=""></li></ol><p>…其他参考原文</p><h3 id="优化措施"><a href="#优化措施" class="headerlink" title="优化措施"></a>优化措施</h3><ol><li>启用Opcache</li><li>开启hugepage</li></ol><blockquote><p>操作系统默认的内存是以4KB分页的，而虚拟地址和内存地址需要转换， 而这个转换要查表，CPU为了加速这个查表过程会内建TLB(Translation Lookaside Buffer)。 显然，如果虚拟页越小，表里的条目数也就越多，而TLB大小是有限的，条目数越多TLB的Cache Miss也就会越高， 所以如果我们能启用大内存页就能间接降低这个TLB Cache Miss。<br>PHP7开启HugePage支持后，会把自身的text段, 以及内存分配中的huge都采用大内存页来保存, 减少TLB miss, 从而提高性能。相关实现可参考Opcache实现中的</p></blockquote><h2 id="2017-3-28-Redis架构之防雪崩设计"><a href="#2017-3-28-Redis架构之防雪崩设计" class="headerlink" title="2017-3-28 Redis架构之防雪崩设计"></a>2017-3-28 Redis架构之防雪崩设计</h2><p>原文链接：<a href="http://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug" target="_blank" rel="noopener">Redis架构之防雪崩设计</a></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>当请求的数据在缓存层和存储层中都不存在时，会发生缓存穿透，请求流量直接打到存储层。缓存穿透时缓存失去对后端的保护作用，容易被攻击者利用。<br>缓存穿透的解决方法：</p><ol><li>缓存空对象<br>当从存储层读不到数据时，在缓存中写入空对象，下次请求时直接返回空对象。<br>这种方案的缺点是如果被攻击，会消耗大量的内存空间（存储空对象），这种情况下，可以给空值缓存的key设置过期时间来缓解。</li><li>布隆过滤器<br>在redis之前加一层保护，定期更新一批存在的key。请求时，如果用布隆过滤器判断key不存在，则直接返回。<br>该方案的缺点是布隆过滤器的数据需要定期更新，在更新周期内可能存在数据不一致的情况。</li></ol><h3 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h3><p>当缓存无法提供服务时，所有的请求流量都会到存储层，存储层压力暴增，造成存储层不可用进而影响其他系统。<br>雪崩主要通过服务隔离、服务限流、服务降级、灾备演练等方法避免。</p><h3 id="热点Key优化"><a href="#热点Key优化" class="headerlink" title="热点Key优化"></a>热点Key优化</h3><p>一般缓存的key都存在失效失效时间，当热点key（并发请求量大）失效时，如果重建缓存的过程比较复杂（如多个SQL、多个依赖、逻辑复杂），大量服务器资源用于重建缓存，造成后端负载过大。<br>热点key优化的方法：</p><ol><li>重建缓存过程加锁<br>当某个进程发现key失效时，该进程对该key进行加锁（如setnx）后进入重建逻辑，其他进程请求该key的进程进入等待。<br>这种方法的缺点很明显，有可能造成死锁或者大量进程的等待。</li><li>逻辑上控制失效时间<br>在redis中不设置key的失效时间，业务逻辑上控制失效，当发现key失效时，发起一个异步重建的任务。<br>这种方法的缺点是在重建这段时间存在数据不一致，优点是能大大降低热点key失效时的负载（实际上相当于该key在redis中永远不会失效）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2017-3-28-新浪微博升级PHP7实践&quot;&gt;&lt;a href=&quot;#2017-3-28-新浪微博升级PHP7实践&quot; class=&quot;headerlink&quot; title=&quot;2017-3-28 新浪微博升级PHP7实践&quot;&gt;&lt;/a&gt;2017-3-28 新浪微博升级PHP7
      
    
    </summary>
    
      <category term="NOTE" scheme="http://longlog.me/categories/NOTE/"/>
    
    
      <category term="NOTE" scheme="http://longlog.me/tags/NOTE/"/>
    
  </entry>
  
  <entry>
    <title>nginx中的last和break</title>
    <link href="http://longlog.me/2017/03/17/nginx-rewrite-break/"/>
    <id>http://longlog.me/2017/03/17/nginx-rewrite-break/</id>
    <published>2017-03-17T09:02:22.000Z</published>
    <updated>2019-08-29T07:09:16.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="last后的操作"><a href="#last后的操作" class="headerlink" title="last后的操作"></a>last后的操作</h2><p>之前看大部分文档说的是：<br><strong>last</strong>是从server域开始重新请求。<br>nginx官方解释：</p><blockquote><p><strong>last：</strong><br>stops processing the current set of ngx_http_rewrite_module directives followed by a search for a new location matching the changed URI;<br><strong>break：</strong><br>stops processing the current set of ngx_http_rewrite_module directives;</p></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#location中的last</span></span><br><span class="line">rewrite /test2 /tt <span class="built_in">break</span>;</span><br><span class="line">  location /<span class="built_in">test</span> &#123;</span><br><span class="line">      rewrite /test2 /test3 <span class="built_in">break</span>;</span><br><span class="line">      rewrite /<span class="built_in">test</span> /test2 last;</span><br><span class="line">      rewrite /test2 /test3 <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  location /test2 &#123;</span><br><span class="line">      <span class="built_in">return</span> 508;</span><br><span class="line">  &#125;</span><br><span class="line">  location /test3 &#123;</span><br><span class="line">      <span class="built_in">return</span> 503;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>请求/test的结果:508,说明：</p><ol><li>location域里的last终止当前location下的所有rewrite(因为没有跳到test3),重启location匹配</li><li>重新发起请求后是从匹配location开始,不是从server域的rewrite开始(如果这样的话，应该跳转/tt,返回404)</li></ol><h2 id="server域里的last和break"><a href="#server域里的last和break" class="headerlink" title="server域里的last和break"></a>server域里的last和break</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#server中的last</span></span><br><span class="line">     rewrite /tt /index.html <span class="built_in">break</span>;</span><br><span class="line">     rewrite /test2 /tt last;</span><br><span class="line">     //rewrite /tt /index.html <span class="built_in">break</span>;</span><br><span class="line">     location /<span class="built_in">test</span> &#123;</span><br><span class="line">         rewrite /test2 /test3 <span class="built_in">break</span>;</span><br><span class="line">         rewrite /<span class="built_in">test</span> /test2 last;</span><br><span class="line">         rewrite /test2 /test3 <span class="built_in">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     location /test2 &#123;</span><br><span class="line">         <span class="built_in">return</span> 508;</span><br><span class="line">     &#125;</span><br><span class="line">     location /test3 &#123;</span><br><span class="line">         <span class="built_in">return</span> 503;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     location / &#123;</span><br><span class="line">         root   html;</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>请求/test2,返回404,将rewrite /tt的位置调整后,请求test2的返回结果还是404，说明：<br>server域里的last，会终止server的rewrite，进入location匹配（而不是从server头发起请求）。<br>所以，<strong>server域里的break和last的作用没有区别</strong>，都是终止rewrite进入location匹配.<br>总结：<br>1.server中的break终止rewrite进入location匹配<br>2.location中的break，终止当前请求的匹配工作，进入执行阶段</p><h2 id="location中rewrite的作用"><a href="#location中rewrite的作用" class="headerlink" title="location中rewrite的作用"></a>location中rewrite的作用</h2><p>补充一个nginx配置的问题，之前在nginx中加了如下配置，配置一些url的日志不打印</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ ^/+receiver.php$</span> &#123;</span><br><span class="line">    <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php(.*)$</span> &#123;</span><br><span class="line">  <span class="attribute">fastcgi_pass</span>    unix:/home/app/php/var/php-cgi.sock;</span><br><span class="line">  <span class="attribute">fastcgi_split_path_info</span>           <span class="regexp"> ^(.+\.php)(.*)$</span>;</span><br><span class="line">  <span class="attribute">fastcgi_param</span>   SCRIPT_FILENAME    <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">  <span class="attribute">fastcgi_param</span>   PATH_INFO    <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">  <span class="attribute">include</span>         fastcgi_params;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，发现所有的<code>/receiver.php</code>请求都直接返回了，没有经过php处理<br>location阶段如果没有进行break的话，不是应该进入到下一个location么？如下的配置,当请求/test时，返回的是509。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /test2 &#123;</span><br><span class="line">    return 509;</span><br><span class="line">&#125;</span><br><span class="line">location /test &#123;</span><br><span class="line">    rewrite /test /test1;</span><br><span class="line">    rewrite /test1 /test2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此看来，rewrite指令也会影响location阶段的后续处理，整理了下location中rewrite指令最后一个参数几种情况分别进行实验。</p><h3 id="有rewrite"><a href="#有rewrite" class="headerlink" title="有rewrite"></a>有rewrite</h3><h4 id="1-break"><a href="#1-break" class="headerlink" title="1.break"></a>1.break</h4><p>终止rewrite，进入请求处理阶段</p><h4 id="2-last"><a href="#2-last" class="headerlink" title="2.last"></a>2.last</h4><p>终止rewrite，重新开始匹配location</p><h4 id="3-redirect-perminate"><a href="#3-redirect-perminate" class="headerlink" title="3.redirect , perminate"></a>3.redirect , perminate</h4><p>301和302</p><h4 id="4-default-rewrite后不带指令"><a href="#4-default-rewrite后不带指令" class="headerlink" title="4.default(rewrite后不带指令)"></a>4.default(rewrite后不带指令)</h4><p>继续执行下一条rewrite指令，如果该条指令为最后一条，则执行处理请求的指令（如fastcgi_pass，proxy_pass），没有则继续匹配其他location。</p><h3 id="无rewrite"><a href="#无rewrite" class="headerlink" title="无rewrite"></a>无rewrite</h3><p>直接进入请求处理阶段</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;last后的操作&quot;&gt;&lt;a href=&quot;#last后的操作&quot; class=&quot;headerlink&quot; title=&quot;last后的操作&quot;&gt;&lt;/a&gt;last后的操作&lt;/h2&gt;&lt;p&gt;之前看大部分文档说的是：&lt;br&gt;&lt;strong&gt;last&lt;/strong&gt;是从server域
      
    
    </summary>
    
      <category term="Nginx" scheme="http://longlog.me/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://longlog.me/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>从配置Chares抓包理解HTTPS</title>
    <link href="http://longlog.me/2017/03/02/https/"/>
    <id>http://longlog.me/2017/03/02/https/</id>
    <published>2017-03-02T14:04:19.000Z</published>
    <updated>2019-08-29T07:09:16.066Z</updated>
    
    <content type="html"><![CDATA[<p>这两天看了一些https的文章，想起来之前捣鼓chares抓https包时一知半解，借这个问题总结一下Https。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在Chares里通过Proxy-&gt;SSL ProxySettings可以打开https代理，没有经过任何配置的话，抓包中看到的https链接是这样的。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884377678270.jpg" alt=""><br>要解决这个问题很简单，按照官方的说法，只需要安装Chares的证书并在系统设置中信任该证书即可。<br>这中间经历了什么过程，为什么安装证书后就可以看到https包内容，这就需要我们对https的原理有一定的了解。</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>在了解https之前，先简单说下加密算法。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>顾名思义，对称加密算法加密和解密用相同的密钥(Key)，密钥越大加密性越强，越不容易被破解。<br>常见的对称加密算法有DES、3DES、RC5等。<br>对称加密算法的优点是加密效率高，密钥足够大时安全性很强。缺点也很明显，发送者和接受者使用相同的密钥，发送者在发送消息时需要将密钥要发送给接受者，这样相当于没加密，密钥安全性无法保障。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>对比对称加密，非对称加密有两个密钥，公钥（Public Key）和私钥（Private Key）。公钥加密的数据只能由私钥解密，私钥加密的数据只能由公钥解密。私钥由发送者保存，公钥对外发布。<br>使用最广泛的非对称加密算法是RSA算法。<br>非对称加密算法的有点是在私钥不泄露情况下，能保证发送的消息不被篡改，收到的消息无法被破解，缺点是算法复杂度高，性能不如对称加密算法。<br>可以看出，<strong>在实际使用的安全性上</strong>，非对称加密算法要比对称加密算法高。这里强调的是使用安全性，因为就算法安全性来说，只要密钥够长，破解难度都是很高的。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>了解了加密算法，开始说说Https，思路主要是根据自己对Https的理解过程。</p><h3 id="裸奔"><a href="#裸奔" class="headerlink" title="裸奔"></a>裸奔</h3><p>对于http请求，在没有加密的时代，所有的请求参数都是对外暴露的。<br>对于攻击者来说，只要想办法拦截到用户的请求，很容易就能获取到交互内容和进行伪造。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884423572656.jpg" alt=""></p><h3 id="开始加密"><a href="#开始加密" class="headerlink" title="开始加密"></a>开始加密</h3><p>要保证请求的内容即使被拦截也无法破解，最简单的方法就是对请求内容进行加密，但是用哪种加密算法呢？<br>从使用安全性上考虑，当然是非对称加密算法。但是对于网络请求来说，性能就是生命，性能是第一要考虑的，因此性能更好的对称加密算法是首选。<br>从对加密算法的介绍中了解到，对称加密最大的问题在于，对于http请求来说，加密解密的密钥需要在Client和Server之间传输。如何保证密钥不被泄露？</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################10s分割线##################</span></span><br></pre></td></tr></table></figure><p>容易想到的是一点：Server一般都是接收多个Client的请求，因此为了保护密钥，这一点是肯定的：<strong>不同的会话需要使用不同的密钥</strong>。因此，在Client和Server通讯前必须有一个阶段，<strong>商量用什么密钥</strong>，就是密钥生成密钥的过程。<br>这样问题来了，这个商量的过程怎么保证不被泄露呢？ 再对这个商量过程进行对称加密？那你的这个加密过程又怎么保证呢？…无线循环了。<br>这时候，非对称加密就派上用场了。</p><h3 id="加密我的加密"><a href="#加密我的加密" class="headerlink" title="加密我的加密"></a>加密我的加密</h3><p>我们可以用非对称加密对密钥的生成过程进行加密。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884564685368.jpg" alt=""><br>如上图是一个的加密传输过程，使用非对称加密进行密钥生成，使用对称加密进行信息加密和传输。</p><ol><li>客户端请求服务端得到公钥。</li><li>客户端生成MasterKey并用公钥加密后发给服务端。</li><li>服务端接收到加密的信息并用私钥解密得到MasterKey。</li><li>服务端使用MasterKey加密Message发给客户端</li><li>客户端收到消息后用MasterKey解密出消息<br>至此，消息传输完成，使用非对称加密保证了MasterKey只有客户端和服务端知晓，从而保证了对称加密交互过程的信息安全。一个简化版本的Https交互完成。</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################10s分割线，想想该过程有什么问题？##################</span></span><br></pre></td></tr></table></figure><h4 id="认证机构-CA"><a href="#认证机构-CA" class="headerlink" title="认证机构(CA)"></a>认证机构(CA)</h4><p>上图的方案，解决了<strong>密钥的保护问题</strong>，但是会有另外一个问题，就是<strong>身份认证</strong>。<br>在第一步中，客户端请求服务端得到公钥，<strong>怎么确定这个公钥就是服务端的呢？</strong>。如果这一步的请求被第三方拦截了，返回给客户端第三方自己的公钥，整个交互过程又全暴露了。<br>具体的过程如下，容我偷懒盗个图。<a href="https://showme.codes/2017-02-20/understand-https/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">原图链接</a><br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884574921787.png" alt=""><br>可见，在非对称加密过程中，<strong>需要有公钥的身份验证，确保公钥不被篡改</strong>。<br>这时候，认证机构(Certification Authority)出现了，由认证机构负责对各Server的公钥进行管理。Server向认证机构申请了资格后，认证机构用自己的私钥给Server的公钥加密，生成一个”证明”。下次客户端请求时，服务端将这个”证明”返回给客户端。客户端用认证机构的公钥可以从证明中获取服务端的公钥。<br>那认证机构的公钥哪里来呢？总不能每次请求都访问一下认证机构吧。实际上，每台电脑上都保存着认证机构的信息，认证机构的公钥可以从客户端本地查询。</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>上文所说的这个”证明”，就是Https中的数字证书。数字证书由服务端向第三方机构申请，用于Https握手阶段的公钥身份验证。证书由第三方机构用私钥对申请信息(公钥)进行加密生成。<br><strong>注意，这里说的证书还只是第一版，并非最终的Https证书</strong></p><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>有了数字证书之后，我们来看下现在获取服务端公钥的过程。<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884592962322.jpg" alt=""><br>可以看到，在引入CA后，解决了公钥被伪造的问题。因为如果攻击者劫持请求并伪造了证书，证书的内容是没法被CA的公钥解密的。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################10s分割线，想想该过程有什么问题？##################</span></span><br></pre></td></tr></table></figure><p>我们聪明的攻击者又来了！，上面这个过程难道还有漏洞？<br>是的，刚刚说到，上面的证书没法被伪造，但是。。。如果攻击者补伪造证书，自己向第三方机构申请证书，并发给客户端呢？！！<br>大家在想一下这个过程，客户端收到攻击者自己的证书（该证书是合法申请的），用第三方机构公钥解密得到了<strong>客户端认为的服务端公钥</strong>，然后用这个实际上是攻击者的公钥进行密钥生成….信息又全暴露了。<br>所以，我们还需要<strong>对证书进行认证</strong>，数字签名的引入，就是为了解决该问题。<br>带数字签名的证书生成过程：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884612467318.jpg" alt=""><br>如上图，CA在生成证书时，对证书的内容进行单向加密(这里以Md5为例，可以是其他算法如SHA)生成<strong>摘要</strong>，对摘要用个人私钥进行加密生成了数字签名。<br>客户端获取到证书后，用CA的公钥对签名进行解密得到摘要，再用Md5对证书内容生成本地的摘要，只要对比两个摘要是否相同就能确认该证书是不是由机构签发的。这里的证书就是真正意义上的Https证书。<br>至此，Https的密钥生成和消息传递过程的安全问题解决了，<strong>@1不过大家可以再想想上面这个过程还有没有问题，什么情况下会被破解？</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的Https过程只说了最主要的部分，实际上Https的握手阶段还要更复杂一些。容我再偷张图：<br><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">原图链接</a> <img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884617468013.jpg" alt=""></p><ol><li>客户端发出协议版本号、一个客户端生成的随机数（<strong>RandomA</strong>），以及客户端支持的加密方法。</li><li>服务端确认双方使用的加密方法，并返回数字证书和一个服务端生成的随机数（<strong>RandomB</strong>）。</li><li>客户端确认数字证书有效（有效期、签名），然后生成一个新的随机数（<strong>RandomC</strong>），并使用数字证书中的公钥，加密这个随机数，发给服务端。</li><li>服务端使用私钥，解密得到发来的RandomC。</li><li>客户端和服务端根据约定的加密方法，使用RandomA、B、C生成对话密钥（<strong>Session Key</strong>），后续的对话由该Key进行加密解密。<br>过程中的三个随机数，可以保证之前所说的，对不同的客户端，使用不同的密钥。<h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2>回到之前的Chares配置的问题。现在想想，如果你是Chares的开发者，用户已经设置了Chares作为代理，要想查看Https的包内容，应该怎么办？</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################10s分割线##################</span></span><br></pre></td></tr></table></figure><p>根据上文理解的Https的过程，可以看到，第三方如果想查看和伪造https的内容，必须满足两点：</p><ol><li>自己当CA，给自己颁发个证书。</li><li>让客户端电脑信任自己(CA)。<br>这两个步骤实际上就是Chares配置https代理过程所做的事，配置完成后，可以查看https的包内容：<br><img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-03-02-14884622405300.jpg" alt=""></li></ol><p>从这里也可以回答上面@1的问题，<strong>当系统层面被被攻破后，https就不是安全的</strong>，这也是越狱的iPhone，Root的安卓、以前用安装盘安装的XP不安全的其中一个原因。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://mp.weixin.qq.com/s/7ImZolr7m3tUuyOgMJeFYg" target="_blank" rel="noopener">理解HTTPS为什么安全前，先看看这些东西</a><br><a href="https://showme.codes/2017-02-20/understand-https/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">也许，这样理解HTTPS更容易</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天看了一些https的文章，想起来之前捣鼓chares抓https包时一知半解，借这个问题总结一下Https。&lt;/p&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在Chare
      
    
    </summary>
    
      <category term="Web" scheme="http://longlog.me/categories/Web/"/>
    
    
      <category term="Web" scheme="http://longlog.me/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>swool2.0 协程</title>
    <link href="http://longlog.me/2017/02/09/swoole2-coroutine/"/>
    <id>http://longlog.me/2017/02/09/swoole2-coroutine/</id>
    <published>2017-02-09T12:42:22.000Z</published>
    <updated>2019-08-29T07:09:16.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-0更新说明"><a href="#2-0更新说明" class="headerlink" title="2.0更新说明"></a>2.0更新说明</h2><p><a href="https://wiki.swoole.com/wiki/page/672.html" target="_blank" rel="noopener">官方链接</a></p><blockquote><p>Swoole 2.0正式版发布了。2.0版本最大的更新是增加了对协程（Coroutine）的支持。正式版已同时支持PHP5和PHP7。基于Swoole2.0协程PHP开发者可以已同步的方式编写代码，底层自动进行协程调度，转变为异步IO。<strong>解决了传统异步编程嵌套回调的问题。</strong><br>与Node.js（ES6+）、Python等语言使用yield/generator、async/await的实现方式相比，Swoole协程无需修改代码添加额外的关键词。<br>与Go语言的goroutine相比，Swoole协程是内置式的，应用层代码无需添加go关键词启动协程，只需要使用封装好的协程客户端即可，使用更简单。另外Swoole协程的IO组件在底层内置了超时机制，不需要使用复杂的select/chan/timer实现客户端超时。<br>目前Swoole底层内置的协程客户端组件包括：udpclient、tcpclient、httpclient、redisclient、mysqlclient，基本涵盖了开发者常用的几种通信协议。协程组件只能在服务器的onConnect、onRequest、onReceive、onMessage 回调函数中使用。</p></blockquote><h2 id="关于协程"><a href="#关于协程" class="headerlink" title="关于协程"></a>关于协程</h2><h3 id="异步IO-Reactor"><a href="#异步IO-Reactor" class="headerlink" title="异步IO-Reactor"></a>异步IO-Reactor</h3><h4 id="同步IO"><a href="#同步IO" class="headerlink" title="同步IO"></a>同步IO</h4><p>当一个线程在进行io操作时，传统的处理方法线程会阻塞等待IO完成，等待过程无法接收其他请求，程序的并发能力存在很大的瓶颈。<br>可以通过多线程or多进程的方式提升程序的并发处理能力，但是没有本质上的提升。原因在于系统能创建的进程数量是有限的，并且阻塞IO这种等待自身就是对cpu资源的浪费。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>相对于同步IO，异步IO过程中，线程在IO开始时会注册系统回调，IO过程中线程可以进行其他工作，IO完成后执行回调进行后续操作。<br>可以看到，异步IO一个本质的区别是：<strong>同一个线程，能同时处理多个IO请求</strong>。这种情况下程序的并发能力有很大的提升。<br>例如某个IO请求的耗时为1s，在单线程同步IO方式下，理论上最大只能达到1qps，异步IO方式的qps远高于这个数。</p><h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><blockquote><p>一个IO操作其实分成了两个步骤：<strong>发起IO请求和实际的IO操作</strong><br><strong>阻塞IO和非阻塞IO的区别在于第一步</strong>：发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO;如果不阻塞，那么就是非阻塞IO<br><strong>同步IO和异步IO的区别就在于第二个步骤是否阻塞</strong>，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO;如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO</p></blockquote><h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h4><p>参考文章： <a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.html" target="_blank" rel="noopener">高性能IO</a><br>异步非阻塞的实现是应用了Reactor模式。用户线程向Reactor注册事件处理函数，Reactor负责管理EventHandler（注册、调用、删除）、轮询系统事件（通过epool或者select系统调用）。线程注册了EventHandler之后可以继续执行其他操作。<br>注意：</p><ol><li><strong>Reactor只是一个事件管理器，实际的IO操作是在EventHandler(用户实现)中完成的</strong>。</li><li><strong>异步非阻塞IO，实际上并不是真正的异步，因为程序接收的事件是：可读 or 可写，实际的读写操作都是需要应用自己完成（从socket读取）</strong>。</li><li><strong>完成的异步IO实现是Proactor模式，程序接收的事件是： 读取完成 or 写入完成了，读写操作由系统完成，应用从缓冲区读取</strong>。</li></ol><p>Reactor结构图：<img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-02-10-14867149196922.jpg" alt=""></p><p>Reactor时序图：<img src="https://longlog-1300108443.cos.ap-beijing.myqcloud.com/before2019/2017-02-10-14867149572894.jpg" alt=""></p><h4 id="Reactor和观察者模式的区别"><a href="#Reactor和观察者模式的区别" class="headerlink" title="Reactor和观察者模式的区别"></a>Reactor和观察者模式的区别</h4><p>观察者模式是一种一对多的<strong>发布-订阅</strong>的关系，更多应用于消息的分发。<br>Reactor更强调的是<strong>注册-回调</strong>，应用于高效率IO。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><blockquote><p>协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在。<br>个人理解，协程是应用层对异步IO的一种实现，封装了异步IO的回调、上下文切换等过程。</p></blockquote><h3 id="swoole的协程处理"><a href="#swoole的协程处理" class="headerlink" title="swoole的协程处理"></a>swoole的协程处理</h3><p>在swoole中使用自带协程的client，在进行io此操作时（如connect，query），swoole会保存当前的上下文信息保存在swoole开辟的栈内，然后将协程挂起等待返回。<br>io完成后，触发epool事件，协程切换，恢复上下文，继续执行php代码。<br>从处理流程可以看出，协程的实现是语言层面的实现，在操作系统中并没有这个概念，而进程和线程是操作系统级别的，其调度和上下文切换是由操作系统对外提供的api实现的。</p><h3 id="swoole2-0协程使用和性能测试"><a href="#swoole2-0协程使用和性能测试" class="headerlink" title="swoole2.0协程使用和性能测试"></a>swoole2.0协程使用和性能测试</h3><h4 id="开启协程："><a href="#开启协程：" class="headerlink" title="开启协程："></a>开启协程：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">phpize</span><br><span class="line">./configure --with-php-config=&#123;path-to-php-config&#125;  --<span class="built_in">enable</span>-coroutine</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>注意：<strong>目前只支持在onRequet, onReceive, onConnect事件回调函数中使用协程。</strong></p><h4 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$server = <span class="keyword">new</span> Swoole\Http\Server(<span class="string">'127.0.0.1'</span>, <span class="number">9501</span>);</span><br><span class="line">$dbConn = mysqli_connect(<span class="string">"127.0.0.1"</span> , <span class="string">"root"</span>, <span class="string">"secret"</span>, <span class="string">"homestead"</span>);</span><br><span class="line">$swooleDb = <span class="keyword">new</span> swoole_mysql;</span><br><span class="line">$server-&gt;set([</span><br><span class="line">     <span class="string">'worker_num'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="comment">/*触发on request事件时，SWOOLE会开辟一个协程栈，对协程栈进行初始化*/</span></span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($request, $response)</span> <span class="title">use</span> <span class="params">($dbConn, $swooleDb)</span></span>&#123;</span><br><span class="line">    $style = $request-&gt;get[<span class="string">"style"</span>];</span><br><span class="line">    <span class="comment">//传统方式，同步阻塞IO</span></span><br><span class="line">    <span class="keyword">if</span> ($style == <span class="string">"sync"</span>) &#123;</span><br><span class="line">        $res = mysqli_query($dbConn, <span class="string">"select sleep(1)"</span>);</span><br><span class="line">        $ret = mysqli_fetch_assoc($res);</span><br><span class="line">        <span class="keyword">echo</span> !<span class="keyword">empty</span>($ret) ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">        $response-&gt;end(<span class="string">"mysql sync is ok \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异步IO，swoole 1.8.5</span></span><br><span class="line">    <span class="keyword">if</span> ($style == <span class="string">"async"</span>) &#123;</span><br><span class="line">$swooleDb-&gt;connect(</span><br><span class="line">[<span class="string">"host"</span> =&gt; <span class="string">"127.0.0.1"</span>, </span><br><span class="line"> <span class="string">"user"</span> =&gt; <span class="string">"root"</span>, </span><br><span class="line"> <span class="string">"password"</span> =&gt; <span class="string">"secret"</span>, </span><br><span class="line"> <span class="string">"database"</span> =&gt; <span class="string">"test"</span>], </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="params">($swooleDb, $resp)</span> </span>&#123;</span><br><span class="line">    $sql = <span class="string">'select sleep(1)'</span>;</span><br><span class="line">    $swooleDb-&gt;query($sql, <span class="function"><span class="keyword">function</span><span class="params">(swoole_mysql $swooleDb, $res)</span> </span>&#123;</span><br><span class="line">    $response-&gt;end(<span class="string">"mysql async is ok \n"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//协程方式, swoole 2.0</span></span><br><span class="line">    <span class="keyword">if</span> ($style == <span class="string">"coroutine"</span>) &#123;</span><br><span class="line">        $swoole_mysql = <span class="keyword">new</span> Swoole\Coroutine\MySQL();</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        client在调用connect函数后，SWOOLE会将PHP上下文信息保存到当前栈内</span></span><br><span class="line"><span class="comment">        然后将协程挂起，待确认连接成功后，触发epoll事件，然后协程切换</span></span><br><span class="line"><span class="comment">        恢复PHP上下文信息，返回结果，继续执行PHP代码</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        $swoole_mysql-&gt;connect([</span><br><span class="line">            <span class="string">'host'</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">            <span class="string">'user'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line">            <span class="string">'password'</span> =&gt; <span class="string">'secret'</span>,</span><br><span class="line">            <span class="string">'database'</span> =&gt; <span class="string">'homestead'</span></span><br><span class="line">        ]);</span><br><span class="line">        $res = $swoole_mysql-&gt;query(<span class="string">'select sleep(1)'</span>);</span><br><span class="line">        <span class="keyword">echo</span> !<span class="keyword">empty</span>($res) ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">        $response-&gt;end(<span class="string">"mysql async is ok \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h3><h4 id="传统方式："><a href="#传统方式：" class="headerlink" title="传统方式："></a>传统方式：</h4><p>./bin/siege -c 10 -r 20 “<a href="http://127.0.0.1:9501/?style=sync&quot;" target="_blank" rel="noopener">http://127.0.0.1:9501/?style=sync&quot;</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Transactions:                 200 hits</span><br><span class="line">Availability:              100.00 %</span><br><span class="line">Elapsed time:              200.33 secs</span><br><span class="line">Data transferred:            0.00 MB</span><br><span class="line">Response time:                9.26 secs</span><br><span class="line">Transaction rate:            1.00 trans/sec</span><br><span class="line">Throughput:                0.00 MB/sec</span><br><span class="line">Concurrency:                9.25</span><br><span class="line">Successful transactions:         200</span><br><span class="line">Failed transactions:               0</span><br><span class="line">Longest transaction:           10.03</span><br><span class="line">Shortest transaction:            1.00</span><br></pre></td></tr></table></figure><h4 id="协程方式："><a href="#协程方式：" class="headerlink" title="协程方式："></a>协程方式：</h4><p>./bin/siege -c 10 -r 20 “<a href="http://127.0.0.1:9501/?style=coroutine&quot;" target="_blank" rel="noopener">http://127.0.0.1:9501/?style=coroutine&quot;</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Transactions:                 200 hits</span><br><span class="line">Availability:              100.00 %</span><br><span class="line">Elapsed time:               34.18 secs</span><br><span class="line">Data transferred:            0.00 MB</span><br><span class="line">Response time:                1.01 secs</span><br><span class="line">Transaction rate:            5.85 trans/sec</span><br><span class="line">Throughput:                0.00 MB/sec</span><br><span class="line">Concurrency:                5.89</span><br><span class="line">Successful transactions:         200</span><br><span class="line">Failed transactions:               0</span><br><span class="line">Longest transaction:            1.09</span><br><span class="line">Shortest transaction:            1.00</span><br></pre></td></tr></table></figure><p><strong>可以看到，单个线程处理耗时为1s的程序，传统处理方式的只能达到1qps，而协程方式能达到6qps</strong><br>swoole2之前提供的异步客户端和协程本质上没有区别，都是异步IO Reactor模型，所以没有进行性能测试。<br>相比于老的异步客户端的各种回调，从代码上可以看出来，协程的方式大大降低了代码的复杂度。<br>注意：<strong>协程组件只能在服务器的onConnect、onRequest、onReceive、onMessage 回调函数中使用。因为只有这些函数中swoole才会创建协程。</strong></p><h3 id="其他客户端的使用"><a href="#其他客户端的使用" class="headerlink" title="其他客户端的使用"></a>其他客户端的使用</h3><p><a href="https://wiki.swoole.com/wiki/page/672.html" target="_blank" rel="noopener">2.0.5使用示例</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>关于reactor，个人知识有限，了解的比较片面，详细的可以阅读下面这几篇大神文章。参考文章：<br><a href="http://rango.swoole.com/archives/508" target="_blank" rel="noopener">PHP并发IO编程之路</a><br><a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.html" target="_blank" rel="noopener">高性能IO模型</a><br><a href="http://www.cnblogs.com/ivaneye/p/5731432.html" target="_blank" rel="noopener">Reactor模型</a><br><a href="http://blog.csdn.net/mango_song/article/details/42643971" target="_blank" rel="noopener">epool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2-0更新说明&quot;&gt;&lt;a href=&quot;#2-0更新说明&quot; class=&quot;headerlink&quot; title=&quot;2.0更新说明&quot;&gt;&lt;/a&gt;2.0更新说明&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://wiki.swoole.com/wiki/page/672.htm
      
    
    </summary>
    
      <category term="PHP" scheme="http://longlog.me/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://longlog.me/tags/PHP/"/>
    
      <category term="Swoole" scheme="http://longlog.me/tags/Swoole/"/>
    
  </entry>
  
</feed>
