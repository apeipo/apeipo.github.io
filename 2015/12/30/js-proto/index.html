<!DOCTYPE html><html><head><meta charset="utf-8"><title>js中的__proto__和prototype | linxianlong的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Javascript,"><meta name="description" content="参考链接JS的prototype和proto原型链**jS核心指南**js对象模型原型误区prototype和__proto__的概念prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。__proto__是一个对象拥有的内置属性（请注意：prototype是函数的内置属性，proto是对象的内置属性），是JS"><meta name="keywords" content="Javascript"><meta property="og:type" content="article"><meta property="og:title" content="js中的__proto__和prototype"><meta property="og:url" content="http://longlog.me/2015/12/30/js-proto/index.html"><meta property="og:site_name" content="linxianlong的博客"><meta property="og:description" content="参考链接JS的prototype和proto原型链**jS核心指南**js对象模型原型误区prototype和__proto__的概念prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。__proto__是一个对象拥有的内置属性（请注意：prototype是函数的内置属性，proto是对象的内置属性），是JS"><meta property="og:locale" content="default"><meta property="og:image" content="http://7xrhmq.com1.z0.glb.clouddn.com/2016-03-03-14525824622530.jpg"><meta property="og:updated_time" content="2018-08-06T12:12:41.817Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="js中的__proto__和prototype"><meta name="twitter:description" content="参考链接JS的prototype和proto原型链**jS核心指南**js对象模型原型误区prototype和__proto__的概念prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。__proto__是一个对象拥有的内置属性（请注意：prototype是函数的内置属性，proto是对象的内置属性），是JS"><meta name="twitter:image" content="http://7xrhmq.com1.z0.glb.clouddn.com/2016-03-03-14525824622530.jpg"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE" href="/2018/08/06/2018-Target/">2018</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2017/03/28/MY-2017/">2017</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/2018/08/06/2018-Target/">2018</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prototype和-proto-的概念"><span class="toc-text">prototype和__proto__的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象创建过程"><span class="toc-text">对象创建过程</span></a></li></ol></div><div class="content-post LEFT"><article id="post-js-proto" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">js中的__proto__和prototype</h1><div class="article-meta"><span>2015-12-30</span> <span>| </span><span class="article-author">Linxianlong</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/前端/">前端</a></span></div></header><div class="article-content"><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.cnblogs.com/yangjinjin/archive/2013/02/01/2889103.html" target="_blank" rel="noopener">JS的prototype和<strong>proto</strong></a><br><a href="http://rockyuse.iteye.com/blog/1426510" target="_blank" rel="noopener">原型链</a><br><a href="http://www.cnblogs.com/ifishing/archive/2010/12/08/1900594.html" target="_blank" rel="noopener">**jS核心指南</a><br><a href="http://www.cnblogs.com/RicCC/archive/2008/02/15/JavaScript-Object-Model-Execution-Model.html" target="_blank" rel="noopener">**js对象模型</a><br><a href="http://www.laruence.com/2010/05/13/1462.html" target="_blank" rel="noopener">原型误区</a></p><h2 id="prototype和-proto-的概念"><a href="#prototype和-proto-的概念" class="headerlink" title="prototype和__proto__的概念"></a>prototype和<code>__proto__</code>的概念</h2><p><code>prototype</code>是函数的一个属性（每个<strong>函数</strong>都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。<br><code>__proto__</code>是一个<strong>对象</strong>拥有的内置属性（请注意：prototype是函数的内置属性，<strong>proto</strong>是对象的内置属性），是JS内部使用寻找原型链的属性。<br><code>__proto__</code><strong>指向的是对象构造函数的prototype</strong></p><blockquote><p>每个对象都会在其内部初始化一个属性，就是<code>__proto__</code>，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去<code>__proto__</code>里找这个属性，这个<code>__proto__</code>又会有自己的<code>__proto__</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p></blockquote><p>使用obj.propName访问一个对象的属性时，按照下面的步骤进行处理(假设obj的内部[[Prototype]]属性名为<code>__proto__</code>):</p><p>(1)如果obj存在propName属性，返回属性的值，否则<br>(2)如果<code>obj.__proto__</code>为null，返回undefined，否则<br>(3)返回<code>obj.__proto__.propName</code><br>调用对象的方法跟访问属性搜索过程一样，因为方法的函数对象就是对象的一个属性值。<br>提示: 上面步骤中隐含了一个递归过程，步骤3中<code>obj.__proto__</code>是另外一个对象，同样将采用1, 2, 3这样的步骤来搜索propName属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo.prototype.label = <span class="string">"laruence"</span>;</span><br><span class="line">alert(foo.label); <span class="comment">//output: laruence</span></span><br><span class="line">alert(Foo.label);<span class="comment">//output: undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Foo是函数，函数的构造函数都是Function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">alert(Foo.__proto__ === Foo.prototype); <span class="comment">//output: false</span></span><br><span class="line">alert(Foo.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">//output: true</span></span><br></pre></td></tr></table></figure><p><img src="http://7xrhmq.com1.z0.glb.clouddn.com/2016-03-03-14525824622530.jpg" alt=""></p><h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p>JS中只有函数对象具备类的概念，因此要创建一个对象，必须使用函数对象。<br>函数对象内部有[[Construct]]方法和[[Call]]方法，[[Construct]]用于构造对象，[[Call]]用于函数调用，只有使用new操作符时才触发[[Construct]]逻辑。<br>var obj=new Object(); 是使用<strong>内置的Object这个函数对象</strong>创建实例化对象obj。<br>var obj={};和var obj=[];这种代码将由JS引擎触发Object和Array的构造过程。function fn(){}; var myObj=new fn();是使用用户定义的类型创建实例化对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Person = function()&#123;&#125;;</span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure><p>new的过程拆分成以下三步：<br>(1) var p={}; 也就是说，初始化一个对象p<br>(2) p.<strong>proto</strong> = Person.prototype;<br>(3) Person.call(p); 也就是说构造p，也可以称之为初始化p</p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2015/12/30/js-proto/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>