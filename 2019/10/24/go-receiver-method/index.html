<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Go中指针和非指针Receiver的方法集 | apeipo的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Golang,"><meta name="description" content="在Go中，一个类型实现了某个接口，如果receiver是指针，虽然该类型的实例可以调用接口的方法，但是在进行接口类型判断时无法会被判定为该实例没有实现该接口。但是如果receiver不是指针，是没有问题的。参考代码如下：package mainimport &quot;fmt&quot;type SomeIf interface &amp;#123;	Print()&amp;#125;type SomeStruct struct &amp;"><meta name="keywords" content="Golang"><meta property="og:type" content="article"><meta property="og:title" content="Go中指针和非指针Receiver的方法集"><meta property="og:url" content="http://longlog.me/2019/10/24/go-receiver-method/index.html"><meta property="og:site_name" content="apeipo的博客"><meta property="og:description" content="在Go中，一个类型实现了某个接口，如果receiver是指针，虽然该类型的实例可以调用接口的方法，但是在进行接口类型判断时无法会被判定为该实例没有实现该接口。但是如果receiver不是指针，是没有问题的。参考代码如下：package mainimport &quot;fmt&quot;type SomeIf interface &amp;#123;	Print()&amp;#125;type SomeStruct struct &amp;"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2019-10-24T11:37:43.591Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Go中指针和非指针Receiver的方法集"><meta name="twitter:description" content="在Go中，一个类型实现了某个接口，如果receiver是指针，虽然该类型的实例可以调用接口的方法，但是在进行接口类型判断时无法会被判定为该实例没有实现该接口。但是如果receiver不是指针，是没有问题的。参考代码如下：package mainimport &quot;fmt&quot;type SomeIf interface &amp;#123;	Print()&amp;#125;type SomeStruct struct &amp;"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#另一种理解"><span class="toc-text">另一种理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-text">参考链接</span></a></li></ol></div><div class="content-post LEFT"><article id="post-go-receiver-method" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">Go中指针和非指针Receiver的方法集</h1><div class="article-meta"><span>2019-10-24</span> <span>| </span><span class="article-author">apeipo</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/Golang/">Golang</a></span></div></header><div class="article-content"><p>在Go中，一个类型实现了某个接口，如果receiver是指针，虽然该类型的实例可以调用接口的方法，但是在进行接口类型判断时无法会被判定为该实例没有实现该接口。但是如果receiver不是指针，是没有问题的。<br>参考代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SomeIf <span class="keyword">interface</span> &#123;</span><br><span class="line">	Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SomeStruct <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SomeStruct)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s SomeIf</span><br><span class="line">	ins := SomeStruct&#123;&#125;</span><br><span class="line">	ins.Print() <span class="comment">// ok</span></span><br><span class="line">	s = ins   <span class="comment">//compile error: cannot use ins (type SomeStruct) as type SomeIf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释这个问题，我们用<code>T</code>和<code>*T</code>分别代表一个类型的实例和指针。<br>在进行接口判定时，类型<code>T</code>的方法集只包含了receiver为T类型的方法，但是<code>*T</code>类型的方法集同时包含了receiver为<code>T</code>和<code>*T</code>的所有方法。<br>造成这个差异的主要原因是，将一个<code>*T</code>类型传递给一个接口时，任何<code>*T</code>都可以解引用得到<code>T</code>。<br>但是相反的，如果一个接口接收了一个T类型数据</p><ol><li>不是所有T都是addressable的。(addressable的定义见<a href="http://longlog.me/2019/10/23/go-addressable/">go-addressable</a>)</li><li>对于addresable的值，如果进行自动的取址，会带来语言层面的不一致</li></ol><p>如下case，buf实现了io.Writer接口，在buf的Write方法中会对buf的内容进行更改，而buf的receiver是指针，Write方法是直接更改调用者。<br>如果Go自动对<code>io.Copy(buf, os.Stdin)</code>中的buf进行自动取地址（假设这里不发生编译错误），会发生什么？</p><p><strong>重要</strong>：因为在函数调用过程会发生变量的复制，即io.Copy中的buf是原始buf变量的复制，从而Write方法中修改的只是buf的复制。从而会导致在Write方法中修改了buf，但是并没有修改原始的buf变量，<br>很明显，这样带来了不一致，因为我们都知道如果receiver是指针，那么方法中的修改应该是直接改调用者。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">io.Copy(buf, os.Stdin) <span class="comment">//compile error, buf not implument writer interface</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(buf *bytes.Buffer)</span> <span class="title">Write</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//modify the buf content</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="另一种理解"><a href="#另一种理解" class="headerlink" title="另一种理解"></a>另一种理解</h2><p>另外一种理解，参考这篇文章<a href="https://go101.org/article/unofficial-faq.html#unaddressable-values" target="_blank" rel="noopener">method_set</a>中的解释。<br>可以这么理解，对于每个定义在<code>T</code>类型上的方法，会自动生成一个<code>*T</code>类型的方法，在该方法中，自动对<code>*T</code>进行解引用再调用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">someMethod</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">auto</span> <span class="title">gen</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(t *T)</span> <span class="title">someMethod</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    (*t).someMethod(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反，如果对于每个<code>*T</code>上的方法，自动生成<code>T</code>的方法，如下代码，<strong>会导致什么问题？</strong><br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">someMethod</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    t.Name = <span class="string">"hehe"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//auto gen</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt T)</span> <span class="title">someMethod</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">    (&amp;rt).someMethod(...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := T&#123;&#125;</span><br><span class="line">a.someMethod()</span><br></pre></td></tr></table></figure><p></p><p>同样会产生上诉语言层面的不一致问题，因为rt是a的拷贝，在someMethod中的更改实际上只改了rt，没有更改a。<br>但是为什么现在在Go中，可以直接通过<code>T</code>调用<code>*T</code>上的方法？不会发生上诉的不一致问题？，因为这是go加的一个语法糖，在执行<code>a.someMethod</code>时，会自动对T进行取地址再调用<code>(&amp;a).someMethod</code>，如果a无法取地址(un_addresable)，会产生编译错误（如下代码）。（注意和上面代码的区别，是直接取地址，而不是一个方法间接调用）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> us <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *us)</span> <span class="title">pName</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(u.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">us&#123;<span class="string">"hehe"</span>&#125;.pName() <span class="comment">//runtime error, 因为us&#123;"hehe"&#125;是个字面量，是不可寻址的</span></span><br><span class="line"></span><br><span class="line"># command-line-arguments</span><br><span class="line">gpl/ref/addres.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">12</span>: cannot call pointer method on us literal</span><br><span class="line">gpl/ref/addres.<span class="keyword">go</span>:<span class="number">20</span>:<span class="number">12</span>: cannot take the address of us literal</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://golang.org/doc/faq#different_method_sets" target="_blank" rel="noopener">different_method_sets</a><br><a href="https://go101.org/article/unofficial-faq.html#unaddressable-values" target="_blank" rel="noopener">method_set</a></p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2019/10/24/go-receiver-method/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>