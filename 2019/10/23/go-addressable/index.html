<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>Go中的CanAddr和addresable | apeipo的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Golang,"><meta name="description" content="在Go中，通过反射来修改变量的值（即调用reflect.Value对象的SetXXX方法），必须保证reflect.Value是可寻址(addresable)的，reflect.Value的CanAddr判断一个Value是否可取地址。CanAddr reports whether the value’s address can be obtained with Addr. Such values"><meta name="keywords" content="Golang"><meta property="og:type" content="article"><meta property="og:title" content="Go中的CanAddr和addresable"><meta property="og:url" content="http://longlog.me/2019/10/23/go-addressable/index.html"><meta property="og:site_name" content="apeipo的博客"><meta property="og:description" content="在Go中，通过反射来修改变量的值（即调用reflect.Value对象的SetXXX方法），必须保证reflect.Value是可寻址(addresable)的，reflect.Value的CanAddr判断一个Value是否可取地址。CanAddr reports whether the value’s address can be obtained with Addr. Such values"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2019-10-24T11:34:01.116Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Go中的CanAddr和addresable"><meta name="twitter:description" content="在Go中，通过反射来修改变量的值（即调用reflect.Value对象的SetXXX方法），必须保证reflect.Value是可寻址(addresable)的，reflect.Value的CanAddr判断一个Value是否可取地址。CanAddr reports whether the value’s address can be obtained with Addr. Such values"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/styles.css"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?bec693dc99391bbe29dd7310e3fff81a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><body><div class="post-header LEFT"><div class="toolbox"><ul class="list-toolbox"><li class="item-toolbox"><a class="CIRCLE" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE" href="/about/">关于</a></li></ul></div><div class="toolbox tool-vertical" id="tool-vertical"><ul class="list-toolbox list-vertical"><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/">首页</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/categories/">分类</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/tags/">标签</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/link/">友链</a></li><li class="item-toolbox"><a class="CIRCLE VERTICAL" href="/about/">关于</a></li></ul></div><script type="text/javascript">function getStyle(e){return void 0===e.currentStyle?getComputedStyle(e):e.currentStyle}window.onscroll=function(){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop,t=document.getElementsByClassName("toolbox")[0],l=document.getElementById("tool-vertical"),o=getStyle(l).display,n=document.getElementsByClassName("CIRCLE VERTICAL");if(60<=e&&"none"==o){l.style.display="block",t.style.display="none";for(var s=0;s<n.length;s++)n[s].setAttribute("class","CIRCLE VERTICAL")}if(e<60&&"block"==o)for(t.style.display="block",setTimeout("document.getElementById('tool-vertical').style.display = 'none'",600),s=0;s<n.length;s++)n[s].setAttribute("class",n[s].className+" a-vertical")}</script></div><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#addressable"><span class="toc-text">addressable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么slice的元素一定是可寻址的"><span class="toc-text">为什么slice的元素一定是可寻址的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unaddressable-values"><span class="toc-text">unaddressable values</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么字符串的字节是不可寻址的"><span class="toc-text">为什么字符串的字节是不可寻址的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么map元素是不可寻址的"><span class="toc-text">为什么map元素是不可寻址的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可寻址的struct和array"><span class="toc-text">不可寻址的struct和array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CanAddr"><span class="toc-text">CanAddr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CanAddr和CanSet"><span class="toc-text">CanAddr和CanSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Addr和Pointer"><span class="toc-text">Addr和Pointer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-text">参考链接</span></a></li></ol></div><div class="content-post LEFT"><article id="post-go-addressable" class="article article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="post-title">Go中的CanAddr和addresable</h1><div class="article-meta"><span>2019-10-23</span> <span>| </span><span class="article-author">apeipo</span> <span>| </span><span class="article-category"><a class="article-category-link" href="/categories/Golang/">Golang</a></span></div></header><div class="article-content"><p>在Go中，通过反射来修改变量的值（即调用reflect.Value对象的SetXXX方法），必须保证reflect.Value是<strong>可寻址(addresable)</strong>的，reflect.Value的CanAddr判断一个Value是否可取地址。</p><blockquote><p>CanAddr reports whether the value’s address can be obtained with Addr. Such values are called addressable. A value is addressable if it is <strong>an element of a slice</strong>, <strong>an element of an addressable array</strong>, <strong>a field of an addressable struct</strong>, or <strong>the result of dereferencing a pointer.</strong> If CanAddr returns false, calling Addr will panic.</p></blockquote><p>当Value是可取址时，可以通过<code>value.SetXXX来修改value指向的值</code>。或者通过<code>value.Addr().Interface()</code>获取到interface再转换成实际的指针进行修改（本质上这两种方式是一样的，都是对Value中的ptr进行转换再修改）<br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">d := reflect.ValueOf(&amp;x).Elem()   <span class="comment">// d refers to the variable x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用set       </span></span><br><span class="line"><span class="comment">//d.SetInt(4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用指针</span></span><br><span class="line">px := d.Addr().Interface().(*<span class="keyword">int</span>) <span class="comment">// px := &amp;x</span></span><br><span class="line">*px = <span class="number">3</span>                           <span class="comment">// x = 3</span></span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure><p></p><p>在了解CanAddr之前需要了解一下addressable的概念</p><h2 id="addressable"><a href="#addressable" class="headerlink" title="addressable"></a>addressable</h2><p><a href="https://colobu.com/2018/02/27/go-addressable/" target="_blank" rel="noopener">go addressable 详解</a><br><a href="https://go101.org/article/unofficial-faq.html#unaddressable-values" target="_blank" rel="noopener">unaddressable-values</a><br>在Go中，对一个对象进行取址操作(&amp;x)，要求x必须是可取址(addressable)的，只有以下几种值是可寻址的：</p><ol><li>变量：<code>&amp;x</code></li><li><strong>可寻址</strong>struct的字段:<code>&amp;s.Name</code></li><li>slice(不管slice是否可寻址)元素：<code>&amp;arr[0]</code></li><li><strong>可寻址</strong>数组的元素：<code>&amp;a[0]</code></li><li>指针解引用操作获取的值：<code>x := &amp;somevar px:= &amp;*x</code></li></ol><h3 id="为什么slice的元素一定是可寻址的"><a href="#为什么slice的元素一定是可寻址的" class="headerlink" title="为什么slice的元素一定是可寻址的"></a>为什么slice的元素一定是可寻址的</h3><p>go中任意slice的底层结构都是一个reflect.SliceHeader的结构体，其data是一个指向其底层数组首元素的指针。从结构体可以看出来，<strong>任何slice的底层数组一定是可寻址的，否则无法得到data指针</strong>，因此任意slice的元素都是可寻址的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unaddressable-values"><a href="#unaddressable-values" class="headerlink" title="unaddressable values"></a>unaddressable values</h3><p>在这篇文章：<a href="https://go101.org/article/unofficial-faq.html#unaddressable-values" target="_blank" rel="noopener">不可寻址的values</a> 中详细列了不可寻址的值类型。主要包括：</p><ol><li>字符串中的字节(如<code>s := &quot;abc&quot; ps:=&amp;s[0]</code>)</li><li>map元素</li><li>通过<code>type assertions</code>获取的接口对象的动态值</li><li>常数</li><li>字面量</li><li>包级别的函数</li><li>用作函数值的方法</li><li>中间值<ul><li>函数调用</li><li>显示类型转换</li><li>各种类型操作的中间值（除了指针的取值操作）<ul><li>channel接收（如<code>&amp;&lt;-somechane</code>）</li><li>子字符串操作</li><li>子slice操作</li><li>加减乘除运算</li></ul></li></ul></li></ol><p><strong>注意第五条</strong>：<br>实际测试可以发现，字面量的结构体的寻址操作(<code>&amp;struct{Name string}{&quot;nn&quot;}</code>)是可以的，但是这并不意味着字面量结构体是可寻址的，因为这在go中这是一个语法糖(<code>&amp;struct{Name string}{&quot;nn&quot;}</code>)等价于<code>tmp := struct{Name string}{&quot;nn&quot;}; (&amp;tmp)</code>。</p><h3 id="为什么字符串的字节是不可寻址的"><a href="#为什么字符串的字节是不可寻址的" class="headerlink" title="为什么字符串的字节是不可寻址的"></a>为什么字符串的字节是不可寻址的</h3><p>因为字符串是不可变的，如果其字节是可寻址的，就可以通过指针修改值，破坏了定义。<br>同理，常量不可更改也是这个原因。</p><h3 id="为什么map元素是不可寻址的"><a href="#为什么map元素是不可寻址的" class="headerlink" title="为什么map元素是不可寻址的"></a>为什么map元素是不可寻址的</h3><p>两个原因：</p><ol><li>map[“key”]取元素的操作，不管map为nil或者不包含该key，都会默认返回一个类型的零值。为了安全考虑，类型的该零值是不可寻址的（另外一点，即使零值是可寻址的，也需要在运行时判断一个值是否是类型零值）。</li><li>map元素的地址可能发生变化，如果允许寻址，可能导致获取的地址在之后无效。</li></ol><h3 id="不可寻址的struct和array"><a href="#不可寻址的struct和array" class="headerlink" title="不可寻址的struct和array"></a>不可寻址的struct和array</h3><p>一些字面量的struct和array是不可寻址的，其元素也是不可寻址的。注意slice和array的区别，<strong>slice任意情况下都可以寻址</strong><br></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//error</span></span><br><span class="line">a := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;&#123;<span class="string">"x"</span>&#125;.Name</span><br><span class="line"></span><br><span class="line"><span class="comment">//error</span></span><br><span class="line">b := &amp;[<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">//correct</span></span><br><span class="line">c := &amp;[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p></p><h3 id="CanAddr"><a href="#CanAddr" class="headerlink" title="CanAddr"></a>CanAddr</h3><p><code>CanAddr</code>只有以下几种类型的<code>reflect.Value</code>才返回true：</p><ol><li>slice元素</li><li>可寻址数组的元素</li><li>可寻址struct的field</li><li>指针解引用的结果</li></ol><p><strong>对比addressable的定义，少了变量</strong>。变量是addressable的但是它的reflect.Value不是<code>CanAddr</code>的，主要因为栈上的变量在函数调用结束时会被释放，如果是CanAddr的可能带来安全问题（例如对函数内的变量执行Addr后返回）。对比对变量进行寻址不会有安全问题，因为如果变量的地址在函数外部保存了，逃逸分析会将该变量改为在堆上开辟空间。</p><p>注意第四条：<strong>只有指针解引用的结果的Value是CanAddr的，但是指针本身的Value是不能Addr的</strong>（如<code>reflect.ValueOf(&amp;x)</code>不是CanAddr的，但是<code>reflect.ValueOf(&amp;x).Elem()</code>可以）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> refStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//error</span></span><br><span class="line">s := refStruct&#123;&#125;</span><br><span class="line">svN := reflect.ValueOf(s).FieldByName(<span class="string">"Name"</span>)</span><br><span class="line"><span class="comment">//panic: reflect: reflect.Value.SetString using unaddressable value</span></span><br><span class="line">svN.SetString(<span class="string">"hehe"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//correct</span></span><br><span class="line">s := refStruct&#123;&#125;</span><br><span class="line">svN := reflect.ValueOf(&amp;s).Elem().FieldByName(<span class="string">"Name"</span>)</span><br><span class="line">svN.SetString(<span class="string">"hehe"</span>)</span><br></pre></td></tr></table></figure><h3 id="CanAddr和CanSet"><a href="#CanAddr和CanSet" class="headerlink" title="CanAddr和CanSet"></a>CanAddr和CanSet</h3><p><code>CanAddr</code>和<code>CanSet</code>的区别在于<code>CanSet</code>还会判断struct的filed是否是可导出的，只有可导出的字段才能修改。</p><blockquote><p>CanAddr reports whether the value’s address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic.</p></blockquote><h4 id="Addr和Pointer"><a href="#Addr和Pointer" class="headerlink" title="Addr和Pointer"></a>Addr和Pointer</h4><p>Pointer返回一个指针指向的地址(uintptr)，只有chanel、slice、map、func、指针类型可以调用<br>Addr对value进行取址操作，并返回一个原始value指针的Value，原始value.CanAddr为true时才能调用</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://colobu.com/2018/02/27/go-addressable/" target="_blank" rel="noopener">Go-addresable详解</a></p></div></article><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><script type="text/javascript">!function(){var t=document.getElementsByTagName("article")[0];if(null!=t){imgs=t.getElementsByTagName("img");for(var e=0;e<imgs.length;e++)img=imgs[e],width=parseInt(img.getAttribute("alt").replace("-w","")),0<width&&img.setAttribute("style","width:"+width+"px")}}()</script><script>var disqus_shortname="apeipo",disqus_url="http://longlog.me/2019/10/23/go-addressable/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></body>